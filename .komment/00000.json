[
  {
    "name": "long_term_graph.py",
    "path": "agents/long_term_spatial_memory_agent/src/long_term_graph.py",
    "content": {
      "structured": {
        "description": "A class `Room` that represents a 3D room in a graph, with nodes representing corners and edges representing walls. The class provides methods for calculating the projective coordinates (4x1) of the corners and objects in the room frame, as well as for drawing the room and its objects on a plot. The code uses the `networkx` and `scipy.spatial` libraries to manipulate and analyze the graph data.",
        "items": [
          {
            "id": "e77351db-7a15-56b3-3644-4399c887d62b",
            "ancestors": [],
            "description": "Provides a user interface for visualizing and exploring a graph, including rooms and doors. It allows for adding nodes, edges, and doors, as well as displaying room names and distances between nodes.",
            "attributes": [
              {
                "name": "g",
                "type_name": "str|int",
                "description": "Used to specify the color of the graph's edges. It can be set to a valid matplotlib color name or an integer value between 0 and 1, representing the transparency level of the edge."
              },
              {
                "name": "read_graph",
                "type_name": "Callable[[str],Dict[str,float]]",
                "description": "Used to read a graph from a file specified by the filename parameter. It returns a dictionary containing the graph data as key-value pairs where keys are node or edge indices and values are the corresponding coordinates or weights."
              },
              {
                "name": "fig",
                "type_name": "matplotlibfigureFigure",
                "description": "Used to represent the figure object that will be drawn with the graph. It contains information about the figure, such as its size, layout, and any additional elements that will be displayed in it."
              },
              {
                "name": "ax",
                "type_name": "matplotlibpyplotAxes",
                "description": "Used to represent a 2D axes object that displays the graphical representation of the long-term graph."
              },
              {
                "name": "fig_2",
                "type_name": "matplotlibfigureFigure",
                "description": "Used to store the figure object for the second graph."
              },
              {
                "name": "ax_2",
                "type_name": "AxesSubplot|MatplotlibFigure",
                "description": "Used to store a secondary axes object, which can be used to display additional visualizations or metrics alongside the primary graph."
              }
            ],
            "name": "LongTermGraph",
            "location": {
              "start": 15,
              "insert": 16,
              "offset": " ",
              "indent": 4,
              "comment": null
            },
            "item_type": "class",
            "length": 269,
            "docLength": null
          },
          {
            "id": "35f455db-0eef-1ba5-f04f-cb6cacf60abb",
            "ancestors": [
              "e77351db-7a15-56b3-3644-4399c887d62b"
            ],
            "description": "Reads a graph from a file, creates an igraph object, and displays both the original graph and its metric reconstruction using matplotlib.",
            "params": [
              {
                "name": "file_name",
                "type_name": "str",
                "description": "Used to specify the name of the graph file that contains the LTSM data to be reconstructed."
              }
            ],
            "returns": null,
            "usage": {
              "language": "python",
              "code": "from LongTermGraph import LongTermGraph\n\n# create an instance of the class and set its name\nltg = LongTermGraph(\"my_graph.pickle\")\n\n# print the summary of the graph\nprint(ltg.summary())\n\n# plot the graph on a matplotlib figure\nltg.plot()\n",
              "description": ""
            },
            "name": "__init__",
            "location": {
              "start": 16,
              "insert": 17,
              "offset": " ",
              "indent": 8,
              "comment": null
            },
            "item_type": "constructor",
            "length": 22,
            "docLength": null
          },
          {
            "id": "252c67c9-d429-faa7-ef4a-8d465711c8a0",
            "ancestors": [
              "e77351db-7a15-56b3-3644-4399c887d62b"
            ],
            "description": "Generates a graph based on a subgraph of the original graph, with only certain types of nodes and edges visible.",
            "params": [
              {
                "name": "only_rooms",
                "type_name": "bool",
                "description": "Used to filter out nodes that are not rooms or doors, and edges that do not connect rooms or doors."
              }
            ],
            "returns": null,
            "usage": {
              "language": "python",
              "code": "# create an instance of LongTermGraph class and read graph from file\nmy_graph = LongTermGraph(\"myfile.pkl\")\n\n# draw graph with only rooms\nmy_graph.draw_graph(only_rooms=True)\n\n# draw graph with all nodes including walls, doors, and rooms\nmy_graph.draw_graph()\n",
              "description": ""
            },
            "name": "draw_graph",
            "location": {
              "start": 252,
              "insert": 253,
              "offset": " ",
              "indent": 8,
              "comment": null
            },
            "item_type": "method",
            "length": 33,
            "docLength": null
          }
        ]
      }
    }
  },
  {
    "name": "genericworker.py",
    "path": "agents/g2o_agent/src/genericworker.py",
    "content": {
      "structured": {
        "description": "A worker class that inherits from QtWidgets.QWidget and provides a kill signal for shutting down the worker. The code also sets up an ice slice and imports a RoboCompCommonBehavior module. Additionally, the code creates a Ui_guiDlg class and initializes a timer to call a method every 30 milliseconds.",
        "items": [
          {
            "id": "cb6f42fc-bcd1-7fb5-eb49-91afccba59e8",
            "ancestors": [],
            "description": "Manages a worker process with a periodic timer and provides a signal for termination. It also has a method to set the period of the timer.",
            "attributes": [
              {
                "name": "kill",
                "type_name": "QtCoreSignal",
                "description": "Used to emit a signal when the object needs to be killed."
              },
              {
                "name": "ui",
                "type_name": "Ui_guiDlg",
                "description": "Used to initialize and access the user interface of the widget."
              },
              {
                "name": "mutex",
                "type_name": "QMutex",
                "description": "Used to protect access to the internal state of the worker object, particularly the timer and kill signal."
              },
              {
                "name": "Period",
                "type_name": "int",
                "description": "30 milliseconds by default, which represents the time interval for the timer to run."
              },
              {
                "name": "timer",
                "type_name": "QTimer",
                "description": "Used to schedule a call to the `killYourSelf` slot after a specified period of time."
              }
            ],
            "name": "GenericWorker",
            "location": {
              "start": 43,
              "insert": 45,
              "offset": " ",
              "indent": 4,
              "comment": null
            },
            "item_type": "class",
            "length": 26,
            "docLength": null
          },
          {
            "id": "795c292f-f253-f1aa-a748-23953c9013be",
            "ancestors": [
              "cb6f42fc-bcd1-7fb5-eb49-91afccba59e8"
            ],
            "description": "Initializes an instance of the `GenericWorker` class, setting up a GUI dialog and creating a mutex for managing access to the timer. It also sets the period of the timer to 30 seconds.",
            "params": [
              {
                "name": "mprx",
                "type_name": "Ui_guiDlg",
                "description": "Used as an argument for the setupUi method."
              }
            ],
            "returns": null,
            "name": "__init__",
            "location": {
              "start": 47,
              "insert": 48,
              "offset": " ",
              "indent": 8,
              "comment": null
            },
            "item_type": "method",
            "length": 9,
            "docLength": null
          },
          {
            "id": "ea51cd3f-4286-88a2-5c4e-a765280c1202",
            "ancestors": [
              "cb6f42fc-bcd1-7fb5-eb49-91afccba59e8"
            ],
            "description": "Emits the `kill` signal, indicating that the instance should be destroyed.",
            "params": [],
            "returns": null,
            "name": "killYourSelf",
            "location": {
              "start": 60,
              "insert": 62,
              "offset": " ",
              "indent": 8,
              "comment": null
            },
            "item_type": "method",
            "length": 4,
            "docLength": null
          },
          {
            "id": "20082581-a4f0-66af-9a45-78e2e70b070f",
            "ancestors": [
              "cb6f42fc-bcd1-7fb5-eb49-91afccba59e8"
            ],
            "description": "Updates the `Period` attribute and starts a timer with the new period value using the `timer.start()` method.",
            "params": [
              {
                "name": "p",
                "type_name": "int",
                "description": "Used to set the new period for the timer."
              }
            ],
            "returns": null,
            "name": "setPeriod",
            "location": {
              "start": 67,
              "insert": 69,
              "offset": " ",
              "indent": 8,
              "comment": null
            },
            "item_type": "method",
            "length": 5,
            "docLength": null
          }
        ]
      }
    }
  },
  {
    "name": "specificworker.py",
    "path": "agents/g2o_agent/src/specificworker.py",
    "content": {
      "structured": {
        "description": "a class called `Robot` that interacts with a graph representing a robot's environment and its movements. The class has several methods for adding, updating, and deleting nodes and edges in the graph, as well as updating edge attributes. It also keeps track of the robot's current position and orientation, and uses this information to update its graph representation.\n\nThe code uses the `networkx` library to represent the graph, and the `time` module for timing purposes. The class has methods to initialize and update the graph, as well as to handle various events such as new nodes or edges being added, or a room changing. It also has methods to delete nodes and edges when they are no longer needed.\n\nOverall, the code is concerned with maintaining an accurate representation of the robot's environment and movements, and updating this representation in response to changes in the graph.",
        "items": [
          {
            "id": "f9d0a7c6-bb7a-81a5-5c42-4fecec81e359",
            "ancestors": [],
            "description": "Manages a graph-based representation of an environment and its objects, providing functions for updating node and edge attributes, deleting nodes and edges, and handling RT messages. It also maintains a set of rooms and their initial positions.",
            "attributes": [
              {
                "name": "Period",
                "type_name": "float|int",
                "description": "Set to `200` by default, indicating the time interval (in milliseconds) between successive calls to the `update` method. It determines how frequently the worker updates its state."
              },
              {
                "name": "agent_id",
                "type_name": "int|str",
                "description": "Used to identify the worker's agent in the simulation environment."
              },
              {
                "name": "g",
                "type_name": "Graph|NetworkXGraph",
                "description": "Used for managing graphs in the worker's update and delete operations."
              },
              {
                "name": "startup_check",
                "type_name": "QTimersingleShot200,QApplicationinstancequit",
                "description": "Used to check if the application should quit after a certain period of time."
              },
              {
                "name": "rt_api",
                "type_name": "str|int",
                "description": "Used to store the last RT (Real-time) edge set id that was received by the worker, so it can check if a new RT edge set has been received since the last time it was checked."
              },
              {
                "name": "inner_api",
                "type_name": "Callable[[],None]",
                "description": "Used to define a custom API for the worker to interact with its internal state and update its graph."
              },
              {
                "name": "odometry_node_id",
                "type_name": "int",
                "description": "Used to store the ID of the node representing the shadow robot in the graph, which is used for updating the robot's odometry."
              },
              {
                "name": "odometry_queue",
                "type_name": "List[Tuple[float,float,float,int]]",
                "description": "Used to store the odometry data points received from the ROS node. It is updated every 200 milliseconds."
              },
              {
                "name": "last_odometry",
                "type_name": "float|List[float]",
                "description": "Used to store the last known odometry values (position, orientation, and advance speed) for the robot."
              },
              {
                "name": "g2o",
                "type_name": "None|Graph2O",
                "description": "Used to store the graph data in Graph2O format for the robot's environment."
              },
              {
                "name": "odometry_noise_std_dev",
                "type_name": "float|int",
                "description": "Used to control the noise level in robot odometry readings."
              },
              {
                "name": "odometry_noise_angle_std_dev",
                "type_name": "float|int",
                "description": "0.1 by default, representing the standard deviation of the angle noise added to the robot's odometry measurements during simulation."
              },
              {
                "name": "measurement_noise_std_dev",
                "type_name": "float|double",
                "description": "Used to represent the standard deviation of measurement noise in the worker's measurements. It is used to simulate random fluctuations in the measurements during training."
              },
              {
                "name": "last_room_id",
                "type_name": "int|str",
                "description": "Used to store the last room ID seen by the worker before changing rooms, which allows the worker to track the current room ID."
              },
              {
                "name": "actual_room_id",
                "type_name": "str|int",
                "description": "Used to keep track of the current room ID that the worker is in, during its execution"
              },
              {
                "name": "elapsed",
                "type_name": "float|int",
                "description": "Used to store the elapsed time since the worker's last call to the `update` method, which can be used to control the worker's execution rate."
              },
              {
                "name": "room_initialized",
                "type_name": "bool",
                "description": "Used to track whether a specific room has been initialized for RT mapping. It is set to False when the room is first encountered, and True when it has been successfully mapped with the robot's pose."
              },
              {
                "name": "iterations",
                "type_name": "int|float",
                "description": "Used to keep track of the number of iterations of the worker's tasks that have been performed."
              },
              {
                "name": "hide",
                "type_name": "bool",
                "description": "Used to hide or show the worker's updates during simulation."
              },
              {
                "name": "init_graph",
                "type_name": "bool",
                "description": "Set to True when the worker initializes its graph and False otherwise, indicating whether the graph has been initialized or not."
              },
              {
                "name": "current_edge_set",
                "type_name": "bool",
                "description": "Used to keep track of whether the current edge set has been updated recently, indicating when a new RT translation or rotation should be computed. It is set to True after each edge set update and reset to False after a certain time interval (defined as `rt_time_min` in the code) has passed without any updates, to avoid computing unnecessary RT translations or rotations."
              },
              {
                "name": "first_rt_set",
                "type_name": "bool",
                "description": "Set to True when the RT translation and rotation are first detected, False otherwise. It indicates whether the RT set has been detected for a given edge."
              },
              {
                "name": "translation_to_set",
                "type_name": "float|List[float]",
                "description": "Used to store the translation of the robot to set. It is updated when the RT transmission is received and its value represents the distance from the origin of the robot's frame to the origin of the set frame in the global coordinate system."
              },
              {
                "name": "rotation_to_set",
                "type_name": "float|List[float]",
                "description": "Used to store the Euler angles representing the rotation from the current room to the target set."
              },
              {
                "name": "room_polygon",
                "type_name": "List[float]",
                "description": "Used to store the coordinates of a polygon representing the boundary of a room in the environment, which is used for collision detection and avoidance."
              },
              {
                "name": "security_polygon",
                "type_name": "Shape|str",
                "description": "Used to store a polygon that defines the security area around the robot, which is used for collision detection and obstacle avoidance."
              },
              {
                "name": "initialize_g2o_graph",
                "type_name": "void",
                "description": "Used to initialize a Graph2O graph, which is a data structure representing a robot's environment, and perform other operations such as adding nodes and edges, setting attributes, and updating node positions."
              },
              {
                "name": "rt_set_last_time",
                "type_name": "float|int",
                "description": "Used to track the time since the last RT set was created by the worker. It is used to determine when to set a new RT translation and rotation value."
              },
              {
                "name": "rt_time_min",
                "type_name": "float|int",
                "description": "Defined as the minimum time interval between consecutive RT sets. Its purpose is to ensure that the robot's motion is smooth and does not oscillate excessively during navigation."
              },
              {
                "name": "last_update_with_corners",
                "type_name": "int|bool",
                "description": "Used to keep track of the last time corners were updated. When the corner of a room was updated, it's set to True, otherwise it's set to False."
              },
              {
                "name": "timer",
                "type_name": "QTimersingleShot200,QApplicationinstancequit",
                "description": "Used to schedule a call to the `QApplication.instance().quit()` function after 200 milliseconds. This allows the worker to run indefinitely until the user presses the \"Stop\" button."
              },
              {
                "name": "compute",
                "type_name": "Callable[[],float]",
                "description": "Used to compute the next node id to update based on the current node id and the edge id. It takes no arguments and returns a floating-point value representing the next node id to update."
              },
              {
                "name": "update_node_att",
                "type_name": "List[str]",
                "description": "Used to update the attributes of a node in the graph based on certain conditions, such as when the node's id matches the `odometry_node_id` constant."
              },
              {
                "name": "update_edge",
                "type_name": "Callable[[int,int,str],None]",
                "description": "Called when an edge's type changes to \"RT\". It sets the `translation_to_set`, `rotation_to_set`, and `rt_set_last_time` attributes based on the new RT translation and rotation."
              },
              {
                "name": "update_edge_att",
                "type_name": "List[str]",
                "description": "Used to update the attributes of an edge based on a specific condition. It takes three parameters: `fr`, `to`, and `type`, which are the ID of the edge being updated, its destination ID, and the type of update respectively."
              }
            ],
            "name": "SpecificWorker",
            "location": {
              "start": 50,
              "insert": 51,
              "offset": " ",
              "indent": 4,
              "comment": null
            },
            "item_type": "class",
            "length": 423,
            "docLength": null
          },
          {
            "id": "1c3f1211-7524-8695-b942-f5e904197296",
            "ancestors": [
              "f9d0a7c6-bb7a-81a5-5c42-4fecec81e359"
            ],
            "description": "Initializes various components of the worker, including the graph, odometry queue, and timer. It also sets up signal connections for updates on nodes and edges.",
            "params": [
              {
                "name": "proxy_map",
                "type_name": "Dict[str, Any]",
                "description": "Used to store map-related information, such as the graph's nodes and edges, which are required for the worker's functionality."
              },
              {
                "name": "startup_check",
                "type_name": "bool",
                "description": "Used to check if the graph has been properly initialized before proceeding with the worker's tasks."
              }
            ],
            "returns": null,
            "usage": {
              "language": "python",
              "code": "# Initialize the class with the proxy_map and startup check parameter set to False\nworker = SpecificWorker(proxy_map, startup_check=False)\n\n# Set the agent ID and initialize the graph\nworker.agent_id = 20\nworker.initialize_graph()\n\n# Connect the signals for updating node attributes, deleting nodes, and updating edges\nsignals.connect(worker.g, signals.UPDATE_NODE_ATTR, worker.update_node_att)\nsignals.connect(worker.g, signals.DELETE_NODE, worker.delete_node)\nsignals.connect(worker.g, signals.UPDATE_EDGE, worker.update_edge)\nsignals.connect(worker.g, signals.UPDATE_EDGE_ATTR, worker.update_edge_att)\n",
              "description": "\nThis code initializes the SpecificWorker class with a proxy map and sets its agent ID to 20. It then connects the signals for updating node attributes, deleting nodes, and updating edges using the signals module."
            },
            "name": "__init__",
            "location": {
              "start": 51,
              "insert": 52,
              "offset": " ",
              "indent": 8,
              "comment": null
            },
            "item_type": "constructor",
            "length": 54,
            "docLength": null
          },
          {
            "id": "ee0a9d1b-9271-b39a-5e4f-64e1d858f292",
            "ancestors": [
              "f9d0a7c6-bb7a-81a5-5c42-4fecec81e359"
            ],
            "description": "Performs the following tasks:\n\n1. Checks if enough time has passed since the last frame was computed.\n2. Updates the robot's position and orientation using odometry data.\n3. Generates a new RT edge for the robot based on its current position and orientation.\n4. Adds the new RT edge to the graph.",
            "params": [],
            "returns": null,
            "usage": {
              "language": "python",
              "code": "worker = SpecificWorker() # Create a new instance of the worker class\nworker.compute() # Call the compute method of the worker with no arguments\n",
              "description": "\nThis code creates a new instance of the `SpecificWorker` class and calls its `compute()` method, which is expected to perform some computation using the data stored in the worker's variables. However, without knowing more about the implementation details of the worker's `compute()` method, it is difficult to provide a more detailed example of how this function might be used by an end-user."
            },
            "name": "compute",
            "location": {
              "start": 123,
              "insert": 125,
              "offset": " ",
              "indent": 8,
              "comment": null
            },
            "item_type": "method",
            "length": 103,
            "docLength": null
          },
          {
            "id": "433924a0-c643-1c86-c947-e424e514e8fb",
            "ancestors": [
              "f9d0a7c6-bb7a-81a5-5c42-4fecec81e359"
            ],
            "description": "1) retrieves nodes and edges from the ROS topic, 2) validates node and edge presence, 3) adds nominal corners and fixed poses to the G2O graph for robot and door nodes, and 4) initializes last odometry timestamp.",
            "params": [],
            "returns": {
              "type_name": "bool",
              "description": "1 if the initialization of the G2O graph was successful, and 0 otherwise."
            },
            "usage": {
              "language": "python",
              "code": "# create graph and object for g2o\ng = DSRGraph(0, \"G2O_agent\", agent_id)\nspecific_worker = SpecificWorker(proxy_map, startup_check=False)\nspecific_worker.rt_api = rt_api(g)\nspecific_worker.inner_api = inner_api(g)\n\n# initialize g2o graph\nspecific_worker.initialize_g2o_graph()\n",
              "description": ""
            },
            "name": "initialize_g2o_graph",
            "location": {
              "start": 253,
              "insert": 256,
              "offset": " ",
              "indent": 8,
              "comment": null
            },
            "item_type": "method",
            "length": 115,
            "docLength": null
          },
          {
            "id": "1a1a98ec-b136-4690-5d41-202f10833328",
            "ancestors": [
              "f9d0a7c6-bb7a-81a5-5c42-4fecec81e359"
            ],
            "description": "Calculates the displacement of a robot based on its odometry data, computing the lateral displacement, forward displacement, and angular displacement.",
            "params": [
              {
                "name": "odometry",
                "type_name": "Tuple[float, float, float]",
                "description": "A sequence of 3-element tuples representing the robot's position, velocity, and timestamp."
              }
            ],
            "returns": {
              "type_name": "Tuple[float,float,float]",
              "description": "3 components of displacement (lateral, avance and angular) calculated based on the odometry data."
            },
            "usage": {
              "language": "python",
              "code": "specific_worker = SpecificWorker(proxy_map)\nodometry = (10, 20, 30, time.time())\ndesplzamiento_lateral, desplzamiento_avance, desplzamiento_angular = specific_worker.get_displacement(odometry)\nprint(\"Desplazamiento lateral:\", desplzamiento_lateral)\nprint(\"Desplazamiento avance:\", desplzamiento_avance)\nprint(\"Desplazamiento angular:\", desplzamiento_angular)\n",
              "description": ""
            },
            "name": "get_displacement",
            "location": {
              "start": 458,
              "insert": 459,
              "offset": " ",
              "indent": 8,
              "comment": null
            },
            "item_type": "method",
            "length": 14,
            "docLength": null
          },
          {
            "id": "70fffc25-7e1d-52b1-f24e-5a8cb6ce551c",
            "ancestors": [
              "f9d0a7c6-bb7a-81a5-5c42-4fecec81e359"
            ],
            "description": "Computes the covariance matrix of a set of vertices in a graph using the G2O optimizer and returns the result.",
            "params": [
              {
                "name": "vertex",
                "type_name": "G2O.HessianIndex",
                "description": "Used to represent a vertex in the graph."
              }
            ],
            "returns": {
              "type_name": "Tuple[bool,npndarray]",
              "description": "A result of computing marginals and a covariance matrix."
            },
            "usage": {
              "language": "python",
              "code": "import numpy as np\nfrom specific_worker import SpecificWorker\n\n# Create a new instance of SpecificWorker class.\nspecific_worker = SpecificWorker(proxy_map)\n\n# Get covariance matrix for a vertex with index 0.\ncov_vertices = [(specific_worker.vertex.hessian_index(), specific_worker.vertex.hessian_index())]\ncovariances, covariances_result = specific_worker.g2o.optimizer.compute_marginals(cov_vertices)\nif covariances_result:\n    print(\"Covariance computed\")\n    matrix = covariances.block(specific_worker.vertex.hessian_index(), specific_worker.vertex.hessian_index())\n    upper_triangle = np.triu(matrix) \n    print(\"Covariance matrix\", upper_triangle)\nelse:\n    print(\"Covariance not computed\")\n",
              "description": ""
            },
            "name": "get_covariance_matrix",
            "location": {
              "start": 477,
              "insert": 478,
              "offset": " ",
              "indent": 8,
              "comment": null
            },
            "item_type": "method",
            "length": 11,
            "docLength": null
          },
          {
            "id": "1d4a0115-e749-6b95-ef46-016f982f6e14",
            "ancestors": [
              "f9d0a7c6-bb7a-81a5-5c42-4fecec81e359"
            ],
            "description": "Loads G2O files, visualizes their positions and edges in 3D, and updates the display in real-time using matplotlib.",
            "params": [
              {
                "name": "optimizer",
                "type_name": "object",
                "description": "Used to load a G2O file for visualization."
              }
            ],
            "returns": null,
            "usage": {
              "language": "python",
              "code": "import matplotlib.pyplot as plt\nfrom matplotlib import animation\n\n# Create a new SpecificWorker instance\nspecific_worker = SpecificWorker(proxy_map, startup_check=False)\n\n# Load the G2O graph data from a file\noptimizer = specific_worker.g2o.load(\"archivo.g2o\")\n\n# Visualize the G2O graph in real-time using matplotlib\nanim = animation.FuncAnimation(plt.figure(), specific_worker.visualize_g2o_realtime, fargs=(optimizer,))\n",
              "description": "\nThe user creates a new instance of the SpecificWorker class, which is a subclass of GenericWorker. Then, they load the G2O graph data from a file using the g2o.load() method and pass it as an argument to the visualize_g2o_realtime function. The function will create a 3D scatter plot of the vertices in the graph using matplotlib's animation module."
            },
            "name": "visualize_g2o_realtime",
            "location": {
              "start": 490,
              "insert": 491,
              "offset": " ",
              "indent": 8,
              "comment": null
            },
            "item_type": "method",
            "length": 29,
            "docLength": null
          },
          {
            "id": "8e143288-7f47-9db0-dd4d-4eae4da6c637",
            "ancestors": [
              "f9d0a7c6-bb7a-81a5-5c42-4fecec81e359"
            ],
            "description": "Updates the attributes of a node in a graph, specifically the odometry node, and appends a new entry to the odometry queue based on the current robot position and speed.",
            "params": [
              {
                "name": "id",
                "type_name": "int",
                "description": "Used to identify the node for which attributes are being updated, specifically the odometry node."
              },
              {
                "name": "attribute_names",
                "type_name": "[str]",
                "description": "An array of strings that represents the names of attributes to be updated on a node in the graph."
              }
            ],
            "returns": null,
            "usage": {
              "language": "python",
              "code": "worker = SpecificWorker(proxy_map=proxy_map)\n# Update the attribute of a node in the graph.\nworker.update_node_att(id=20, attribute_names=[\"robot_current_advance_speed\", \"robot_current_side_speed\"])\n",
              "description": "\nThis code would update the attributes of the node with id 20 in the graph, which is a G2OGraph. The function updates the values of the attributes \"robot_current_advance_speed\" and \"robot_current_side_speed\"."
            },
            "name": "update_node_att",
            "location": {
              "start": 527,
              "insert": 536,
              "offset": " ",
              "indent": 8,
              "comment": null
            },
            "item_type": "method",
            "length": 7,
            "docLength": null
          },
          {
            "id": "92490404-1b41-4ab7-2044-f62b24cc8d3e",
            "ancestors": [
              "f9d0a7c6-bb7a-81a5-5c42-4fecec81e359"
            ],
            "description": "Updates an individual node's type, specifically \"corner\". If the node belongs to a room, it initializes the graph's room structure if necessary.",
            "params": [
              {
                "name": "id",
                "type_name": "int",
                "description": "Used to identify the node being updated."
              },
              {
                "name": "type",
                "type_name": "str",
                "description": "Used to identify the node's type, which can be either \"corner\" or \"room\"."
              }
            ],
            "returns": null,
            "usage": {
              "language": "python",
              "code": "specific_worker = SpecificWorker(\"proxy_map\")\nnode_id = 10 # arbitrary node ID\nnode_type = \"corner\" # arbitrary node type string\nspecific_worker.update_node(node_id, node_type)\n",
              "description": "\nThis example shows how the update_node method of the SpecificWorker class might be used to update a node in the graph with the specified node ID and node type. The function takes two arguments: the first is an integer representing the node ID, and the second is a string representing the node type. In this case, we have set the node ID to 10 and the node type to \"corner\", but these values can be any valid integers or strings that correspond to actual nodes in the graph."
            },
            "name": "update_node",
            "location": {
              "start": 543,
              "insert": 553,
              "offset": " ",
              "indent": 8,
              "comment": null
            },
            "item_type": "method",
            "length": 6,
            "docLength": null
          },
          {
            "id": "9d7aca63-132b-0493-8e40-0f29a33de3d0",
            "ancestors": [
              "f9d0a7c6-bb7a-81a5-5c42-4fecec81e359"
            ],
            "description": "Deletes a node from a graph data structure represented in the method signature, by setting the `room_initialized` attribute to `False`.",
            "params": [
              {
                "name": "id",
                "type_name": "int",
                "description": "Intended to represent the unique identifier of the node to be deleted."
              }
            ],
            "returns": null,
            "usage": {
              "language": "python",
              "code": "worker = SpecificWorker(proxy_map, startup_check=False)\n# ... (code for worker initialization)\nworker.delete_node(1234)\n",
              "description": "\nIn this example, the user creates a specific worker instance using the provided proxy map and sets `startup_check` to False. Then they call the `delete_node()` function with node ID 1234 as an argument, which deletes the specified node from the graph represented by the worker's G2OGraph object."
            },
            "name": "delete_node",
            "location": {
              "start": 555,
              "insert": 556,
              "offset": " ",
              "indent": 8,
              "comment": null
            },
            "item_type": "method",
            "length": 6,
            "docLength": null
          },
          {
            "id": "1fbca7ab-3716-df8e-d44a-d5010fbc319e",
            "ancestors": [
              "f9d0a7c6-bb7a-81a5-5c42-4fecec81e359"
            ],
            "description": "Updates the room ID and sets the current edge set based on node type and RT edge information.",
            "params": [
              {
                "name": "fr",
                "type_name": "int",
                "description": "Representing the from node ID in the graph."
              },
              {
                "name": "to",
                "type_name": "int",
                "description": "Used to represent the ID of the node that follows the edge being updated."
              },
              {
                "name": "type",
                "type_name": "str",
                "description": "Used to specify the edge's type, which can be either \"current\" or \"RT\"."
              }
            ],
            "returns": null,
            "usage": {
              "language": "python",
              "code": "from SpecificWorker import SpecificWorker\nimport time\n\n# Create a new instance of the class SpecificWorker with proxy_map as a parameter.\nworker = SpecificWorker(proxy_map)\n\n# Update the edge with from node fr and to node to.\nworker.update_edge(fr, to, \"current\")\n",
              "description": "\nIn this example, the SpecificWorker object is created using the proxy_map argument and then the update_edge method of the class is called using the nodes fr and to as parameters. The type parameter is set to \"current\" indicating that the edge represents a current edge in the graph."
            },
            "name": "update_edge",
            "location": {
              "start": 564,
              "insert": 565,
              "offset": " ",
              "indent": 8,
              "comment": null
            },
            "item_type": "method",
            "length": 22,
            "docLength": null
          },
          {
            "id": "9020eb51-763c-97aa-9b4c-b9312291e281",
            "ancestors": [
              "f9d0a7c6-bb7a-81a5-5c42-4fecec81e359"
            ],
            "description": "Deletes an edge from a graph, specified by its index (fr), type (to), and the worker instance.",
            "params": [
              {
                "name": "fr",
                "type_name": "int",
                "description": "1st in the function signature, indicating that it should be the first argument passed to the function when calling it."
              },
              {
                "name": "to",
                "type_name": "int",
                "description": "Representing the second vertex index of an edge to be deleted."
              },
              {
                "name": "type",
                "type_name": "str",
                "description": "Used to specify the edge type to be deleted, which can be either \"weighted\" or \"unweighted\"."
              }
            ],
            "returns": null,
            "usage": {
              "language": "python",
              "code": "from SpecificWorker import GenericWorker\n\n# Create a new instance of the SpecificWorker class\nworker = SpecificWorker(proxy_map)\n\n# Add an edge to the graph\nworker.add_edge(0, 1, \"type\")\n\n# Delete an edge from the graph\nworker.delete_edge(0, 1, \"type\")\n",
              "description": "\nThis example demonstrates how the delete_edge function is used to remove a previously created edge between nodes with IDs 0 and 1 of type \"type\" from the graph."
            },
            "name": "delete_edge",
            "location": {
              "start": 592,
              "insert": 593,
              "offset": " ",
              "indent": 8,
              "comment": null
            },
            "item_type": "method",
            "length": 3,
            "docLength": null
          }
        ]
      }
    }
  },
  {
    "name": "long_term_graph.py",
    "path": "agents/long_term_spatial_memory_agent/scripts/long_term_graph.py",
    "content": {
      "structured": {
        "description": "a function called draw_metric_map that takes in a metric map object and plots the map using Matplotlib. It first loads the graph from a text file and defines various functions to work with the graph, such as get_room_corners, get_room_objects, and get_room_objects_coordinates. These functions recursively traverse the graph to find the corners or objects in a room, respectively. The draw_metric_map function then uses these functions to plot the rooms and objects in the map. Specifically, it plots each room as a rectangle and adds names to each room, and it plots each object as a point and adds a text label with its name.",
        "items": [
          {
            "id": "5176435a-f92b-e4bd-1b4e-e1e310ab5ae8",
            "ancestors": [],
            "description": "Draws a graph of long-term spatial mobility data using PyQt and Matplotlib. It provides methods to visualize rooms, doors, walls, and edges in the graph.",
            "attributes": [
              {
                "name": "g",
                "type_name": "Graph",
                "description": "Used to represent the graph object that contains the rooms, doors, and walls to be visualized."
              },
              {
                "name": "read_graph",
                "type_name": "instance",
                "description": "Used to read a graph from a file specified by the user. It takes a string path as input and reads the graph data from it."
              },
              {
                "name": "fig",
                "type_name": "instance",
                "description": "A reference to the figure object that will be used to draw the graph."
              },
              {
                "name": "ax",
                "type_name": "MatplotlibFigure",
                "description": "Used to represent the axis object for the graph. It provides methods for adding patches, lines, and other visual elements to the graph."
              }
            ],
            "name": "LongTermGraph",
            "location": {
              "start": 15,
              "insert": 16,
              "offset": " ",
              "indent": 4,
              "comment": null
            },
            "item_type": "class",
            "length": 198,
            "docLength": null
          },
          {
            "id": "411ae665-2c3f-efb9-7546-d76e93280634",
            "ancestors": [
              "5176435a-f92b-e4bd-1b4e-e1e310ab5ae8"
            ],
            "description": "Initializes an object of `LongTermGraph` class, loading a graph from a file using the `read_graph` method and displaying its summary.",
            "params": [
              {
                "name": "file_name",
                "type_name": "str",
                "description": "Used to specify the name of a file containing a graph represented as an adjacency matrix."
              }
            ],
            "returns": null,
            "name": "__init__",
            "location": {
              "start": 16,
              "insert": 17,
              "offset": " ",
              "indent": 8,
              "comment": null
            },
            "item_type": "method",
            "length": 8,
            "docLength": null
          },
          {
            "id": "fbfe681a-6ac8-9cb2-ad48-9c2d64fec643",
            "ancestors": [
              "5176435a-f92b-e4bd-1b4e-e1e310ab5ae8"
            ],
            "description": "Generates a graphical representation of a subgraph within a larger graph, based on node and edge properties. It creates a figure and axis object, sets the title, and draws the nodes and edges using different colors for each type of node or edge.",
            "params": [
              {
                "name": "only_rooms",
                "type_name": "bool",
                "description": "Used to filter the nodes in the graph based on their types, only showing rooms and doors."
              }
            ],
            "returns": null,
            "name": "draw_graph",
            "location": {
              "start": 191,
              "insert": 192,
              "offset": " ",
              "indent": 8,
              "comment": null
            },
            "item_type": "method",
            "length": 34,
            "docLength": null
          }
        ]
      }
    }
  },
  {
    "name": "main.py",
    "path": "agents/long_term_spatial_memory_agent/scripts/main.py",
    "content": {
      "structured": {
        "description": "Three functions: draw_graph, find_edge_with_attribute, and get_connected_door_nodes. The draw_graph function takes a graph object as input and uses PySide2's QtCore module to create a subplot and plot points on the graph. The find_edge_with_attribute function searches for an edge in a given graph based on a specific attribute, and the get_connected_door_nodes function recursively traverses a graph to find all connected door nodes in a given room. The code also loads a graph from a pickled file using the LongTermGraph class, and uses the compute_metric_map and draw_metric_map functions to display the graph's metric map and point locations.",
        "items": [
          {
            "id": "d3824e62-3401-2c9e-394e-2ee9ee755e69",
            "ancestors": [],
            "description": "Generates a graph based on a provided adjacency matrix using Kamada-Kawai layout algorithm, and adds node names and edges with arrowheads.",
            "params": [
              {
                "name": "graph",
                "type_name": "AbstractGraph",
                "description": "Used to represent a graph object that contains vertices and edges."
              }
            ],
            "returns": null,
            "name": "draw_graph",
            "location": {
              "start": 6,
              "insert": 7,
              "offset": " ",
              "indent": 4,
              "comment": null
            },
            "item_type": "function",
            "length": 24,
            "docLength": null
          },
          {
            "id": "d7906eb3-709a-3c95-7c40-18ce0ab8dcfd",
            "ancestors": [],
            "description": "Searches through a graph's edges for an edge with a specific attribute equal to a given value. If such an edge is found, it returns it; otherwise, it returns `None`.",
            "params": [
              {
                "name": "graph",
                "type_name": "Graph",
                "description": "Represented as an object that contains a collection of edges, where each edge represents a connection between two nodes in the graph."
              },
              {
                "name": "attribute",
                "type_name": "attribute",
                "description": "Used to specify the attribute of interest for finding an edge in a graph."
              },
              {
                "name": "value",
                "type_name": "object",
                "description": "Used to search for an edge in a graph based on a specific attribute."
              }
            ],
            "returns": {
              "type_name": "edge",
              "description": "An untyped reference to a graph edge that has the specified attribute equal to the provided value."
            },
            "name": "find_edge_with_attribute",
            "location": {
              "start": 41,
              "insert": 42,
              "offset": " ",
              "indent": 4,
              "comment": null
            },
            "item_type": "function",
            "length": 5,
            "docLength": null
          },
          {
            "id": "fe2cae8a-54a8-32a7-014a-24ebf3a8e0f2",
            "ancestors": [],
            "description": "Iterates over the edges in a graph and adds to an output list any edge connecting nodes with \"door\" in their names.",
            "params": [
              {
                "name": "graph",
                "type_name": "Graph",
                "description": "Represented as g, which contains a collection of nodes and edges that define a graph structure."
              }
            ],
            "returns": {
              "type_name": "list",
              "description": "A collection of edges from the given graph."
            },
            "name": "get_room_edges",
            "location": {
              "start": 47,
              "insert": 48,
              "offset": " ",
              "indent": 4,
              "comment": null
            },
            "item_type": "function",
            "length": 10,
            "docLength": null
          },
          {
            "id": "e9acd19c-513f-f78e-4949-cd353d1b9b16",
            "ancestors": [],
            "description": "In Java code recursively queries the graph for all nodes connected to a given node via doors, returning a list of such nodes.",
            "params": [
              {
                "name": "graph",
                "type_name": "Graph",
                "description": "Used to represent a graph structure."
              },
              {
                "name": "node",
                "type_name": "GraphNode",
                "description": "Referred to as a node in the graph."
              }
            ],
            "returns": {
              "type_name": "list",
              "description": "A collection of nodes that are connected to a specific node through doors."
            },
            "name": "get_connected_door_nodes",
            "location": {
              "start": 58,
              "insert": 60,
              "offset": " ",
              "indent": 4,
              "comment": null
            },
            "item_type": "function",
            "length": 10,
            "docLength": null
          },
          {
            "id": "9a2a2e72-8415-229d-6c4a-657476ccda61",
            "ancestors": [],
            "description": "Navigates through a graph by starting from a given room and visiting all other rooms reachable through doors. It keeps track of visited rooms using a list and prints information about each room it visits.",
            "params": [
              {
                "name": "graph",
                "type_name": "Graph",
                "description": "Used to represent a graph with nodes and edges."
              },
              {
                "name": "current_room",
                "type_name": "dict",
                "description": "Represents the current room to be traversed in the graph."
              },
              {
                "name": "visited",
                "type_name": "list",
                "description": "Used to keep track of the rooms that have been visited during the traversal process, initialized to an empty list if None."
              }
            ],
            "returns": {
              "type_name": "list",
              "description": "A collection of strings representing the rooms that have been visited."
            },
            "name": "traverse_graph",
            "location": {
              "start": 74,
              "insert": 75,
              "offset": " ",
              "indent": 4,
              "comment": null
            },
            "item_type": "function",
            "length": 17,
            "docLength": null
          }
        ]
      }
    }
  },
  {
    "name": "genericworker.py",
    "path": "agents/long_term_spatial_memory_agent/src/genericworker.py",
    "content": {
      "structured": {
        "description": "A worker class that inherits from QtWidgets.QWidget and implements a timer-based mechanism for killing itself after a specified period. It also provides a signal kill to allow for handling of the termination from outside the worker. The code uses PySide2, Ice, and the RoboCompCommonBehavior module.",
        "items": [
          {
            "id": "8a50128c-009f-a1ac-2c45-674f0e62438e",
            "ancestors": [],
            "description": "Manages a timer and a signal to stop its own execution. It has methods to change the timer period and to emit the signal to stop itself.",
            "attributes": [
              {
                "name": "kill",
                "type_name": "QtCoreQObjectSlot",
                "description": "Used to emit a signal that can be caught by any connected slots to stop the worker's execution."
              },
              {
                "name": "ui",
                "type_name": "Ui_guiDlg",
                "description": "Used to setup the user interface of the class."
              },
              {
                "name": "mutex",
                "type_name": "QMutex",
                "description": "Used to protect the worker's state from concurrent access."
              },
              {
                "name": "Period",
                "type_name": "int",
                "description": "Used to set the time interval for the timer signal emitted by the `setPeriod()` method, which changes its value on each call."
              },
              {
                "name": "timer",
                "type_name": "QtCoreQTimer",
                "description": "Used to start a timer that emits the `kill` signal after a specified period."
              }
            ],
            "name": "GenericWorker",
            "location": {
              "start": 43,
              "insert": 45,
              "offset": " ",
              "indent": 4,
              "comment": null
            },
            "item_type": "class",
            "length": 26,
            "docLength": null
          },
          {
            "id": "dc756aa5-ebc6-5490-d649-854bb2ac26a4",
            "ancestors": [
              "8a50128c-009f-a1ac-2c45-674f0e62438e"
            ],
            "description": "Initializes an object of the `GenericWorker` class, setting up a UI widget, creating a mutex for synchronization, and defining a timer with a period of 500 milliseconds.",
            "params": [
              {
                "name": "mprx",
                "type_name": "Ui_guiDlg",
                "description": "Used as the parent widget for the GenericWorker object's UI."
              }
            ],
            "returns": null,
            "name": "__init__",
            "location": {
              "start": 47,
              "insert": 48,
              "offset": " ",
              "indent": 8,
              "comment": null
            },
            "item_type": "method",
            "length": 9,
            "docLength": null
          },
          {
            "id": "17fccd3d-bcc7-a9a3-5f45-73125f7d1f78",
            "ancestors": [
              "8a50128c-009f-a1ac-2c45-674f0e62438e"
            ],
            "description": "Emits the `kill` signal, indicating that the object should be terminated.",
            "params": [],
            "returns": null,
            "name": "killYourSelf",
            "location": {
              "start": 60,
              "insert": 62,
              "offset": " ",
              "indent": 8,
              "comment": null
            },
            "item_type": "method",
            "length": 4,
            "docLength": null
          },
          {
            "id": "a2ebb705-7932-fb9b-3e45-f965c61ebf4d",
            "ancestors": [
              "8a50128c-009f-a1ac-2c45-674f0e62438e"
            ],
            "description": "Sets the period of a timer and updates the internal variable `Period`.",
            "params": [
              {
                "name": "p",
                "type_name": "int",
                "description": "Used to set the new period for the timer."
              }
            ],
            "returns": null,
            "name": "setPeriod",
            "location": {
              "start": 67,
              "insert": 69,
              "offset": " ",
              "indent": 8,
              "comment": null
            },
            "item_type": "method",
            "length": 5,
            "docLength": null
          }
        ]
      }
    }
  },
  {
    "name": "specificworker.py",
    "path": "agents/long_term_spatial_memory_agent/src/specificworker.py",
    "content": {
      "structured": {
        "description": "An igraph wrapper around a graph and provides several methods for working with it, including inserting new nodes and edges, updating edge attributes, and deleting nodes and edges. The code uses the `igraph` package to interface with the graph. Specifically, it creates a long-term graph (LTG) and a short-term graph (STG), allowing for efficient insertion, deletion, and manipulation of nodes and edges in the LTG while maintaining the integrity of the STG. The code also provides functions to update edge attributes and delete nodes or edges from the graph.",
        "items": [
          {
            "id": "68a48220-ebf4-7cb1-6d46-ec8ae0b47c1b",
            "ancestors": [],
            "description": "Manages a specific node and edge attributes and performs various operations on them, such as updating, inserting, deleting, and attributing. It also keeps track of the current state of the robot and updates the graph accordingly.",
            "attributes": [
              {
                "name": "Period",
                "type_name": "Union[int,str]",
                "description": "Used to store the period of time during which the worker can perform its task, such as a day or a week."
              },
              {
                "name": "agent_id",
                "type_name": "int|str",
                "description": "Used to identify the specific worker instance, allowing the agent to perform tasks and maintain a unique identity during its lifetime."
              },
              {
                "name": "g",
                "type_name": "igraphGraph",
                "description": "Used to represent the long-term graph of the environment, which is updated periodically by the worker."
              },
              {
                "name": "startup_check",
                "type_name": "bool|str",
                "description": "Used to check if the worker has been started or not, with possible values \"yes\", \"no\", or False."
              },
              {
                "name": "rt_api",
                "type_name": "str|int",
                "description": "Used for storing the RT (Real-Time) API ID which represents the current task being executed by the worker."
              },
              {
                "name": "inner_api",
                "type_name": "Dict[str,Any]",
                "description": "Used to store the inner API of the worker, which is a Python function that performs actions related to the worker's task."
              },
              {
                "name": "robot_name",
                "type_name": "str|int",
                "description": "Used to store the name of the robot that will perform a specific task."
              },
              {
                "name": "robot_id",
                "type_name": "int",
                "description": "Used to identify the robot node in the graph, which is the starting point for the worker's movement."
              },
              {
                "name": "last_robot_pose",
                "type_name": "Tuple[float,float,float]",
                "description": "Stored as the last known pose (position, orientation, and scale) of the robot before any actions were taken in the environment."
              },
              {
                "name": "robot_exit_pose",
                "type_name": "str|int",
                "description": "A reference to the pose of the robot when it exits a room. It is used to determine when the robot has reached its goal in a task."
              },
              {
                "name": "state",
                "type_name": "str|int",
                "description": "Used to keep track of the current state of the worker, which can be either \"idle\", \"crossed\", or \"completed\"."
              },
              {
                "name": "affordance_node_active_id",
                "type_name": "int|bool",
                "description": "Used to keep track of the active affordance node ID, which is used to determine when the robot has reached its goal."
              },
              {
                "name": "exit_door_id",
                "type_name": "int|str",
                "description": "Used to store the ID of the door node that leads from a room to the outside world."
              },
              {
                "name": "room_exit_door_id",
                "type_name": "int|str",
                "description": "Used to represent the ID of the door node that leads from a room to the outside world."
              },
              {
                "name": "enter_room_node_id",
                "type_name": "int",
                "description": "Used to store the ID of the room node that the worker is currently entering."
              },
              {
                "name": "vertex_size",
                "type_name": "int|str",
                "description": "Used to keep track of the number of vertices in the graph, which can be useful for various operations such as insertion, deletion, and querying the graph."
              },
              {
                "name": "not_required_attrs",
                "type_name": "List[str]",
                "description": "Used to store a list of attributes that are not required for the worker's functionality, but can be useful for debugging or other purposes."
              },
              {
                "name": "last_save_time",
                "type_name": "datetime|str",
                "description": "Used to store the time when the worker's long-term graph was last saved. It helps track when the graph was last updated for subsequent actions."
              },
              {
                "name": "long_term_graph",
                "type_name": "igraphGraph",
                "description": "Used to store the long-term graph representation of the environment, which is updated over time as new data becomes available."
              },
              {
                "name": "initialize_room_from_igraph",
                "type_name": "Dict[str,Any]",
                "description": "Used to initialize the room graph from an igraph graph. It takes the igraph graph as input and creates a new room graph with the same node IDs and edges as the input igraph."
              },
              {
                "name": "update_robot_pose_in_igraph",
                "type_name": "void",
                "description": "Used to update the pose of a robot node in the graph by inserting a new edge with the correct \"RT\" translation and rotation."
              },
              {
                "name": "insert_current_edge",
                "type_name": "List[Edge]",
                "description": "Used to insert a new edge into the graph with the specified source and target nodes and edge type, effectively setting it as the current edge in the graph."
              },
              {
                "name": "timer",
                "type_name": "int|float",
                "description": "Used to track the time taken by the worker to perform its tasks."
              },
              {
                "name": "compute",
                "type_name": "Callable[[int],str|int]",
                "description": "Defined as a method that takes an integer argument and returns a string or integer value representing the result \nof some computation. It is used in various methods of the worker to perform computations on the graph."
              },
              {
                "name": "update_node",
                "type_name": "Dict[str,Any]",
                "description": "Responsible for updating a node in the graph when the worker's id matches the node's id. It takes three parameters: `id`, `type`, and `door_node`. The method updates the node's attributes based on its type and inserts an RT edge between the node and its parent if necessary."
              },
              {
                "name": "update_edge",
                "type_name": "Union[int,str]",
                "description": "Used to update an edge's type or remove it altogether based on certain conditions."
              }
            ],
            "name": "SpecificWorker",
            "location": {
              "start": 49,
              "insert": 50,
              "offset": " ",
              "indent": 4,
              "comment": null
            },
            "item_type": "class",
            "length": 628,
            "docLength": null
          },
          {
            "id": "ad42c39d-e8e5-3180-aa4c-67d2bbbe477e",
            "ancestors": [
              "68a48220-ebf4-7cb1-6d46-ec8ae0b47c1b"
            ],
            "description": "Initializes the worker's internal state, including its graph, node and edge variables, and timers for computing and updating the graph.",
            "params": [
              {
                "name": "proxy_map",
                "type_name": "dict",
                "description": "Used to pass a mapping of proxy nodes to their corresponding real nodes in the graph."
              },
              {
                "name": "startup_check",
                "type_name": "bool",
                "description": "Set to False by default. It performs a check on the graph upon initialization if it's set to True, otherwise, it does not."
              }
            ],
            "returns": null,
            "usage": {
              "language": "python",
              "code": "from SpecificWorker import SpecificWorker\nimport time\n\n# Initialize the worker with a proxy map and a startup check\nworker = SpecificWorker(proxy_map, True)\n\n# Set up the timer for the compute method\ntimer = time.time()\nworker.setPeriod(100)\nworker.startTimer()\n\nwhile True:\n    # Perform the computation\n    worker.compute()\n    \n    # Check if it's time to save the graph\n    if time.time() - last_save_time > 3600:\n        worker.saveGraph(\"graph.pkl\")\n",
              "description": ""
            },
            "name": "__init__",
            "location": {
              "start": 50,
              "insert": 51,
              "offset": " ",
              "indent": 8,
              "comment": null
            },
            "item_type": "constructor",
            "length": 54,
            "docLength": null
          },
          {
            "id": "61093faf-d7f7-cebb-4d49-712ed045066d",
            "ancestors": [
              "68a48220-ebf4-7cb1-6d46-ec8ae0b47c1b"
            ],
            "description": "Sets parameters and modifies the state of the room by removing a self-edge, storing an exit door ID, and adding attributes to doors.",
            "params": [
              {
                "name": "params",
                "type_name": "bool",
                "description": "Passed to set the parameters of the room."
              }
            ],
            "returns": {
              "type_name": "bool",
              "description": "True."
            },
            "usage": {
              "language": "python",
              "code": "worker = SpecificWorker(proxy_map)\n# setParams takes in a dictionary of parameters as input\nparams = {\"Period\": 10, \"agent_id\": 12}\nworker.setParams(params)\n",
              "description": "\nIn this example, the user creates an instance of the SpecificWorker class and passes a dictionary of parameters to the setParams method. The function then updates the worker's internal state based on the input parameters."
            },
            "name": "setParams",
            "location": {
              "start": 127,
              "insert": 128,
              "offset": " ",
              "indent": 8,
              "comment": null
            },
            "item_type": "method",
            "length": 7,
            "docLength": null
          },
          {
            "id": "cfc1e69d-8797-9087-e844-76a8a7e76242",
            "ancestors": [
              "68a48220-ebf4-7cb1-6d46-ec8ae0b47c1b"
            ],
            "description": "Updates the robot's pose in the graph and performs various actions based on the current state of the robot.",
            "params": [],
            "returns": null,
            "usage": {
              "language": "python",
              "code": "specific_worker = SpecificWorker()\nspecific_worker.compute()\n",
              "description": ""
            },
            "name": "compute",
            "location": {
              "start": 141,
              "insert": 144,
              "offset": " ",
              "indent": 8,
              "comment": null
            },
            "item_type": "method",
            "length": 22,
            "docLength": null
          },
          {
            "id": "8b3d3eed-7010-bd8a-8045-f75833aa77e7",
            "ancestors": [
              "68a48220-ebf4-7cb1-6d46-ec8ae0b47c1b"
            ],
            "description": "Initializes a room in a graph by deleting an edge, finding the robot node and its neighbors, creating a new vertex for the root of the igraph, inserting edges to connect the robot to the room and the room to itself, and updating the robot's parent node attribute.",
            "params": [],
            "returns": null,
            "usage": {
              "language": "python",
              "code": "worker = SpecificWorker(proxy_map, startup_check=False)\nworker.initialize_room_from_igraph()\n",
              "description": "\nThis code uses the Python function \"initialize_room_from_igraph\" to initialize the room from an igraph graph structure. The function is called on a worker object created from the SpecificWorker class, which subclasses GenericWorker."
            },
            "name": "initialize_room_from_igraph",
            "location": {
              "start": 165,
              "insert": 167,
              "offset": " ",
              "indent": 8,
              "comment": null
            },
            "item_type": "method",
            "length": 22,
            "docLength": null
          },
          {
            "id": "aab2b882-aaae-999f-b248-533b7089da3f",
            "ancestors": [
              "68a48220-ebf4-7cb1-6d46-ec8ae0b47c1b"
            ],
            "description": "Updates the robot's pose in an igraph graph based on a RT translation and rotation, taking into account the robot's current location and the surrounding rooms.",
            "params": [],
            "returns": null,
            "usage": {
              "language": "python",
              "code": "# create an instance of SpecificWorker class\nspecific_worker = SpecificWorker(proxy_map)\n\n# call the update_robot_pose_in_igraph method to update robot pose in igraph\nspecific_worker.update_robot_pose_in_igraph()\n",
              "description": ""
            },
            "name": "update_robot_pose_in_igraph",
            "location": {
              "start": 198,
              "insert": 200,
              "offset": " ",
              "indent": 8,
              "comment": null
            },
            "item_type": "method",
            "length": 41,
            "docLength": null
          },
          {
            "id": "67757034-6f36-3890-0942-bd47b1455c70",
            "ancestors": [
              "68a48220-ebf4-7cb1-6d46-ec8ae0b47c1b"
            ],
            "description": "Detects when the robot enters a new room and associates doors based on their proximity to the robot's current position, updating the graph and door attributes accordingly.",
            "params": [],
            "returns": null,
            "usage": {
              "language": "python",
              "code": "# Initialize the worker and specify the startup check parameter as True\nworker = SpecificWorker(proxy_map, startup_check=True)\n\n# Perform an initialization check for the worker\nworker.startup_check()\n\n# Set the agent ID to 13\nworker.agent_id = 13\n\n# Update the robot name to \"Shadow\"\nworker.robot_name = \"Shadow\"\n\n# Update the vertex size to 0\nworker.vertex_size = 0\n\n# Set the state of the worker to idle\nworker.state = \"idle\"\n",
              "description": ""
            },
            "name": "idle",
            "location": {
              "start": 251,
              "insert": 253,
              "offset": " ",
              "indent": 8,
              "comment": null
            },
            "item_type": "method",
            "length": 75,
            "docLength": null
          },
          {
            "id": "51b1dbb4-c5a5-63b2-4b43-06106aa87d12",
            "ancestors": [
              "68a48220-ebf4-7cb1-6d46-ec8ae0b47c1b"
            ],
            "description": "1) retrieves the active affordance node and its parent, 2) sets the exit door ID to the value of the parent attribute, and 3) deletes the edge connecting the current room to itself.",
            "params": [],
            "returns": null,
            "usage": {
              "language": "python",
              "code": "import SpecificWorker\n\n# Create an instance of the SpecificWorker class\nworker = SpecificWorker(proxy_map=your_proxy_map)\n\n# Call the crossed method with no arguments and store the return value in a variable\nroom_state = worker.crossed()\n\n# Print the returned value to see if the function executed successfully\nprint(\"Room state:\", room_state)\n",
              "description": ""
            },
            "name": "crossed",
            "location": {
              "start": 350,
              "insert": 352,
              "offset": " ",
              "indent": 8,
              "comment": null
            },
            "item_type": "method",
            "length": 16,
            "docLength": null
          },
          {
            "id": "d55c53ae-f2c0-628c-ca4e-0ad084fa17b1",
            "ancestors": [
              "68a48220-ebf4-7cb1-6d46-ec8ae0b47c1b"
            ],
            "description": "Determines and sets the ID of the room node to enter upon construction, based on conditions involving the existence of nodes labeled \"room\" and the absence of certain attributes.",
            "params": [],
            "returns": null,
            "usage": {
              "language": "python",
              "code": "from mymodule import SpecificWorker\n\n# Creating an instance of the class and using its method initializing_room\nmyworker = SpecificWorker(proxy_map)\nmyworker.initializing_room()\n\n# The function will be executed within the context of the object,\n# allowing it to modify any attributes or methods associated with it.\n",
              "description": ""
            },
            "name": "initializing_room",
            "location": {
              "start": 370,
              "insert": 373,
              "offset": " ",
              "indent": 8,
              "comment": null
            },
            "item_type": "method",
            "length": 10,
            "docLength": null
          },
          {
            "id": "bdadfa6f-3602-06ad-9c4d-0b5443a38eed",
            "ancestors": [
              "68a48220-ebf4-7cb1-6d46-ec8ae0b47c1b"
            ],
            "description": "Detects the room the robot is currently in and finds the door node leading to the next room. It then creates a new edge in the graph representing the RT pose of the robot and updates the graph with the new edge.",
            "params": [],
            "returns": null,
            "usage": {
              "language": "python",
              "code": "# Initialize a SpecificWorker object named \"worker\"\nworker = SpecificWorker(proxy_map)\n\n# Call the known_room method with a given room name and node ID\nworker.known_room(\"room1\", 234)\n",
              "description": ""
            },
            "name": "known_room",
            "location": {
              "start": 384,
              "insert": 386,
              "offset": " ",
              "indent": 8,
              "comment": null
            },
            "item_type": "method",
            "length": 73,
            "docLength": null
          },
          {
            "id": "911fde00-668a-68ae-d446-d45ece69baae",
            "ancestors": [
              "68a48220-ebf4-7cb1-6d46-ec8ae0b47c1b"
            ],
            "description": "1) retrieves edges leading to the exit door, 2) checks if any matching edges exist, and 3) updates node attributes and associates doors based on the matched edges.",
            "params": [],
            "returns": null,
            "usage": {
              "language": "python",
              "code": "# create a SpecificWorker object\nworker = SpecificWorker(proxy_map)\n\n# initialize the doors in the graph\nworker.initializing_doors()\n",
              "description": ""
            },
            "name": "initializing_doors",
            "location": {
              "start": 478,
              "insert": 480,
              "offset": " ",
              "indent": 8,
              "comment": null
            },
            "item_type": "method",
            "length": 28,
            "docLength": null
          },
          {
            "id": "17a38090-fb25-fbbd-6242-3b9b704aaad8",
            "ancestors": [
              "68a48220-ebf4-7cb1-6d46-ec8ae0b47c1b"
            ],
            "description": "Connects two nodes representing doors in the long-term graph, adding an edge between them and updating their attributes to reflect the connection.",
            "params": [
              {
                "name": "door_1",
                "type_name": "str",
                "description": "A list containing the name of the first door to be associated with another door."
              },
              {
                "name": "door_2",
                "type_name": "str",
                "description": "A string representation of the second door to be associated with the long-term graph."
              }
            ],
            "returns": null,
            "usage": {
              "language": "python",
              "code": "# Initialize the SpecificWorker class object\nworker = SpecificWorker(proxy_map)\n\n# Define two door objects with names and room identifiers\ndoor1 = {\"name\": \"Front Door\", \"room_id\": 2}\ndoor2 = {\"name\": \"Back Door\", \"room_id\": 4}\n\n# Call the associate_doors method on the worker object\nworker.associate_doors(door1, door2)\n",
              "description": ""
            },
            "name": "associate_doors",
            "location": {
              "start": 517,
              "insert": 519,
              "offset": " ",
              "indent": 8,
              "comment": null
            },
            "item_type": "method",
            "length": 16,
            "docLength": null
          },
          {
            "id": "cc21732a-a5cc-7d90-2b4b-65d37df3c117",
            "ancestors": [
              "68a48220-ebf4-7cb1-6d46-ec8ae0b47c1b"
            ],
            "description": "Saves the graph representation of a room node and its exit door id to a file.",
            "params": [],
            "returns": null,
            "usage": {
              "language": "python",
              "code": "from worker import SpecificWorker\n\n# Initialize the worker\nworker = SpecificWorker(proxy_map, startup_check=False)\n\n# Create a new room node\nroom_node = worker.g.vs.find(name=\"New Room\")\nif not room_node:\n    room_node = worker.g.add_vertex(name=\"New Room\")\n\n# Store the graph in pickle format\nwith open(\"graph.pkl\", \"wb\") as f:\n    pickle.dump(worker.long_term_graph.g, f)\n",
              "description": ""
            },
            "name": "store_graph",
            "location": {
              "start": 536,
              "insert": 537,
              "offset": " ",
              "indent": 8,
              "comment": null
            },
            "item_type": "method",
            "length": 11,
            "docLength": null
          },
          {
            "id": "f099c4de-b784-939e-6846-a148b2aeec31",
            "ancestors": [
              "68a48220-ebf4-7cb1-6d46-ec8ae0b47c1b"
            ],
            "description": "Removes edges from the long-term graph based on certain conditions, including room numbers and types of edges.",
            "params": [],
            "returns": null,
            "usage": {
              "language": "python",
              "code": "specific_worker = SpecificWorker(proxy_map, startup_check=True)\nspecific_worker.removing()\n",
              "description": "\nThis code creates a new instance of the `SpecificWorker` class and then calls the `removing` method on it. The `removing` function is defined in the `SpecificWorker` class, and it removes certain elements from the graph using the `delete_node` method. The graph is an attribute of the `SpecificWorker` class, and it represents a long-term spatial memory for a robot named Shadow. The `startup_check` argument passed to the `SpecificWorker` constructor is set to `True`, indicating that the startup check should be performed before the removal process can begin."
            },
            "name": "removing",
            "location": {
              "start": 550,
              "insert": 552,
              "offset": " ",
              "indent": 8,
              "comment": null
            },
            "item_type": "method",
            "length": 19,
            "docLength": null
          },
          {
            "id": "18553e7e-c150-41ac-6742-b52ca312d465",
            "ancestors": [
              "68a48220-ebf4-7cb1-6d46-ec8ae0b47c1b"
            ],
            "description": "Traverses a graph and performs actions based on the type of edges it encounters. It starts at a designated node, then visits the children nodes of that node according to the RT edge type, and repeats this process for each child node until no more actions are left to perform.",
            "params": [
              {
                "name": "node_id",
                "type_name": "int",
                "description": "Represented by the igraph vertex ID of the current node being traversed."
              }
            ],
            "returns": null,
            "usage": {
              "language": "python",
              "code": "specific_worker = SpecificWorker(proxy_map, startup_check=False)\nnode_id = \"a_node_id\"\nspecific_worker.traverse_graph(node_id)\n",
              "description": "\nThis example shows how the traverse_graph method of the SpecificWorker class can be used to start traversing a graph from a specific node. The node ID is passed as an argument to the function, and the function then performs the necessary steps to traverse the graph starting at that node."
            },
            "name": "traverse_graph",
            "location": {
              "start": 576,
              "insert": 578,
              "offset": " ",
              "indent": 8,
              "comment": null
            },
            "item_type": "method",
            "length": 7,
            "docLength": null
          },
          {
            "id": "8ac6a6a7-f160-089e-bb4c-9b09f663081c",
            "ancestors": [
              "68a48220-ebf4-7cb1-6d46-ec8ae0b47c1b"
            ],
            "description": "Traverses the graph, identifying vertices with higher level than the current vertex and adding them to the DSR graph along with their connections.",
            "params": [
              {
                "name": "node",
                "type_name": "igraph.Vertex",
                "description": "Representing a vertex in the graph."
              }
            ],
            "returns": null,
            "usage": {
              "language": "python",
              "code": "specific_worker = SpecificWorker(proxy_map)\nspecific_worker.traverse_igraph(specific_worker.g.vs[0])\n",
              "description": "\nThis code creates a new object of type SpecificWorker and then calls the traverse_igraph method, passing in the first vertex of the graph as an argument. This vertex is used to start the traversal of the graph."
            },
            "name": "traverse_igraph",
            "location": {
              "start": 586,
              "insert": 587,
              "offset": " ",
              "indent": 8,
              "comment": null
            },
            "item_type": "method",
            "length": 10,
            "docLength": null
          },
          {
            "id": "8d4576e6-5bd3-6d9d-6548-08acb2abc696",
            "ancestors": [
              "68a48220-ebf4-7cb1-6d46-ec8ae0b47c1b"
            ],
            "description": "Adds a new vertex to an existing graph, updating the graph's vertices with provided attributes and matching other vertices based on specified conditions.",
            "params": [
              {
                "name": "node",
                "type_name": "igraph.Vertex",
                "description": "Used to represent a single vertex in the graph, including its name, ID, and attributes."
              }
            ],
            "returns": null,
            "usage": {
              "language": "python",
              "code": "worker = SpecificWorker()  # Initiate the class\nnode = Node(name=\"Door\", id=1, type=\"door\")  # Create a node with name and ID\nworker.insert_igraph_vertex(node)  # Pass the node to the function\n",
              "description": "\nThe example shows how a node with name \"Door\" and ID \"1\" is created and then passed to the insert_igraph_vertex() function, which will add it as a vertex in the graph. The function also takes care of any other attributes that may be present in the node object, such as parent or timestamp creation."
            },
            "name": "insert_igraph_vertex",
            "location": {
              "start": 599,
              "insert": 600,
              "offset": " ",
              "indent": 8,
              "comment": null
            },
            "item_type": "method",
            "length": 29,
            "docLength": null
          },
          {
            "id": "705003db-9448-d6bc-2145-c9b70fa2a402",
            "ancestors": [
              "68a48220-ebf4-7cb1-6d46-ec8ae0b47c1b"
            ],
            "description": "Modifies an existing node within a graph, adding new attributes and linking it to its parent node through an attribute.",
            "params": [
              {
                "name": "parent_name",
                "type_name": "str",
                "description": "Used to specify the name of the parent node to insert the new vertex into."
              },
              {
                "name": "node",
                "type_name": "Node | dict",
                "description": "Passed in from caller, it contains attributes that define the vertex to be inserted into graph."
              }
            ],
            "returns": null,
            "usage": {
              "language": "python",
              "code": "specific_worker = SpecificWorker(proxy_map)\nspecific_worker.insert_dsr_vertex(\"parent_name\", {\"type\": \"node_type\", \"name\": \"node_name\"})\n",
              "description": "\nThis example inserts a node with the name \"node_name\" into the graph with the type \"node_type\" and links it to the parent node named \"parent_name\"."
            },
            "name": "insert_dsr_vertex",
            "location": {
              "start": 634,
              "insert": 636,
              "offset": " ",
              "indent": 8,
              "comment": null
            },
            "item_type": "method",
            "length": 9,
            "docLength": null
          },
          {
            "id": "57a732e1-901a-ef80-944c-23f4f0907fda",
            "ancestors": [
              "68a48220-ebf4-7cb1-6d46-ec8ae0b47c1b"
            ],
            "description": "Adds an edge to a long-term graph based on a received edge attribute. It checks if the destination node is the robot, and if so, uses the correct translation and rotation attributes. Otherwise, it uses the provided translation and rotation attributes.",
            "params": [
              {
                "name": "edge",
                "type_name": "GraphEdge",
                "description": "Passed as a whole object containing information about an edge in the graph, including its origin and destination nodes, as well as attribute values such as translation and rotation."
              }
            ],
            "returns": null,
            "usage": {
              "language": "python",
              "code": "worker = SpecificWorker(proxy_map, startup_check=False)\nedge = Edge(\"Origin\", \"Destination\")\nedge.attrs[\"rt_translation\"] = [10, 20, 30]\nedge.attrs[\"rt_rotation_euler_xyz\"] = [45, 90, 180]\nworker.insert_igraph_edge(edge)\n",
              "description": "\nIn this example, a user creates an instance of the SpecificWorker class and then adds an edge to the graph by calling the insert_igraph_edge method with the edge object as an argument. The edge object contains information about the origin and destination nodes of the edge, such as their names or IDs. The method then uses this information to add a new edge to the long-term spatial memory graph with the given translation and rotation attributes."
            },
            "name": "insert_igraph_edge",
            "location": {
              "start": 648,
              "insert": 649,
              "offset": " ",
              "indent": 8,
              "comment": null
            },
            "item_type": "method",
            "length": 12,
            "docLength": null
          },
          {
            "id": "3f1ca468-3163-3ba8-e54f-a2fb9ce810fa",
            "ancestors": [
              "68a48220-ebf4-7cb1-6d46-ec8ae0b47c1b"
            ],
            "description": "Creates a new edge in the long-term graph based on data from the short-term graph. It assigns attributes to the new edge, including a translation and rotation value for RT tracking.",
            "params": [
              {
                "name": "org",
                "type_name": "GraphNode | NoneType",
                "description": "Used to specify the starting node of the edge to be inserted. If it is None, it means the starting node is unknown or unspecified."
              },
              {
                "name": "dest",
                "type_name": "Node | str",
                "description": "Used to specify the destination node or edge id for the edge insertion operation."
              }
            ],
            "returns": null,
            "usage": {
              "language": "python",
              "code": "worker = SpecificWorker(proxy_map)\n# Define the nodes and edges in the graph\nnode1 = Node(\"Node 1\", agent_id=worker.agent_id)\nnode2 = Node(\"Node 2\", agent_id=worker.agent_id)\nedge = Edge(node1, node2, \"RT\", worker.agent_id)\n# Call the function to insert the edge into the graph\nworker.insert_dsr_edge(node1, node2)\n",
              "description": ""
            },
            "name": "insert_dsr_edge",
            "location": {
              "start": 665,
              "insert": 668,
              "offset": " ",
              "indent": 8,
              "comment": null
            },
            "item_type": "method",
            "length": 22,
            "docLength": null
          },
          {
            "id": "04491164-d053-7abe-e94a-0772c85a56b6",
            "ancestors": [
              "68a48220-ebf4-7cb1-6d46-ec8ae0b47c1b"
            ],
            "description": "Determines the room number associated with a given node ID by retrieving the attribute \"room_id\" from the node and returning its value if found, or -1 otherwise.",
            "params": [
              {
                "name": "node_id",
                "type_name": "int",
                "description": "Passed as an argument to the function, indicating the id of the element whose room number needs to be checked."
              }
            ],
            "returns": {
              "type_name": "int",
              "description": "The room ID associated with a given node ID if the node has an attribute \"room_id\" and its value is not None, or -1 otherwise."
            },
            "usage": {
              "language": "python",
              "code": "worker = SpecificWorker(proxy_map)\nnode_id = 1234567890\nroom_id = worker.check_element_room_number(node_id)\nif room_id == -1:\n    print(\"Node is not in a room\")\nelse:\n    print(\"Node is in room\", room_id)\n",
              "description": ""
            },
            "name": "check_element_room_number",
            "location": {
              "start": 695,
              "insert": 696,
              "offset": " ",
              "indent": 8,
              "comment": null
            },
            "item_type": "method",
            "length": 7,
            "docLength": null
          },
          {
            "id": "f912f9d3-d6ed-b482-ee40-a7c750e382d7",
            "ancestors": [
              "68a48220-ebf4-7cb1-6d46-ec8ae0b47c1b"
            ],
            "description": "1) retrieves the element level of a node with the given ID, and 2) handles missing or non-existent element levels by printing an error message and returning -1.",
            "params": [
              {
                "name": "node_id",
                "type_name": "int",
                "description": "Representing an element node identifier, which identifies a specific element in the graph."
              }
            ],
            "returns": {
              "type_name": "int",
              "description": "Element level if found, or -1 otherwise."
            },
            "usage": {
              "language": "python",
              "code": "# Initialize SpecificWorker class instance\nworker = SpecificWorker(proxy_map)\n\n# Get node_id of a specific element in the graph\nnode_id = 123456789\n\n# Call check_element_level function to retrieve level attribute value from node\nelement_level = worker.check_element_level(node_id)\n\n# Print retrieved level attribute value for the specified element\nprint(\"Element level:\", element_level)\n",
              "description": ""
            },
            "name": "check_element_level",
            "location": {
              "start": 704,
              "insert": 705,
              "offset": " ",
              "indent": 8,
              "comment": null
            },
            "item_type": "method",
            "length": 25,
            "docLength": null
          },
          {
            "id": "1141fbc6-886b-ab8c-324d-576e1b3fb114",
            "ancestors": [
              "68a48220-ebf4-7cb1-6d46-ec8ae0b47c1b"
            ],
            "description": "Retrieves and processes information about a room node in a graph, including its ID, old RT edges, translation attribute, and doors. It then draws the room polygon and doors on an image for saving.",
            "params": [
              {
                "name": "room_node_id",
                "type_name": "str | int",
                "description": "Used to identify the room for which the picture will be generated."
              }
            ],
            "returns": null,
            "usage": {
              "language": "python",
              "code": "specific_worker = SpecificWorker(proxy_map)\n# Startup check and initialize the robot's name, id, and last robot pose.\nspecific_worker.startup_check()\n\n# Generate the room picture using the specific worker instance and the desired room node ID.\nroom_node_id = 123456 # Replace with actual node ID\nspecific_worker.generate_room_picture(room_node_id)\n",
              "description": ""
            },
            "name": "generate_room_picture",
            "location": {
              "start": 747,
              "insert": 749,
              "offset": " ",
              "indent": 8,
              "comment": null
            },
            "item_type": "method",
            "length": 24,
            "docLength": null
          },
          {
            "id": "abb52b39-2b77-1e95-5943-2ff31d0cfa5b",
            "ancestors": [
              "68a48220-ebf4-7cb1-6d46-ec8ae0b47c1b"
            ],
            "description": "Inserts or assigns an edge in the graph with the current room ID as the tail and the same ID as the head, indicating that the agent is currently located in that room.",
            "params": [
              {
                "name": "room_id",
                "type_name": "str",
                "description": "Used to represent the id of the current room in which the agent is located."
              }
            ],
            "returns": null,
            "usage": {
              "language": "python",
              "code": "worker = SpecificWorker(proxy_map)\nworker.insert_current_edge(room_id)\n",
              "description": ""
            },
            "name": "insert_current_edge",
            "location": {
              "start": 782,
              "insert": 784,
              "offset": " ",
              "indent": 8,
              "comment": null
            },
            "item_type": "method",
            "length": 3,
            "docLength": null
          },
          {
            "id": "c580b131-a2f7-48b2-d347-fd8315f9d58a",
            "ancestors": [
              "68a48220-ebf4-7cb1-6d46-ec8ae0b47c1b"
            ],
            "description": "Updates the node attributes based on user input and inserts new edges into the graph according to predefined rules.",
            "params": [
              {
                "name": "id",
                "type_name": "int",
                "description": "Used to identify the node to be updated."
              },
              {
                "name": "type",
                "type_name": "str",
                "description": "Used to identify the type of node being updated (door or room)."
              }
            ],
            "returns": null,
            "usage": {
              "language": "python",
              "code": "# Call the function update_node() with parameters\nworker.update_node(1, \"door\")\n",
              "description": "\nIn this code snippet, we call the `update_node()` function in the `SpecificWorker` class by passing two arguments: 1 and \"door\". The first argument is the id of the node to be updated, and the second argument is the type of the node, which is door in this case. This call will update the node with the id 1 with the new type information.\n\nWe can also use `update_node()` to update other types of nodes, such as rooms or affordances, by passing different arguments for the type parameter. For example:\n"
            },
            "name": "update_node",
            "location": {
              "start": 796,
              "insert": 797,
              "offset": " ",
              "indent": 8,
              "comment": null
            },
            "item_type": "method",
            "length": 41,
            "docLength": null
          },
          {
            "id": "1b073fde-9b9f-83a1-3541-533c6e7e206e",
            "ancestors": [
              "68a48220-ebf4-7cb1-6d46-ec8ae0b47c1b"
            ],
            "description": "Updates an edge in the graph based on its type, source node, and target node.",
            "params": [
              {
                "name": "fr",
                "type_name": "int",
                "description": "Representing the first room number of an edge to be updated with new information."
              },
              {
                "name": "to",
                "type_name": "int",
                "description": "Used to identify the target node in the graph for updating the edge."
              },
              {
                "name": "type",
                "type_name": "str",
                "description": "Used to indicate whether the edge is a robot or a room node."
              }
            ],
            "returns": null,
            "usage": {
              "language": "python",
              "code": "worker = SpecificWorker(proxy_map, startup_check=False)\n# Update edge in graph\nworker.update_edge(fr=1, to=2, type=\"RT\")\n",
              "description": "\nThis updates the edge with fr as the starting node and to as the ending node with the type of \"RT\"."
            },
            "name": "update_edge",
            "location": {
              "start": 851,
              "insert": 855,
              "offset": " ",
              "indent": 8,
              "comment": null
            },
            "item_type": "method",
            "length": 5,
            "docLength": null
          }
        ]
      }
    }
  },
  {
    "name": "specificworker_sec.py",
    "path": "agents/long_term_spatial_memory_agent/src/specificworker_sec.py",
    "content": {
      "structured": {
        "description": "An igraph object `self` and implements various operations on a graph, including inserting nodes and edges, updating edge attributes, and deleting nodes and edges. The code uses the `igraph` package to perform these operations. Specifically, it inserts a node in the graph with a certain name and ID, updates the RT translation and rotation of an edge connecting two nodes, and deletes a node and edge from the graph. Additionally, it checks if an affordance node is active and sets the state to \"crossed\" if it is completed and not active.",
        "items": [
          {
            "id": "75233bfc-d379-5786-3e4d-6b16aa1599c4",
            "ancestors": [],
            "description": "Manages a graph representation of a robot navigating through a room, handling various actions such as inserting, updating, and deleting nodes and edges, as well as tracking the current state of the room.",
            "attributes": [
              {
                "name": "Period",
                "type_name": "Union[float,int]",
                "description": "Used to represent the time period for which the worker is active."
              },
              {
                "name": "agent_id",
                "type_name": "int|str",
                "description": "Used to store the unique identifier of the agent in the simulation."
              },
              {
                "name": "g",
                "type_name": "igraphGraph",
                "description": "Used to represent the graph of nodes and edges in the environment. It is used for various operations such as inserting, deleting, updating nodes and edges, and drawing the graph."
              },
              {
                "name": "update_node",
                "type_name": "Dict[str,Any]",
                "description": "Used to update the node attributes of a specific node in the graph based on its ID. It takes two arguments: `id` (int) which is the ID of the node to be updated, and `type` (str) which can be either \"door\" or \"room\" indicating whether the node is a door or room node. The function performs different actions depending on the type of node being updated."
              },
              {
                "name": "update_edge",
                "type_name": "Union[int,str]",
                "description": "Used to update the edge attributes of a robot-room pair based on certain conditions, such as when there is no current edge and the room node exists."
              },
              {
                "name": "startup_check",
                "type_name": "bool|str",
                "description": "Used to check if the worker should perform startup tasks such as inserting a node and edge for a room and robot, and setting the state to \"crossed\"."
              },
              {
                "name": "rt_api",
                "type_name": "str|int",
                "description": "Used to store the ID of the robot that the worker is associated with, allowing the worker to perform RT-based actions."
              },
              {
                "name": "inner_api",
                "type_name": "Dict[str,Any]",
                "description": "Used to store additional APIs that are specific to this worker."
              },
              {
                "name": "robot_name",
                "type_name": "str|int",
                "description": "Used to store the ID of the robot that the worker is associated with."
              },
              {
                "name": "robot_id",
                "type_name": "int",
                "description": "Used to identify the robot that the worker is controlling."
              },
              {
                "name": "last_robot_pose",
                "type_name": "Tuple[float,float,float]",
                "description": "Used to store the last known pose of the robot in the environment, which can be used for various tasks such as path planning and obstacle avoidance."
              },
              {
                "name": "robot_exit_pose",
                "type_name": "str|int",
                "description": "Used to store the exit pose of a robot, which is the position and orientation of the robot when it exits a room."
              },
              {
                "name": "state",
                "type_name": "str|int",
                "description": "Used to keep track of the worker's current state (either \"idle\", \"crossed\", or \"completed\")."
              },
              {
                "name": "affordance_node_active_id",
                "type_name": "int|bool",
                "description": "Used to keep track of the active affordance node ID in the graph. It is used to determine when the affordance node has been completed and can transition to the crossed state."
              },
              {
                "name": "exit_door_id",
                "type_name": "int|str",
                "description": "Used to keep track of the id of the door node that leads from a room to the outside world, which is used for various purposes such as routing, affordance detection, and edge insertion."
              },
              {
                "name": "room_exit_door_id",
                "type_name": "int|str",
                "description": "Used to represent the ID of the door node that marks the exit of a room in the graph. It is used for updating edges and inserting current edges."
              },
              {
                "name": "enter_room_node_id",
                "type_name": "int|str",
                "description": "Used to store the ID of the room node that the worker enters when it completes its task."
              },
              {
                "name": "vertex_size",
                "type_name": "float|int",
                "description": "Used to control the size of the vertices in the graph. It determines the width or height of each vertex in the graph, which can be useful for visualization purposes."
              },
              {
                "name": "not_required_attrs",
                "type_name": "List[str]",
                "description": "Used to store a list of attribute names that are not required for the worker's functionality, i.e., they are optional or non-essential attributes."
              },
              {
                "name": "long_term_graph",
                "type_name": "igraphGraph",
                "description": "Used to store the long-term graph of the environment, which can be different from the short-term graph represented by the `g` attribute."
              },
              {
                "name": "graph",
                "type_name": "igraphGraph",
                "description": "Used to store the current state of the graph, which can be updated and manipulated during the execution of the worker's methods."
              },
              {
                "name": "insert_current_edge",
                "type_name": "List[Edge]",
                "description": "Used to insert a new edge into the graph with the specified from and to nodes, and with the \"current\" type."
              },
              {
                "name": "timer",
                "type_name": "int|str",
                "description": "Used to store a timer for the worker, indicating how long it has been running."
              },
              {
                "name": "compute",
                "type_name": "str|int",
                "description": "Used to store the ID of the node that should be updated or inserted in the graph during computation."
              }
            ],
            "name": "SpecificWorker",
            "location": {
              "start": 49,
              "insert": 50,
              "offset": " ",
              "indent": 4,
              "comment": null
            },
            "item_type": "class",
            "length": 592,
            "docLength": null
          },
          {
            "id": "1652a875-3a7c-04b8-3944-add50b4df62e",
            "ancestors": [
              "75233bfc-d379-5786-3e4d-6b16aa1599c4"
            ],
            "description": "Initializes the worker's internal state, including its graph, node ID, and affordance node active ID. It also connects signals for updating nodes and edges and sets up a timer to call the `compute` method periodically.",
            "params": [
              {
                "name": "proxy_map",
                "type_name": "Dict[str, Any]",
                "description": "Used to store a map of proxy nodes for the specific worker."
              },
              {
                "name": "startup_check",
                "type_name": "bool",
                "description": "Used to check if the graph has already been initialized before creating its inner API. It is set to False by default, meaning no check is performed."
              }
            ],
            "returns": null,
            "usage": {
              "language": "python",
              "code": "# create an instance of SpecificWorker class\nspecific_worker = SpecificWorker(proxy_map, startup_check=False)\n\n# call the function to initialize the worker\nspecific_worker.__init__(proxy_map, startup_check=False)\n",
              "description": "\nIn this example, we create an instance of the `SpecificWorker` class and then call its `__init__` method with the required parameters. The `__init__` method initializes the worker by setting up the necessary connections to the Signals module, creating a new graph if it does not exist, and starting the timer for the computation."
            },
            "name": "__init__",
            "location": {
              "start": 50,
              "insert": 51,
              "offset": " ",
              "indent": 8,
              "comment": null
            },
            "item_type": "constructor",
            "length": 53,
            "docLength": null
          },
          {
            "id": "9e3a3660-ca76-efa0-424c-7384a6dfdac5",
            "ancestors": [
              "75233bfc-d379-5786-3e4d-6b16aa1599c4"
            ],
            "description": "Sets the parameters passed as an argument, then modifies the room by removing a self-edge and adding attributes to doors.",
            "params": [
              {
                "name": "params",
                "type_name": "bool",
                "description": "Passed to set the parameters of the Room object."
              }
            ],
            "returns": {
              "type_name": "bool",
              "description": "True."
            },
            "usage": {
              "language": "python",
              "code": "worker = SpecificWorker(proxy_map)\nworker.setParams({'Period': 50})\n",
              "description": "\nIn this example, we create a new instance of the SpecificWorker class and pass in a proxy map as an argument to its constructor. We then use the setParams method to update the Period attribute of the worker instance to 50."
            },
            "name": "setParams",
            "location": {
              "start": 124,
              "insert": 125,
              "offset": " ",
              "indent": 8,
              "comment": null
            },
            "item_type": "method",
            "length": 7,
            "docLength": null
          },
          {
            "id": "13115bf5-e637-5cb7-b343-250c1fd6afbf",
            "ancestors": [
              "75233bfc-d379-5786-3e4d-6b16aa1599c4"
            ],
            "description": "Computes the RT of a robot in a graph, taking into account the current edges and long-term graph information.",
            "params": [],
            "returns": null,
            "usage": {
              "language": "python",
              "code": "worker = SpecificWorker(proxy_map)\nworker.compute()\n",
              "description": "\nIn this example, the user creates an instance of the class SpecificWorker and calls its compute method to execute the code inside it."
            },
            "name": "compute",
            "location": {
              "start": 138,
              "insert": 141,
              "offset": " ",
              "indent": 8,
              "comment": null
            },
            "item_type": "method",
            "length": 37,
            "docLength": null
          },
          {
            "id": "592108b6-327e-ba98-1c49-e5b2b4fb8c1f",
            "ancestors": [
              "75233bfc-d379-5786-3e4d-6b16aa1599c4"
            ],
            "description": "Checks if there are any \"current\" edges or affordance nodes in the graph, and performs actions based on their existence.",
            "params": [],
            "returns": null,
            "usage": {
              "language": "python",
              "code": "# Creating an instance of the SpecificWorker class\nmy_worker = SpecificWorker(proxy_map=None, startup_check=False)\n\n# Calling the idle method with a loop that lasts for 10 seconds\nfor i in range(int(10000 / my_worker.Period)):\n    my_worker.idle()\n",
              "description": ""
            },
            "name": "idle",
            "location": {
              "start": 182,
              "insert": 184,
              "offset": " ",
              "indent": 8,
              "comment": null
            },
            "item_type": "method",
            "length": 76,
            "docLength": null
          },
          {
            "id": "6aed26f6-3473-6faa-7643-8146c8044dbe",
            "ancestors": [
              "75233bfc-d379-5786-3e4d-6b16aa1599c4"
            ],
            "description": "Determines the current room and updates the state of the worker based on whether it is a known or unknown room.",
            "params": [],
            "returns": null,
            "usage": {
              "language": "python",
              "code": "worker = SpecificWorker(proxy_map)\naffordance_node = worker.g.get_node(affordance_id)\nif affordance_node.attrs[\"parent\"].value:\n    exit_door_id = affordance_node.attrs[\"parent\"].value\n    if exit_door_id:\n        exit_door_id_node = worker.g.get_node(exit_door_id)\n        if exit_door_id_node.attrs[\"connected_room_name\"].value:\n            worker.state = \"known_room\"\n",
              "description": ""
            },
            "name": "crossed",
            "location": {
              "start": 283,
              "insert": 285,
              "offset": " ",
              "indent": 8,
              "comment": null
            },
            "item_type": "method",
            "length": 16,
            "docLength": null
          },
          {
            "id": "ab648f62-f59a-0696-1b4f-b5b4de68bc91",
            "ancestors": [
              "75233bfc-d379-5786-3e4d-6b16aa1599c4"
            ],
            "description": "Initializes the room nodes in the graph, identifying and selecting the entrance node based on the exit door ID, and setting the current state to \"initializing doors\".",
            "params": [],
            "returns": null,
            "usage": {
              "language": "python",
              "code": "# Initiate SpecificWorker class\nworker = SpecificWorker(proxy_map, startup_check=False)\n\n# Run initializing_room method\nworker.initializing_room()\n\n# Do something with the result of initializing_room\nprint(\"Room initialized.\")\n",
              "description": ""
            },
            "name": "initializing_room",
            "location": {
              "start": 303,
              "insert": 306,
              "offset": " ",
              "indent": 8,
              "comment": null
            },
            "item_type": "method",
            "length": 10,
            "docLength": null
          },
          {
            "id": "c91dcd80-22ac-4a9b-be40-5caba44d2d63",
            "ancestors": [
              "75233bfc-d379-5786-3e4d-6b16aa1599c4"
            ],
            "description": "Determines the room the robot is currently in, based on the global map and the robot's position, and updates the graph with the appropriate edges and nodes.",
            "params": [],
            "returns": null,
            "usage": {
              "language": "python",
              "code": "import SpecificWorker\n\n# Create a proxy object for the worker\nworker = SpecificWorker.SpecificWorker()\n\n# Set the agent ID for which to perform the task\nagent_id = 13\n\n# Run the function known_room and pass in the agent ID as an argument\nknown_room_output = worker.known_room(agent_id)\n\n# Print the output of the function\nprint(\"Known room:\", known_room_output)\n",
              "description": ""
            },
            "name": "known_room",
            "location": {
              "start": 317,
              "insert": 319,
              "offset": " ",
              "indent": 8,
              "comment": null
            },
            "item_type": "method",
            "length": 73,
            "docLength": null
          },
          {
            "id": "e7db7e8c-ed5d-4192-e74c-af8b90f950ea",
            "ancestors": [
              "75233bfc-d379-5786-3e4d-6b16aa1599c4"
            ],
            "description": "1) identifies exit edges in the graph, 2) finds matching doors, and 3) associates them to create a connected room hierarchy.",
            "params": [],
            "returns": null,
            "usage": {
              "language": "python",
              "code": "# Assume that \"worker\" is an instance of SpecificWorker class\nworker.initializing_doors()\n",
              "description": "\nIn this example, the initializing_doors method is called on the worker object, which is an instance of the SpecificWorker class. The method then performs various actions such as setting up signals and connecting to a runtime API."
            },
            "name": "initializing_doors",
            "location": {
              "start": 411,
              "insert": 413,
              "offset": " ",
              "indent": 8,
              "comment": null
            },
            "item_type": "method",
            "length": 28,
            "docLength": null
          },
          {
            "id": "5cad0a52-9edf-779c-ab40-f409873f2c7f",
            "ancestors": [
              "75233bfc-d379-5786-3e4d-6b16aa1599c4"
            ],
            "description": "Connects two doors in a graph by adding an edge between them and setting their \"other side door name\" and \"connected room name\" attributes.",
            "params": [
              {
                "name": "door_1",
                "type_name": "str",
                "description": "A string representing the name of the first door to be associated with another door."
              },
              {
                "name": "door_2",
                "type_name": "str | int",
                "description": "Used to represent the name of the second door that needs to be associated with the first door."
              }
            ],
            "returns": null,
            "usage": {
              "language": "python",
              "code": "from igraph import Graph\n\n# Create a graph with two nodes and two edges\ng = Graph()\ng.add_vertices([\"A\", \"B\"])\ng.add_edges([(\"A\", \"B\")])\n\n# Use the associate_doors function to add a door between nodes A and B\nspecific_worker = SpecificWorker(proxy_map)\nspecific_worker.associate_doors(door_1=[\"A\", \"C\"], door_2=[\"B\", \"D\"])\n\n# Print the graph\nprint(g)\n",
              "description": "\nIn this example, we first create a graph with two nodes and one edge using the `add_vertices` and `add_edges` methods. Then, we create an instance of the `SpecificWorker` class and use the `associate_doors` method to add a door between nodes A and B. Finally, we print the graph to show that the door has been added correctly."
            },
            "name": "associate_doors",
            "location": {
              "start": 450,
              "insert": 452,
              "offset": " ",
              "indent": 8,
              "comment": null
            },
            "item_type": "method",
            "length": 16,
            "docLength": null
          },
          {
            "id": "a9f2c249-039d-49a4-e240-853633ecd2f4",
            "ancestors": [
              "75233bfc-d379-5786-3e4d-6b16aa1599c4"
            ],
            "description": "Saves the graph data to a file using pickling.",
            "params": [],
            "returns": null,
            "usage": {
              "language": "python",
              "code": "worker = SpecificWorker(proxy_map, startup_check=True)\nworker.store_graph()\n",
              "description": ""
            },
            "name": "store_graph",
            "location": {
              "start": 469,
              "insert": 470,
              "offset": " ",
              "indent": 8,
              "comment": null
            },
            "item_type": "method",
            "length": 11,
            "docLength": null
          },
          {
            "id": "12a2bcfa-ba36-7bb3-404e-aa001af8fb4c",
            "ancestors": [
              "75233bfc-d379-5786-3e4d-6b16aa1599c4"
            ],
            "description": "Removes edges from the long-term graph that have been labeled as RT or has, based on room numbers. It also deletes nodes in the graph that correspond to shadow nodes.",
            "params": [],
            "returns": null,
            "usage": {
              "language": "python",
              "code": "# Initialize the SpecificWorker class and its associated objects\nsw = SpecificWorker(proxy_map, startup_check=False)\n\n# Define a robot name\nrobot_name = \"Shadow\"\n\n# Call the removing method on the initialized SpecificWorker object\nsw.removing(robot_name)\n",
              "description": ""
            },
            "name": "removing",
            "location": {
              "start": 483,
              "insert": 485,
              "offset": " ",
              "indent": 8,
              "comment": null
            },
            "item_type": "method",
            "length": 19,
            "docLength": null
          },
          {
            "id": "c94afa2d-08b0-cc91-8a47-bf999d91cbf5",
            "ancestors": [
              "75233bfc-d379-5786-3e4d-6b16aa1599c4"
            ],
            "description": "Traverses a directed graph represented by an igraph object, starting from a given node ID. It recursively visits all reachable nodes and inserts edges from the root node to each visited node.",
            "params": [
              {
                "name": "node_id",
                "type_name": "int",
                "description": "Representing the unique identifier of a node in the graph to be traversed."
              }
            ],
            "returns": null,
            "usage": {
              "language": "python",
              "code": "# Creating an instance of SpecificWorker class\nmy_worker = SpecificWorker(proxy_map, startup_check=True)\n\n# Traversing the graph starting from the robot's node\nmy_worker.traverse_graph(my_worker.robot_id)\n\n# Printing the traversed nodes and edges\nfor node in my_worker.g.nodes:\n    print(node.id, node.label)\nfor edge in my_worker.g.edges:\n    print(edge.origin, edge.destination)\n",
              "description": ""
            },
            "name": "traverse_graph",
            "location": {
              "start": 509,
              "insert": 511,
              "offset": " ",
              "indent": 8,
              "comment": null
            },
            "item_type": "method",
            "length": 7,
            "docLength": null
          },
          {
            "id": "8a30575b-5e73-bbab-b148-8adc360d99a5",
            "ancestors": [
              "75233bfc-d379-5786-3e4d-6b16aa1599c4"
            ],
            "description": "Iterates through the graph's successors of a given vertex, and for each successor, it checks if the successor's level is higher than the current vertex's level, and if so, it inserts a new vertex and edge in the DSR and recursively traverses the graph.",
            "params": [
              {
                "name": "node",
                "type_name": "igraph.Vertex",
                "description": "Used to represent a specific vertex in the graph."
              }
            ],
            "returns": null,
            "usage": {
              "language": "python",
              "code": "# Example usage of traverse_igraph()\ng = DSRGraph(0, \"LongTermSpatialMemory_agent\", 13)\nnode = g.get_node(\"My_Node\")\ntraverse_igraph(g, node)\n",
              "description": "\nThis code creates an instance of the class GenericWorker and a graph object named g. It also gets a node from the graph using its name \"My_Node\". Then it calls traverse_igraph() with g as an argument and the node as an argument, which initiates the recursive traversal through the graph starting at the given node."
            },
            "name": "traverse_igraph",
            "location": {
              "start": 519,
              "insert": 520,
              "offset": " ",
              "indent": 8,
              "comment": null
            },
            "item_type": "method",
            "length": 10,
            "docLength": null
          },
          {
            "id": "74851935-7e42-4080-e848-40c81557fc8b",
            "ancestors": [
              "75233bfc-d379-5786-3e4d-6b16aa1599c4"
            ],
            "description": "Adds a vertex to an igraph graph, based on attributes provided by a node object. It also tries to find matching vertices using specific attribute values and adds edges between them if found.",
            "params": [
              {
                "name": "node",
                "type_name": "igraph.Node | dict",
                "description": "Used to add a new vertex to an igraph graph with specified attributes."
              }
            ],
            "returns": null,
            "usage": {
              "language": "python",
              "code": "from GenericWorker import SpecificWorker\n\n# create a new worker instance with proxy_map and startup_check=False\nworker = SpecificWorker(proxy_map, startup_check=False)\n\n# add a vertex to the graph with name='node1', id=2, type='room'\nworker.insert_igraph_vertex(node=SpecificWorkerNode(name='node1', id=2, type='room'))\n\n# add another vertex to the graph with name='node2', id=3, type='room'\nworker.insert_igraph_vertex(node=SpecificWorkerNode(name='node2', id=3, type='room'))\n\n# add an edge between the two vertices\nworker.insert_igraph_edge(origin_node=worker.graph.vs[1], other_side_door_node=worker.graph.vs[2])\n",
              "description": ""
            },
            "name": "insert_igraph_vertex",
            "location": {
              "start": 532,
              "insert": 533,
              "offset": " ",
              "indent": 8,
              "comment": null
            },
            "item_type": "method",
            "length": 28,
            "docLength": null
          },
          {
            "id": "6fb56577-9138-aab8-2145-b8d6dbfab0f8",
            "ancestors": [
              "75233bfc-d379-5786-3e4d-6b16aa1599c4"
            ],
            "description": "Inserts a new vertex into a graph, updating the parent node's attribute with the worker's ID and copying over non-optional attributes from the input node to the new vertex.",
            "params": [
              {
                "name": "parent_name",
                "type_name": "str | str",
                "description": "Used to specify the name of the parent node to insert the new node as."
              },
              {
                "name": "node",
                "type_name": "Node",
                "description": "Passed as an instance of the class `Node`."
              }
            ],
            "returns": null,
            "usage": {
              "language": "python",
              "code": "myWorker = SpecificWorker(proxy_map, startup_check=False)\n# create a new node with name \"NewNode\" and type \"Room\":\nnew_node = myWorker.insert_dsr_vertex(\"MyRobot\", {\"type\": \"Room\", \"name\": \"NewNode\"})\n",
              "description": "\nIn this example, the user creates an instance of the `SpecificWorker` class, then calls the `insert_dsr_vertex` function with the parent node name \"MyRobot\" and a dictionary containing the node type and name. The function returns a new node with the specified attributes."
            },
            "name": "insert_dsr_vertex",
            "location": {
              "start": 567,
              "insert": 569,
              "offset": " ",
              "indent": 8,
              "comment": null
            },
            "item_type": "method",
            "length": 9,
            "docLength": null
          },
          {
            "id": "2addb82a-54dd-dbac-cd4a-bb5786953a0f",
            "ancestors": [
              "75233bfc-d379-5786-3e4d-6b16aa1599c4"
            ],
            "description": "Adds an edge to an existing graph based on information provided by the edge attribute, including translation and rotation values.",
            "params": [
              {
                "name": "edge",
                "type_name": "igraph.Edge | GraphElement",
                "description": "An instance representing a single edge to be inserted into the graph."
              }
            ],
            "returns": null,
            "usage": {
              "language": "python",
              "code": "# Create an instance of the SpecificWorker class and initialize it with the proxy map\nworker = SpecificWorker(proxy_map)\n\n# Insert a new edge into the DSRGraph object\nworker.insert_igraph_edge(Edge(origin=\"Origin\", destination=\"Destination\", rt_translation=0, rt_rotation_euler_xyz=[0, 0, 0]))\n",
              "description": ""
            },
            "name": "insert_igraph_edge",
            "location": {
              "start": 581,
              "insert": 582,
              "offset": " ",
              "indent": 8,
              "comment": null
            },
            "item_type": "method",
            "length": 9,
            "docLength": null
          },
          {
            "id": "9645ce4c-8234-ba84-ff45-3574f5a37212",
            "ancestors": [
              "75233bfc-d379-5786-3e4d-6b16aa1599c4"
            ],
            "description": "Inserts or updates an edge in a graph based on the distance-sensitive roadmap (DSR) algorithm, considering the RT translation and rotation of the edge's endpoints.",
            "params": [
              {
                "name": "org",
                "type_name": "Node | None",
                "description": "Used to specify the source node of the edge being inserted. If `org` is None, it means the root node of the graph."
              },
              {
                "name": "dest",
                "type_name": "Node | str",
                "description": "Used to specify the destination node or name in the graph for which to create a new edge with RT attributes."
              }
            ],
            "returns": null,
            "usage": {
              "language": "python",
              "code": "# Creating a new worker class inheriting from GenericWorker\nclass SpecificWorker(GenericWorker):\n    def __init__(self, proxy_map):\n        super(SpecificWorker, self).__init__(proxy_map)\n        # Initializing the DSR graph with an agent ID and robot name\n        self.agent_id = 13\n        self.robot_name = \"Shadow\"\n        self.g = DSRGraph(0, \"LongTermSpatialMemory_agent\", self.agent_id)\n        # Connecting to the signals of the DSR graph\n        try:\n            signals.connect(self.g, signals.UPDATE_NODE, self.update_node)\n            signals.connect(self.g, signals.UPDATE_EDGE, self.update_edge)\n            console.print(\"signals connected\")\n        except RuntimeError as e:\n            print(e)\n",
              "description": "\nThe user can then use the function insert_dsr_edge to add an edge between two nodes in the DSR graph. Here is an example of how this might be done:\n"
            },
            "name": "insert_dsr_edge",
            "location": {
              "start": 595,
              "insert": 598,
              "offset": " ",
              "indent": 8,
              "comment": null
            },
            "item_type": "method",
            "length": 22,
            "docLength": null
          },
          {
            "id": "c91b9329-a134-37b7-f244-aae2be8f76fd",
            "ancestors": [
              "75233bfc-d379-5786-3e4d-6b16aa1599c4"
            ],
            "description": "Generates a graph based on the layout of a Kamada-Kawai graph, and adds node labels and edge annotations.",
            "params": [],
            "returns": null,
            "usage": {
              "language": "python",
              "code": "# Import necessary libraries and classes\nfrom SpecificWorker import GenericWorker, DSRGraph\nimport signals\nimport console\n\n# Instantiate a new instance of SpecificWorker\nworker = SpecificWorker(proxy_map)\n\n# Define the graph object to be drawn\ngraph = DSRGraph(0, \"LongTermSpatialMemory_agent\", worker.agent_id)\n\n# Connect signals to functions in GenericWorker class\nsignals.connect(graph, signals.UPDATE_NODE, worker.update_node)\nsignals.connect(graph, signals.UPDATE_EDGE, worker.update_edge)\n\n# Draw the graph using the draw_graph function\nworker.draw_graph(graph)\n",
              "description": ""
            },
            "name": "draw_graph",
            "location": {
              "start": 625,
              "insert": 626,
              "offset": " ",
              "indent": 8,
              "comment": null
            },
            "item_type": "method",
            "length": 16,
            "docLength": null
          },
          {
            "id": "29f979ee-26a0-1ca3-4747-685c4ee28371",
            "ancestors": [
              "75233bfc-d379-5786-3e4d-6b16aa1599c4"
            ],
            "description": "Retrieves the room ID associated with a given node ID using the Graph object's `get_node` method and attribute access, and returns the room ID if found, or -1 otherwise.",
            "params": [
              {
                "name": "node_id",
                "type_name": "int",
                "description": "Used to identify the element for which the room number needs to be checked."
              }
            ],
            "returns": {
              "type_name": "int",
              "description": "The room ID of a given element if the element has a \"room_id\" attribute, or -1 otherwise."
            },
            "usage": {
              "language": "python",
              "code": "worker = SpecificWorker(proxy_map, startup_check=False)\nroom_id = worker.check_element_room_number(node_id)\nprint(f\"The room ID of the node with ID {node_id} is {room_id}.\")\n",
              "description": ""
            },
            "name": "check_element_room_number",
            "location": {
              "start": 650,
              "insert": 651,
              "offset": " ",
              "indent": 8,
              "comment": null
            },
            "item_type": "method",
            "length": 7,
            "docLength": null
          },
          {
            "id": "5dddb8ec-4dbc-e387-6e48-64f7ff25662a",
            "ancestors": [
              "75233bfc-d379-5786-3e4d-6b16aa1599c4"
            ],
            "description": "Determines the level of an element with a given ID in the internal graph, handles exceptions, and adjusts door connections based on the room similarity.",
            "params": [
              {
                "name": "node_id",
                "type_name": "int",
                "description": "Used to identify the node being checked for its element level attribute value."
              }
            ],
            "returns": {
              "type_name": "int",
              "description": "The level of an element with the given node ID, or -1 if no such attribute is found."
            },
            "usage": {
              "language": "python",
              "code": "# Example of using the check_element_level function\n\n# Create a new instance of the SpecificWorker class\nmy_worker = SpecificWorker(proxy_map, startup_check=False)\n\n# Call the check_element_level function with node_id as an argument\nelement_level = my_worker.check_element_level(\"node_id\")\n",
              "description": ""
            },
            "name": "check_element_level",
            "location": {
              "start": 659,
              "insert": 660,
              "offset": " ",
              "indent": 8,
              "comment": null
            },
            "item_type": "method",
            "length": 25,
            "docLength": null
          },
          {
            "id": "d812eadc-e596-7a97-8447-d13ce3895f4d",
            "ancestors": [
              "75233bfc-d379-5786-3e4d-6b16aa1599c4"
            ],
            "description": "Retrieves information about a room and its RT edges, then draws the room polygon and doors on an image.",
            "params": [
              {
                "name": "room_node_id",
                "type_name": "str | int",
                "description": "Represented as an integer or string, representing the node ID of the room to be drawn."
              }
            ],
            "returns": null,
            "usage": {
              "language": "python",
              "code": "# Importing necessary packages\nfrom SpecificWorker import SpecificWorker\nimport cv2\n\n# Create a new instance of the class SpecificWorker\nworker = SpecificWorker(proxy_map, startup_check=False)\n\n# Call the generate_room_picture method with the desired room node ID as an argument\nroom_node_id = \"Room1\"\nworker.generate_room_picture(room_node_id)\n",
              "description": "\nThis code creates a new instance of the SpecificWorker class, imports the necessary packages, and calls the generate_room_picture method with the desired room node ID as an argument. The function will then generate a 2D image of the room based on the information stored in the graph. The resulting image can be viewed using the OpenCV library by calling cv2.imwrite() or displayed directly using the OpenCV library's display() method."
            },
            "name": "generate_room_picture",
            "location": {
              "start": 702,
              "insert": 704,
              "offset": " ",
              "indent": 8,
              "comment": null
            },
            "item_type": "method",
            "length": 24,
            "docLength": null
          },
          {
            "id": "a50d6999-6284-35be-614f-deef0dec204d",
            "ancestors": [
              "75233bfc-d379-5786-3e4d-6b16aa1599c4"
            ],
            "description": "Inserts or assigns an edge to the graph representing the current room of the agent, with the source and destination being the same agent ID.",
            "params": [
              {
                "name": "room_id",
                "type_name": "str",
                "description": "Passed as an argument to Edge constructor, representing the ID of the current room that the agent is in."
              }
            ],
            "returns": null,
            "usage": {
              "language": "python",
              "code": "worker = SpecificWorker(proxy_map)\nroom_id = 254\nworker.insert_current_edge(room_id)\n",
              "description": ""
            },
            "name": "insert_current_edge",
            "location": {
              "start": 737,
              "insert": 739,
              "offset": " ",
              "indent": 8,
              "comment": null
            },
            "item_type": "method",
            "length": 3,
            "docLength": null
          },
          {
            "id": "9bc1d031-9b8b-578b-b14d-26d0bcd00d92",
            "ancestors": [
              "75233bfc-d379-5786-3e4d-6b16aa1599c4"
            ],
            "description": "Updates a node's information based on its type and other factors, such as checking if a door node exists and inserting it into the graph if necessary, or handling an affordance node's state change.",
            "params": [
              {
                "name": "id",
                "type_name": "int",
                "description": "Used as an identifier for a node in the graph."
              },
              {
                "name": "type",
                "type_name": "str",
                "description": "Used to indicate the type of node being updated."
              }
            ],
            "returns": null,
            "usage": {
              "language": "python",
              "code": "worker = SpecificWorker(proxy_map, startup_check=True)\nif worker.rt_api.is_running():\n    print(\"Robot is running\")\nelse:\n    print(\"Robot is not running\")\n    return\n\n# Update node with id 123 and type \"door\"\nworker.update_node(123, \"door\")\n",
              "description": ""
            },
            "name": "update_node",
            "location": {
              "start": 751,
              "insert": 752,
              "offset": " ",
              "indent": 8,
              "comment": null
            },
            "item_type": "method",
            "length": 41,
            "docLength": null
          },
          {
            "id": "0c89aab3-c848-cb96-6046-4854f3cd0019",
            "ancestors": [
              "75233bfc-d379-5786-3e4d-6b16aa1599c4"
            ],
            "description": "Updates an edge in the graph based on the current node, type, and other conditions.",
            "params": [
              {
                "name": "fr",
                "type_name": "int",
                "description": "Referred to as \"from room\" indicating that it represents the starting point of an edge in the graph, specifically a room node."
              },
              {
                "name": "to",
                "type_name": "int",
                "description": "The id of the target node to which the edge is being updated."
              },
              {
                "name": "type",
                "type_name": "str",
                "description": "Used to specify the type of edge being updated (either \"RT\" or \"FT\")."
              }
            ],
            "returns": null,
            "usage": {
              "language": "python",
              "code": "# Instantiate an object of SpecificWorker class\nworker = SpecificWorker()\n\n# Set the robot name and ID\nworker.robot_name = \"Shadow\"\nworker.robot_id = 13\n\n# Update the edge with type 'RT' between node 0 (the robot) and node 1 (a room exit door)\nworker.update_edge(fr=0, to=1, type=\"RT\")\n",
              "description": ""
            },
            "name": "update_edge",
            "location": {
              "start": 806,
              "insert": 810,
              "offset": " ",
              "indent": 8,
              "comment": null
            },
            "item_type": "method",
            "length": 5,
            "docLength": null
          }
        ]
      }
    }
  }
]