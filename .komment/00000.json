[
  {
    "name": "long_term_graph.py",
    "path": "agents/long_term_spatial_memory_agent/src/long_term_graph.py",
    "content": {
      "structured": {
        "description": "a class `Room` that represents a 2D room with walls, doors, and objects. It uses the Graphviz library to visualize the room using the DOT language. The code has several methods for computing various aspects of the room, such as getting the center point of the room, drawing walls and doors, and computing the projective coordinates of objects in the room frame.\n\nThe `get_room_corners` method computes the corners of a room by traversing the room graph and finding all nodes with type \"corner\". It then returns a list of these nodes. The `get_room_objects_coordinates` method computes the projective coordinates of objects in the room frame by recursively traversing the room graph, finding all nodes with a given object type, and computing the rotation matrix and rotation vector for each object using the shortest path algorithm.\n\nOverall, this code provides a flexible framework for representing and manipulating 2D rooms with various features, such as walls, doors, and objects, using Graphviz for visualization.",
        "items": [
          {
            "id": "a5b8dc06-fd09-cd98-cb49-455fa8997129",
            "ancestors": [],
            "description": "Acts as a plotter for a graph representation of a metric reconstruction. It provides methods to draw rooms and doors, and to customize the plot's appearance.",
            "attributes": [
              {
                "name": "g",
                "type_name": "str|int",
                "description": "Used to specify the color of the graph's edges, defaulting to 'r-' for non-current rooms and 'g-' for current rooms."
              },
              {
                "name": "read_graph",
                "type_name": "Callable[[Union[str,Path],int],Graph]",
                "description": "Used to read a graph from a file specified by the file path or name."
              },
              {
                "name": "fig",
                "type_name": "matplotlibfigureFigure",
                "description": "Used to represent the figure instance for visualization of the graph."
              },
              {
                "name": "ax",
                "type_name": "matplotlibpyplotAxes",
                "description": "Used to represent the axis of the graph. It provides methods for setting various properties of the axes, such as titles, labels, limits, and annotations."
              },
              {
                "name": "fig_2",
                "type_name": "matplotlibfigureFigure",
                "description": "Used to store the second figure object that is created for visualizing the metric reconstruction."
              },
              {
                "name": "ax_2",
                "type_name": "matplotlibpyplotAxes",
                "description": "Used to access and manipulate the second axes object created by the `subplot()` function in the parent plot."
              }
            ],
            "name": "LongTermGraph",
            "location": {
              "start": 15,
              "insert": 16,
              "offset": " ",
              "indent": 4,
              "comment": null
            },
            "item_type": "class",
            "length": 271,
            "docLength": null
          },
          {
            "id": "a7b64245-15fe-bab5-fc4f-fd7f097e041e",
            "ancestors": [
              "a5b8dc06-fd09-cd98-cb49-455fa8997129"
            ],
            "description": "Reads a graph from a file and creates an instance of the Graph class, optionally creating a figure and axes to visualize the graph.",
            "params": [
              {
                "name": "file_name",
                "type_name": "str",
                "description": "Used to specify the path to a graph file from which the graph will be read."
              }
            ],
            "returns": null,
            "usage": {
              "language": "python",
              "code": "# Calling the initialization method of the class LongTermGraph with file_name as a parameter\nltg = LongTermGraph('file.txt')\n\n# Accessing and using the graph instance read from the file\nprint(ltg.g)\nprint(ltg.g.summary())\n",
              "description": ""
            },
            "name": "__init__",
            "location": {
              "start": 16,
              "insert": 17,
              "offset": " ",
              "indent": 8,
              "comment": null
            },
            "item_type": "constructor",
            "length": 22,
            "docLength": null
          },
          {
            "id": "99491a89-ca41-e68a-5e46-7cd175e3030f",
            "ancestors": [
              "a5b8dc06-fd09-cd98-cb49-455fa8997129"
            ],
            "description": "Creates a graph based on a directed graph represented by a NetworkX graph object, and displays it using Matplotlib's scatter and plot functions.",
            "params": [
              {
                "name": "only_rooms",
                "type_name": "bool",
                "description": "Used to filter the nodes and edges of the graph according to their types, only including rooms and doors."
              }
            ],
            "returns": null,
            "usage": {
              "language": "python",
              "code": "import matplotlib.pyplot as plt\nfrom LongTermGraph import LongTermGraph\n\n# Create a graph object from a file\ngt = LongTermGraph(\"path/to/file\")\n\n# Draw the graph with only rooms and doors\ngt.draw_graph(only_rooms=True)\n\n# Update the plot\nplt.show()\n",
              "description": ""
            },
            "name": "draw_graph",
            "location": {
              "start": 254,
              "insert": 255,
              "offset": " ",
              "indent": 8,
              "comment": null
            },
            "item_type": "method",
            "length": 33,
            "docLength": null
          }
        ]
      }
    }
  },
  {
    "name": "genericworker.py",
    "path": "agents/g2o_agent/src/genericworker.py",
    "content": {
      "structured": {
        "description": "A worker class that inherits from QtWidgets.QWidget and provides a kill signal for shutting down the worker. The code also sets up an ice slice and imports a RoboCompCommonBehavior module. Additionally, the code creates a Ui_guiDlg class and initializes a timer to call a method every 30 milliseconds.",
        "items": [
          {
            "id": "cb6f42fc-bcd1-7fb5-eb49-91afccba59e8",
            "ancestors": [],
            "description": "Manages a worker process with a periodic timer and provides a signal for termination. It also has a method to set the period of the timer.",
            "attributes": [
              {
                "name": "kill",
                "type_name": "QtCoreSignal",
                "description": "Used to emit a signal when the object needs to be killed."
              },
              {
                "name": "ui",
                "type_name": "Ui_guiDlg",
                "description": "Used to initialize and access the user interface of the widget."
              },
              {
                "name": "mutex",
                "type_name": "QMutex",
                "description": "Used to protect access to the internal state of the worker object, particularly the timer and kill signal."
              },
              {
                "name": "Period",
                "type_name": "int",
                "description": "30 milliseconds by default, which represents the time interval for the timer to run."
              },
              {
                "name": "timer",
                "type_name": "QTimer",
                "description": "Used to schedule a call to the `killYourSelf` slot after a specified period of time."
              }
            ],
            "name": "GenericWorker",
            "location": {
              "start": 43,
              "insert": 45,
              "offset": " ",
              "indent": 4,
              "comment": null
            },
            "item_type": "class",
            "length": 26,
            "docLength": null
          },
          {
            "id": "795c292f-f253-f1aa-a748-23953c9013be",
            "ancestors": [
              "cb6f42fc-bcd1-7fb5-eb49-91afccba59e8"
            ],
            "description": "Initializes an instance of the `GenericWorker` class, setting up a GUI dialog and creating a mutex for managing access to the timer. It also sets the period of the timer to 30 seconds.",
            "params": [
              {
                "name": "mprx",
                "type_name": "Ui_guiDlg",
                "description": "Used as an argument for the setupUi method."
              }
            ],
            "returns": null,
            "name": "__init__",
            "location": {
              "start": 47,
              "insert": 48,
              "offset": " ",
              "indent": 8,
              "comment": null
            },
            "item_type": "method",
            "length": 9,
            "docLength": null
          },
          {
            "id": "ea51cd3f-4286-88a2-5c4e-a765280c1202",
            "ancestors": [
              "cb6f42fc-bcd1-7fb5-eb49-91afccba59e8"
            ],
            "description": "Emits the `kill` signal, indicating that the instance should be destroyed.",
            "params": [],
            "returns": null,
            "name": "killYourSelf",
            "location": {
              "start": 60,
              "insert": 62,
              "offset": " ",
              "indent": 8,
              "comment": null
            },
            "item_type": "method",
            "length": 4,
            "docLength": null
          },
          {
            "id": "20082581-a4f0-66af-9a45-78e2e70b070f",
            "ancestors": [
              "cb6f42fc-bcd1-7fb5-eb49-91afccba59e8"
            ],
            "description": "Updates the `Period` attribute and starts a timer with the new period value using the `timer.start()` method.",
            "params": [
              {
                "name": "p",
                "type_name": "int",
                "description": "Used to set the new period for the timer."
              }
            ],
            "returns": null,
            "name": "setPeriod",
            "location": {
              "start": 67,
              "insert": 69,
              "offset": " ",
              "indent": 8,
              "comment": null
            },
            "item_type": "method",
            "length": 5,
            "docLength": null
          }
        ]
      }
    }
  },
  {
    "name": "specificworker.py",
    "path": "agents/g2o_agent/src/specificworker.py",
    "content": {
      "structured": {
        "description": "A class `RosOdometry` that handles robot odometry data from a ROS node. It has various methods for updating and deleting nodes and edges in the graph, as well as handling different types of updates such as current position, RT translation, and room changes. The code uses the `graph` package to handle the graph structure and the `rospy` package for ROS-related functionality.",
        "items": [
          {
            "id": "81834b2b-13a8-409b-7041-ea7aad5792ec",
            "ancestors": [],
            "description": "Manages a specific robot's state and updates its graph, edges, and attributes based on messages from the occupancy grid. It also handles room changes and RT sets for the specified robot.",
            "attributes": [
              {
                "name": "Period",
                "type_name": "float|int",
                "description": "200 by default, indicating the time interval (in milliseconds) between updates of the graph. It can be modified to adjust the update rate of the worker."
              },
              {
                "name": "agent_id",
                "type_name": "int|str",
                "description": "A unique identifier for the agent, which can be used to identify specific agents within the system."
              },
              {
                "name": "g",
                "type_name": "Graph|QGraphicsScene",
                "description": "Used to store and manipulate the graph data structure."
              },
              {
                "name": "startup_check",
                "type_name": "QTimersingleShot200,QApplicationinstancequit",
                "description": "Set to call the quit function of the QApplication instance after a delay of 200 milliseconds."
              },
              {
                "name": "rt_api",
                "type_name": "Union[int,str]",
                "description": "Used to store the API for the Robot Translation (RT) functionality in the worker. It can take the value of either an integer representing the RT algorithm or a string representing the RT algorithm name."
              },
              {
                "name": "inner_api",
                "type_name": "Dict[str,Any]",
                "description": "Used to store additional internal data for the worker, such as the current room ID or the first RT set. It is only accessible within the worker's implementation and is not part of the public API."
              },
              {
                "name": "odometry_node_id",
                "type_name": "int",
                "description": "Used to identify the node in the graph that represents the robot's position and orientation."
              },
              {
                "name": "odometry_queue",
                "type_name": "List[Tuple[float,float,float,int]]",
                "description": "Used to store the latest odometry data from the robot's sensors for graph updating."
              },
              {
                "name": "last_odometry",
                "type_name": "float|List[float]",
                "description": "Used to store the last known odometry information of the robot, including its position, velocity, and angular velocity, which are updated every 200 milliseconds."
              },
              {
                "name": "g2o",
                "type_name": "Graph|npndarray",
                "description": "Used to represent the graph of the environment, allowing the worker to perform operations on it such as adding or deleting nodes and edges."
              },
              {
                "name": "odometry_noise_std_dev",
                "type_name": "float|int",
                "description": "Used to represent the standard deviation of noise in the odometry measurements. It determines how much the actual robot position, orientation, and velocity are expected to deviate from their predicted values based on the odometry measurements."
              },
              {
                "name": "odometry_noise_angle_std_dev",
                "type_name": "float|int",
                "description": "1.0 by default, which represents the standard deviation of the noise angle in the odometry measurement. It helps to quantify the uncertainty in the estimated angle of the robot's movement."
              },
              {
                "name": "measurement_noise_std_dev",
                "type_name": "float|int",
                "description": "Used to represent the standard deviation of measurement noise in the robot's odometry readings. It is used to estimate the uncertainty of the robot's position and velocity."
              },
              {
                "name": "last_room_id",
                "type_name": "str|int",
                "description": "Used to store the last room ID seen by the agent before changing rooms, used for updating the RT set."
              },
              {
                "name": "actual_room_id",
                "type_name": "str|int",
                "description": "Used to store the current room ID of the agent, which is updated when the agent moves to a new room."
              },
              {
                "name": "elapsed",
                "type_name": "float|int",
                "description": "Used to keep track of the time since the last call to the `update()` method, which is used to control the frequency of updates to the graph."
              },
              {
                "name": "room_initialized",
                "type_name": "bool",
                "description": "Set to False when a room change is detected, indicating that the worker has switched rooms. It is then reset to True once the new room's ID is determined."
              },
              {
                "name": "iterations",
                "type_name": "int|List[int]",
                "description": "Used to keep track of the number of iterations of the worker's function that have been performed, or the list of iteration numbers if the function is called multiple times with different inputs."
              },
              {
                "name": "hide",
                "type_name": "bool",
                "description": "Used to hide the worker from the graphical user interface (GUI) when set to True."
              },
              {
                "name": "init_graph",
                "type_name": "bool",
                "description": "Used to track whether the graph has been initialized by the worker during its lifetime. It is used to prevent unnecessary work from being performed when the graph has already been initialized."
              },
              {
                "name": "current_edge_set",
                "type_name": "bool",
                "description": "Used to indicate whether the current edge being processed is part of a RT set or not. It is set to True when a new RT edge is encountered, and False otherwise."
              },
              {
                "name": "first_rt_set",
                "type_name": "bool",
                "description": "Set to True when the robot performs its first RT (Real-time) movement, indicating that the worker has started tracking RT movements."
              },
              {
                "name": "translation_to_set",
                "type_name": "float|List[float]",
                "description": "Used to store the translation value to set for the shadow robot. The list stores the values of the translation in the x, y, and z dimensions respectively."
              },
              {
                "name": "rotation_to_set",
                "type_name": "float|int",
                "description": "Used to store the rotation of the robot to set its position relative to its starting point."
              },
              {
                "name": "room_polygon",
                "type_name": "Tuple[float,float,float,]",
                "description": "Used to store the coordinates of a room's polygon in a graph."
              },
              {
                "name": "security_polygon",
                "type_name": "Polygon|List[Point]",
                "description": "Used to store the security polygon of a room, which is used for collision detection and avoidance during robot navigation."
              },
              {
                "name": "initialize_g2o_graph",
                "type_name": "void|QTimersingleShot200,QApplicationinstancequit",
                "description": "Used to initialize a Graph2O graph for representing the environment."
              },
              {
                "name": "rt_set_last_time",
                "type_name": "int|float",
                "description": "Used to track the time since the last RT (Room To) set by the agent. It is used to determine when to reset the translation and rotation to set values."
              },
              {
                "name": "rt_time_min",
                "type_name": "float|int",
                "description": "Defined as a minimum time gap between two successive RT edge sets, used to determine when to update the translation and rotation values for the agent."
              },
              {
                "name": "last_update_with_corners",
                "type_name": "int|bool",
                "description": "Used to keep track of when the worker has last updated its state with corners data. It is initially set to True, indicating that the worker has not yet received any corners data, and then is updated to False whenever the worker receives new corners data."
              },
              {
                "name": "timer",
                "type_name": "int|float",
                "description": "Used to track the time elapsed since the last update of the graph, with the purpose of checking if it's been a certain amount of time (200ms) since the last update, and if so, quit the application."
              },
              {
                "name": "compute",
                "type_name": "Callable[[float,float],float]",
                "description": "Used to compute the next node ID for the worker's node. It takes two arguments: the current time and a seed value, and returns the next node ID as a float value."
              },
              {
                "name": "update_node_att",
                "type_name": "Tuple[int,str,int,int]",
                "description": "Used to update the attributes of a node in the graph when the node's ID matches the given ID. The attribute takes four arguments: the node ID, the attribute names, the old value, and the new value."
              },
              {
                "name": "update_edge",
                "type_name": "Callable[float,float,str]",
                "description": "Used to update the edge attributes of a graph based on specific conditions. It takes three arguments: the first is the source node ID, the second is the target node ID, and the third is the edge type. The attribute is called whenever a new edge is added or an existing edge is modified in the graph, and it can be used to set or update edge attributes based on specific conditions."
              },
              {
                "name": "update_edge_att",
                "type_name": "List[str]",
                "description": "Used to update the attributes of an edge based on a specific type and name. It takes three parameters: the first is the id of the edge, the second is the type of edge, and the third is a list of attribute names to be updated."
              }
            ],
            "name": "SpecificWorker",
            "location": {
              "start": 50,
              "insert": 51,
              "offset": " ",
              "indent": 4,
              "comment": null
            },
            "item_type": "class",
            "length": 421,
            "docLength": null
          },
          {
            "id": "dff97ec1-552a-9187-a548-c33a4b688e14",
            "ancestors": [
              "81834b2b-13a8-409b-7041-ea7aad5792ec"
            ],
            "description": "Initializes the worker's internal state, including its graph, odometry queue, and other components essential for its operation.",
            "params": [
              {
                "name": "proxy_map",
                "type_name": "Dict[str, Any]",
                "description": "Used to pass additional data to the SpecificWorker object."
              },
              {
                "name": "startup_check",
                "type_name": "bool",
                "description": "Used to check if the graph has been properly initialized before starting the worker's computation. If set to `False`, it will skip this check and proceed with the computation."
              }
            ],
            "returns": null,
            "usage": {
              "language": "python",
              "code": "from SpecificWorker import SpecificWorker\n\n# Create an instance of the SpecificWorker class, passing in necessary arguments and initializing variables.\nproxy_map = {}\nworker = SpecificWorker(proxy_map)\n\n# Use the init method to initialize any necessary variables or perform any initialization actions that need to be done once when the object is created.\nworker.init()\n\n# Use the compute method to perform any computations required by the program and update any necessary variables.\nworker.compute()\n",
              "description": ""
            },
            "name": "__init__",
            "location": {
              "start": 51,
              "insert": 52,
              "offset": " ",
              "indent": 8,
              "comment": null
            },
            "item_type": "constructor",
            "length": 54,
            "docLength": null
          },
          {
            "id": "494ffcaf-17f0-9292-5440-6391c5fd6330",
            "ancestors": [
              "81834b2b-13a8-409b-7041-ea7aad5792ec"
            ],
            "description": "Processes robot odometry data and updates the graph using G2O optimization to estimate the robot's position and orientation.",
            "params": [],
            "returns": null,
            "usage": {
              "language": "python",
              "code": "# Example usage of the Python function compute\ndef main():\n    # Create a new instance of the SpecificWorker class\n    specific_worker = SpecificWorker(proxy_map)\n\n    # Set some initial values for the worker's attributes\n    specific_worker.agent_id = 20\n    specific_worker.g = DSRGraph(0, \"G2O_agent\", specific_worker.agent_id)\n\n    # Call the compute function with a few arguments\n    specific_worker.compute(args=[\"--input-file\", \"/path/to/input_file.csv\"])\n\n# Call the main function to run the example code\nif __name__ == \"__main__\":\n    main()\n",
              "description": ""
            },
            "name": "compute",
            "location": {
              "start": 123,
              "insert": 125,
              "offset": " ",
              "indent": 8,
              "comment": null
            },
            "item_type": "method",
            "length": 101,
            "docLength": null
          },
          {
            "id": "2140c48f-ed84-5b99-2545-c6c54962a658",
            "ancestors": [
              "81834b2b-13a8-409b-7041-ea7aad5792ec"
            ],
            "description": "1) initializes the g2o graph based on room and robot nodes, 2) adds nominal corners for rooms and doors, and 3) fixes the pose of a robot node using odometry information.",
            "params": [],
            "returns": {
              "type_name": "bool",
              "description": "1 if the g2o graph is successfully initialized with nominal corners and fixed poses, and 0 otherwise."
            },
            "usage": {
              "language": "python",
              "code": "import SpecificWorker\n\n# Create a new instance of the worker class and call its initialize method with some arguments.\nworker = SpecificWorker(proxy_map=True, startup_check=False)\nworker.initialize_g2o_graph()\n\n# Some time later, use the g2o graph object to perform operations such as adding a new node or edge.\nworker.g2o.add_node(name='NewNode')\n",
              "description": ""
            },
            "name": "initialize_g2o_graph",
            "location": {
              "start": 252,
              "insert": 255,
              "offset": " ",
              "indent": 8,
              "comment": null
            },
            "item_type": "method",
            "length": 115,
            "docLength": null
          },
          {
            "id": "196e3e68-4c11-b38e-7b41-719b5edd6101",
            "ancestors": [
              "81834b2b-13a8-409b-7041-ea7aad5792ec"
            ],
            "description": "Calculates the displacement of the robot in three dimensions (lateral, forward, and angular) based on the odometry data stored in a queue.",
            "params": [
              {
                "name": "odometry",
                "type_name": "Tuple[float, float, float]",
                "description": "A sequence of 3-element tuples representing the robot's position, velocity, and timestamp in a time interval."
              }
            ],
            "returns": {
              "type_name": "Tuple[float,float,float]",
              "description": "3 floating-point values representing the lateral displacement, forward displacement, and angular displacement of an object over a given time interval."
            },
            "usage": {
              "language": "python",
              "code": "specific_worker = SpecificWorker(proxy_map=SomeProxyMap)\ndesplazamiento_lateral, desplazamiento_avance, desplazamiento_angular = specific_worker.get_displacement(odometry=SomeOdometry)\nprint(\"Displacement:\", displacement)\n",
              "description": ""
            },
            "name": "get_displacement",
            "location": {
              "start": 457,
              "insert": 458,
              "offset": " ",
              "indent": 8,
              "comment": null
            },
            "item_type": "method",
            "length": 14,
            "docLength": null
          },
          {
            "id": "6c21ce38-1c27-049b-984f-6be77c359b75",
            "ancestors": [
              "81834b2b-13a8-409b-7041-ea7aad5792ec"
            ],
            "description": "Computes the covariance matrix between a given vertex and all other vertices in the graph, using the G2O optimizer to compute marginals and upper triangle matrix representation.",
            "params": [
              {
                "name": "vertex",
                "type_name": "G2O.Vertex | G2O.HessianIndex",
                "description": "Used to compute the covariance matrix for a specific vertex in the graph."
              }
            ],
            "returns": {
              "type_name": "numpyndarray",
              "description": "2-dimensional and upper-triangular matrix representing the covariance matrix between a given vertex and all other vertices in the graph."
            },
            "usage": {
              "language": "python",
              "code": "# Create an instance of SpecificWorker\nworker = SpecificWorker()\n\n# Call the get_covariance_matrix method with a vertex as argument\nvertex = g2o.VertexSE3(0)  # Create a VertexSE3 object with index 0\nresult, cov_mat = worker.get_covariance_matrix(vertex)\n\n# Print the result and covariance matrix\nprint(f\"Result: {result}\")\nprint(f\"Covariance Matrix:\\n{cov_mat}\")\n",
              "description": ""
            },
            "name": "get_covariance_matrix",
            "location": {
              "start": 476,
              "insert": 477,
              "offset": " ",
              "indent": 8,
              "comment": null
            },
            "item_type": "method",
            "length": 11,
            "docLength": null
          },
          {
            "id": "32bdf14a-da4a-c7ae-2443-b9488fb241d4",
            "ancestors": [
              "81834b2b-13a8-409b-7041-ea7aad5792ec"
            ],
            "description": "Visualizes the real-time optimization process of a G2O algorithm by plotting the positions and edges of the vertices in 3D space.",
            "params": [
              {
                "name": "optimizer",
                "type_name": "object | Optimizer",
                "description": "Used to load G2O files, estimate vertex positions, and visualize them in real-time."
              }
            ],
            "returns": null,
            "usage": {
              "language": "python",
              "code": "from SpecificWorker import SpecificWorker\nimport matplotlib.pyplot as plt\n\n# Create a new instance of the SpecificWorker class\nworker = SpecificWorker()\n\n# Load a graph file and set up the G2OGraph object\nworker.g2o.load(\"archivo.g2o\")\n\n# Visualize the real-time optimization process using matplotlib's 3D plotting library\nplt.ion()\nfig = plt.figure()\nax = fig.add_subplot(111, projection='3d')\nworker.visualize_g2o_realtime(optimizer)\n",
              "description": ""
            },
            "name": "visualize_g2o_realtime",
            "location": {
              "start": 489,
              "insert": 490,
              "offset": " ",
              "indent": 8,
              "comment": null
            },
            "item_type": "method",
            "length": 29,
            "docLength": null
          },
          {
            "id": "db934395-dc97-4b9f-7f41-4d42e8474534",
            "ancestors": [
              "81834b2b-13a8-409b-7041-ea7aad5792ec"
            ],
            "description": "Updates the attributes of a node in a graph, specifically the odometry queue.",
            "params": [
              {
                "name": "id",
                "type_name": "int",
                "description": "Represented as an integer value that identifies the node to be updated."
              },
              {
                "name": "attribute_names",
                "type_name": "[str]",
                "description": "An array containing the names of attributes to be updated for the given node ID."
              }
            ],
            "returns": null,
            "usage": {
              "language": "python",
              "code": "# Import SpecificWorker class from the module specific_worker.py\nfrom specific_worker import SpecificWorker\n\n# Initialize a SpecificWorker object named \"specific_worker\" with proxy map and startup check as True\nspecific_worker = SpecificWorker(proxy_map=True, startup_check=True)\n\n# Update node attribute using the update_node_att method\nspecific_worker.update_node_att(id=20, attribute_names=[\"robot_current_advance_speed\", \"robot_current_side_speed\", \"robot_current_angular_speed\"])\n",
              "description": "\nIn this example, we initialize a SpecificWorker object with proxy map and startup check as True. Then, we use the update_node_att method to update the node attribute of the robot with ID 20 by passing in the attribute names that we want to update. The update_node_att method is then executed using the specific_worker object."
            },
            "name": "update_node_att",
            "location": {
              "start": 526,
              "insert": 535,
              "offset": " ",
              "indent": 8,
              "comment": null
            },
            "item_type": "method",
            "length": 7,
            "docLength": null
          },
          {
            "id": "adfc3c84-948f-4690-934e-0275aa1375a7",
            "ancestors": [
              "81834b2b-13a8-409b-7041-ea7aad5792ec"
            ],
            "description": "Updates a node with ID `id`. The method checks if the node type is \"corner\", and if so, it retrieves the room node from the graph and sets a flag indicating that the room has been initialized.",
            "params": [
              {
                "name": "id",
                "type_name": "int",
                "description": "Used to identify the node to be updated."
              },
              {
                "name": "type",
                "type_name": "str",
                "description": "Used to specify the node's type."
              }
            ],
            "returns": null,
            "usage": {
              "language": "python",
              "code": "# Assuming you have created an instance of the SpecificWorker class, worker, as shown in the previous code snippet\nworker.update_node(id=100, type='corner')  # Updates the node with ID 100 to be a corner\n",
              "description": "\nThis example shows how the update_node function can be used to update the specific node with ID 100 to be of type 'corner'."
            },
            "name": "update_node",
            "location": {
              "start": 542,
              "insert": 552,
              "offset": " ",
              "indent": 8,
              "comment": null
            },
            "item_type": "method",
            "length": 6,
            "docLength": null
          },
          {
            "id": "3e556671-8722-7790-9c4b-f6eb29ed8f0f",
            "ancestors": [
              "81834b2b-13a8-409b-7041-ea7aad5792ec"
            ],
            "description": "Deletes a node from a list or dict based on its ID, setting `self.room_initialized` to `False`.",
            "params": [
              {
                "name": "id",
                "type_name": "int",
                "description": "Intended to represent the unique identifier for the node being deleted."
              }
            ],
            "returns": null,
            "usage": {
              "language": "python",
              "code": "# Create an instance of SpecificWorker class\nworker = SpecificWorker(proxy_map)\n\n# Call delete_node method with node id as parameter\nworker.delete_node(1234)\n",
              "description": ""
            },
            "name": "delete_node",
            "location": {
              "start": 554,
              "insert": 555,
              "offset": " ",
              "indent": 8,
              "comment": null
            },
            "item_type": "method",
            "length": 6,
            "docLength": null
          },
          {
            "id": "ad7c5a47-c41a-8982-0d4b-b1573ab838c8",
            "ancestors": [
              "81834b2b-13a8-409b-7041-ea7aad5792ec"
            ],
            "description": "Updates the room ID and sets the current edge set based on the type of edge received from the graph.",
            "params": [
              {
                "name": "fr",
                "type_name": "int",
                "description": "Representing the starting node index of an edge in a graph."
              },
              {
                "name": "to",
                "type_name": "int",
                "description": "The target node index of the edge to be updated, which can be either a room or the Shadow node."
              },
              {
                "name": "type",
                "type_name": "str",
                "description": "Used to specify the edge type, which can be either \"current\" or \"RT\"."
              }
            ],
            "returns": null,
            "usage": {
              "language": "python",
              "code": "# Initialize the SpecificWorker class and its graph g\nspecific_worker = SpecificWorker(proxy_map=ProxyMap())\nspecific_worker.g = DSRGraph()\n\n# Add nodes to the graph\nnode1 = specific_worker.g.add_node(\"Node 1\")\nnode2 = specific_worker.g.add_node(\"Node 2\")\n\n# Add edges between the nodes\nedge = specific_worker.g.add_edge(node1, node2)\n\n# Call the update_edge function to set a new edge type\nspecific_worker.update_edge(fr=node1, to=node2, type=\"current\")\n\n# Update the graph with the new edge type\nspecific_worker.g.update()\n",
              "description": ""
            },
            "name": "update_edge",
            "location": {
              "start": 563,
              "insert": 564,
              "offset": " ",
              "indent": 8,
              "comment": null
            },
            "item_type": "method",
            "length": 22,
            "docLength": null
          },
          {
            "id": "e0e06e79-6b30-35bd-c340-bdc7b00ca599",
            "ancestors": [
              "81834b2b-13a8-409b-7041-ea7aad5792ec"
            ],
            "description": "Deletes an edge from a graph, specified by its index (fr) and the index of its adjacent vertex (to). The edge's type can be specified for further filtering.",
            "params": [
              {
                "name": "fr",
                "type_name": "int",
                "description": "1st argument or input of the function indicating the first vertex or node to delete an edge from."
              },
              {
                "name": "to",
                "type_name": "int",
                "description": "Used to specify the destination vertex ID for the edge deletion operation."
              },
              {
                "name": "type",
                "type_name": "str",
                "description": "Used to indicate the edge type to be deleted, with possible values 'in' or 'out'."
              }
            ],
            "returns": null,
            "usage": {
              "language": "python",
              "code": "# Delete an edge from the graph\nworker.delete_edge(fr=1, to=2, type=\"TYPE\")\n",
              "description": "\nIn this example, the `delete_edge` method of the SpecificWorker class is called with three arguments: fr, to, and type. The first two arguments, fr and to, represent the source and target nodes of the edge that should be deleted, respectively. The third argument, type, specifies the type of the edge that should be deleted.\n\nFor instance, if we want to delete an edge with the source node being node 1 and the target node being node 2, and the edge has a type of \"TYPE\", we can call the `delete_edge` method as follows:\n"
            },
            "name": "delete_edge",
            "location": {
              "start": 591,
              "insert": 592,
              "offset": " ",
              "indent": 8,
              "comment": null
            },
            "item_type": "method",
            "length": 3,
            "docLength": null
          }
        ]
      }
    }
  },
  {
    "name": "long_term_graph.py",
    "path": "agents/long_term_spatial_memory_agent/scripts/long_term_graph.py",
    "content": {
      "structured": {
        "description": "a function called draw_metric_map that takes in a metric map object and plots the map using Matplotlib. It first loads the graph from a text file and defines various functions to work with the graph, such as get_room_corners, get_room_objects, and get_room_objects_coordinates. These functions recursively traverse the graph to find the corners or objects in a room, respectively. The draw_metric_map function then uses these functions to plot the rooms and objects in the map. Specifically, it plots each room as a rectangle and adds names to each room, and it plots each object as a point and adds a text label with its name.",
        "items": [
          {
            "id": "5176435a-f92b-e4bd-1b4e-e1e310ab5ae8",
            "ancestors": [],
            "description": "Draws a graph of long-term spatial mobility data using PyQt and Matplotlib. It provides methods to visualize rooms, doors, walls, and edges in the graph.",
            "attributes": [
              {
                "name": "g",
                "type_name": "Graph",
                "description": "Used to represent the graph object that contains the rooms, doors, and walls to be visualized."
              },
              {
                "name": "read_graph",
                "type_name": "instance",
                "description": "Used to read a graph from a file specified by the user. It takes a string path as input and reads the graph data from it."
              },
              {
                "name": "fig",
                "type_name": "instance",
                "description": "A reference to the figure object that will be used to draw the graph."
              },
              {
                "name": "ax",
                "type_name": "MatplotlibFigure",
                "description": "Used to represent the axis object for the graph. It provides methods for adding patches, lines, and other visual elements to the graph."
              }
            ],
            "name": "LongTermGraph",
            "location": {
              "start": 15,
              "insert": 16,
              "offset": " ",
              "indent": 4,
              "comment": null
            },
            "item_type": "class",
            "length": 198,
            "docLength": null
          },
          {
            "id": "411ae665-2c3f-efb9-7546-d76e93280634",
            "ancestors": [
              "5176435a-f92b-e4bd-1b4e-e1e310ab5ae8"
            ],
            "description": "Initializes an object of `LongTermGraph` class, loading a graph from a file using the `read_graph` method and displaying its summary.",
            "params": [
              {
                "name": "file_name",
                "type_name": "str",
                "description": "Used to specify the name of a file containing a graph represented as an adjacency matrix."
              }
            ],
            "returns": null,
            "name": "__init__",
            "location": {
              "start": 16,
              "insert": 17,
              "offset": " ",
              "indent": 8,
              "comment": null
            },
            "item_type": "method",
            "length": 8,
            "docLength": null
          },
          {
            "id": "fbfe681a-6ac8-9cb2-ad48-9c2d64fec643",
            "ancestors": [
              "5176435a-f92b-e4bd-1b4e-e1e310ab5ae8"
            ],
            "description": "Generates a graphical representation of a subgraph within a larger graph, based on node and edge properties. It creates a figure and axis object, sets the title, and draws the nodes and edges using different colors for each type of node or edge.",
            "params": [
              {
                "name": "only_rooms",
                "type_name": "bool",
                "description": "Used to filter the nodes in the graph based on their types, only showing rooms and doors."
              }
            ],
            "returns": null,
            "name": "draw_graph",
            "location": {
              "start": 191,
              "insert": 192,
              "offset": " ",
              "indent": 8,
              "comment": null
            },
            "item_type": "method",
            "length": 34,
            "docLength": null
          }
        ]
      }
    }
  },
  {
    "name": "main.py",
    "path": "agents/long_term_spatial_memory_agent/scripts/main.py",
    "content": {
      "structured": {
        "description": "Three functions: draw_graph, find_edge_with_attribute, and get_connected_door_nodes. The draw_graph function takes a graph object as input and uses PySide2's QtCore module to create a subplot and plot points on the graph. The find_edge_with_attribute function searches for an edge in a given graph based on a specific attribute, and the get_connected_door_nodes function recursively traverses a graph to find all connected door nodes in a given room. The code also loads a graph from a pickled file using the LongTermGraph class, and uses the compute_metric_map and draw_metric_map functions to display the graph's metric map and point locations.",
        "items": [
          {
            "id": "d3824e62-3401-2c9e-394e-2ee9ee755e69",
            "ancestors": [],
            "description": "Generates a graph based on a provided adjacency matrix using Kamada-Kawai layout algorithm, and adds node names and edges with arrowheads.",
            "params": [
              {
                "name": "graph",
                "type_name": "AbstractGraph",
                "description": "Used to represent a graph object that contains vertices and edges."
              }
            ],
            "returns": null,
            "name": "draw_graph",
            "location": {
              "start": 6,
              "insert": 7,
              "offset": " ",
              "indent": 4,
              "comment": null
            },
            "item_type": "function",
            "length": 24,
            "docLength": null
          },
          {
            "id": "d7906eb3-709a-3c95-7c40-18ce0ab8dcfd",
            "ancestors": [],
            "description": "Searches through a graph's edges for an edge with a specific attribute equal to a given value. If such an edge is found, it returns it; otherwise, it returns `None`.",
            "params": [
              {
                "name": "graph",
                "type_name": "Graph",
                "description": "Represented as an object that contains a collection of edges, where each edge represents a connection between two nodes in the graph."
              },
              {
                "name": "attribute",
                "type_name": "attribute",
                "description": "Used to specify the attribute of interest for finding an edge in a graph."
              },
              {
                "name": "value",
                "type_name": "object",
                "description": "Used to search for an edge in a graph based on a specific attribute."
              }
            ],
            "returns": {
              "type_name": "edge",
              "description": "An untyped reference to a graph edge that has the specified attribute equal to the provided value."
            },
            "name": "find_edge_with_attribute",
            "location": {
              "start": 41,
              "insert": 42,
              "offset": " ",
              "indent": 4,
              "comment": null
            },
            "item_type": "function",
            "length": 5,
            "docLength": null
          },
          {
            "id": "fe2cae8a-54a8-32a7-014a-24ebf3a8e0f2",
            "ancestors": [],
            "description": "Iterates over the edges in a graph and adds to an output list any edge connecting nodes with \"door\" in their names.",
            "params": [
              {
                "name": "graph",
                "type_name": "Graph",
                "description": "Represented as g, which contains a collection of nodes and edges that define a graph structure."
              }
            ],
            "returns": {
              "type_name": "list",
              "description": "A collection of edges from the given graph."
            },
            "name": "get_room_edges",
            "location": {
              "start": 47,
              "insert": 48,
              "offset": " ",
              "indent": 4,
              "comment": null
            },
            "item_type": "function",
            "length": 10,
            "docLength": null
          },
          {
            "id": "e9acd19c-513f-f78e-4949-cd353d1b9b16",
            "ancestors": [],
            "description": "In Java code recursively queries the graph for all nodes connected to a given node via doors, returning a list of such nodes.",
            "params": [
              {
                "name": "graph",
                "type_name": "Graph",
                "description": "Used to represent a graph structure."
              },
              {
                "name": "node",
                "type_name": "GraphNode",
                "description": "Referred to as a node in the graph."
              }
            ],
            "returns": {
              "type_name": "list",
              "description": "A collection of nodes that are connected to a specific node through doors."
            },
            "name": "get_connected_door_nodes",
            "location": {
              "start": 58,
              "insert": 60,
              "offset": " ",
              "indent": 4,
              "comment": null
            },
            "item_type": "function",
            "length": 10,
            "docLength": null
          },
          {
            "id": "9a2a2e72-8415-229d-6c4a-657476ccda61",
            "ancestors": [],
            "description": "Navigates through a graph by starting from a given room and visiting all other rooms reachable through doors. It keeps track of visited rooms using a list and prints information about each room it visits.",
            "params": [
              {
                "name": "graph",
                "type_name": "Graph",
                "description": "Used to represent a graph with nodes and edges."
              },
              {
                "name": "current_room",
                "type_name": "dict",
                "description": "Represents the current room to be traversed in the graph."
              },
              {
                "name": "visited",
                "type_name": "list",
                "description": "Used to keep track of the rooms that have been visited during the traversal process, initialized to an empty list if None."
              }
            ],
            "returns": {
              "type_name": "list",
              "description": "A collection of strings representing the rooms that have been visited."
            },
            "name": "traverse_graph",
            "location": {
              "start": 74,
              "insert": 75,
              "offset": " ",
              "indent": 4,
              "comment": null
            },
            "item_type": "function",
            "length": 17,
            "docLength": null
          }
        ]
      }
    }
  },
  {
    "name": "genericworker.py",
    "path": "agents/long_term_spatial_memory_agent/src/genericworker.py",
    "content": {
      "structured": {
        "description": "A worker class that inherits from QtWidgets.QWidget and implements a timer-based mechanism for killing itself after a specified period. It also provides a signal kill to allow for handling of the termination from outside the worker. The code uses PySide2, Ice, and the RoboCompCommonBehavior module.",
        "items": [
          {
            "id": "8a50128c-009f-a1ac-2c45-674f0e62438e",
            "ancestors": [],
            "description": "Manages a timer and a signal to stop its own execution. It has methods to change the timer period and to emit the signal to stop itself.",
            "attributes": [
              {
                "name": "kill",
                "type_name": "QtCoreQObjectSlot",
                "description": "Used to emit a signal that can be caught by any connected slots to stop the worker's execution."
              },
              {
                "name": "ui",
                "type_name": "Ui_guiDlg",
                "description": "Used to setup the user interface of the class."
              },
              {
                "name": "mutex",
                "type_name": "QMutex",
                "description": "Used to protect the worker's state from concurrent access."
              },
              {
                "name": "Period",
                "type_name": "int",
                "description": "Used to set the time interval for the timer signal emitted by the `setPeriod()` method, which changes its value on each call."
              },
              {
                "name": "timer",
                "type_name": "QtCoreQTimer",
                "description": "Used to start a timer that emits the `kill` signal after a specified period."
              }
            ],
            "name": "GenericWorker",
            "location": {
              "start": 43,
              "insert": 45,
              "offset": " ",
              "indent": 4,
              "comment": null
            },
            "item_type": "class",
            "length": 26,
            "docLength": null
          },
          {
            "id": "dc756aa5-ebc6-5490-d649-854bb2ac26a4",
            "ancestors": [
              "8a50128c-009f-a1ac-2c45-674f0e62438e"
            ],
            "description": "Initializes an object of the `GenericWorker` class, setting up a UI widget, creating a mutex for synchronization, and defining a timer with a period of 500 milliseconds.",
            "params": [
              {
                "name": "mprx",
                "type_name": "Ui_guiDlg",
                "description": "Used as the parent widget for the GenericWorker object's UI."
              }
            ],
            "returns": null,
            "name": "__init__",
            "location": {
              "start": 47,
              "insert": 48,
              "offset": " ",
              "indent": 8,
              "comment": null
            },
            "item_type": "method",
            "length": 9,
            "docLength": null
          },
          {
            "id": "17fccd3d-bcc7-a9a3-5f45-73125f7d1f78",
            "ancestors": [
              "8a50128c-009f-a1ac-2c45-674f0e62438e"
            ],
            "description": "Emits the `kill` signal, indicating that the object should be terminated.",
            "params": [],
            "returns": null,
            "name": "killYourSelf",
            "location": {
              "start": 60,
              "insert": 62,
              "offset": " ",
              "indent": 8,
              "comment": null
            },
            "item_type": "method",
            "length": 4,
            "docLength": null
          },
          {
            "id": "a2ebb705-7932-fb9b-3e45-f965c61ebf4d",
            "ancestors": [
              "8a50128c-009f-a1ac-2c45-674f0e62438e"
            ],
            "description": "Sets the period of a timer and updates the internal variable `Period`.",
            "params": [
              {
                "name": "p",
                "type_name": "int",
                "description": "Used to set the new period for the timer."
              }
            ],
            "returns": null,
            "name": "setPeriod",
            "location": {
              "start": 67,
              "insert": 69,
              "offset": " ",
              "indent": 8,
              "comment": null
            },
            "item_type": "method",
            "length": 5,
            "docLength": null
          }
        ]
      }
    }
  },
  {
    "name": "specificworker.py",
    "path": "agents/long_term_spatial_memory_agent/src/specificworker.py",
    "content": {
      "structured": {
        "description": "An igraph module that simulates a robot's navigation through a room using RT graph theory. It provides several functions for inserting, updating, and deleting nodes and edges in the room graph, as well as querying node and edge attributes. The code also includes logic to set the current state of the robot based on the type of edge inserted or removed from the room graph. The module uses the `igraph` package to manipulate graphs and perform graph theory operations.",
        "items": [
          {
            "id": "8012c732-b5dd-93a9-2441-d47f31f3d2fa",
            "ancestors": [],
            "description": "Manages a graph representing a manipulation task, providing methods for inserting, updating, and deleting nodes and edges. It also keeps track of the robot's current state and performs actions based on that state.",
            "attributes": [
              {
                "name": "Period",
                "type_name": "str|int",
                "description": "Used to store the period of time during which the worker performs its task, either in seconds or minutes, depending on the value assigned to it."
              },
              {
                "name": "agent_id",
                "type_name": "int|str",
                "description": "Used to store the ID of the specific worker for which the methods of this class are intended to work."
              },
              {
                "name": "g",
                "type_name": "igraphGraph",
                "description": "Used for handling long-term dependencies between nodes in the graph."
              },
              {
                "name": "startup_check",
                "type_name": "bool|str",
                "description": "Used to check if the worker has started successfully or not. It can be set to a specific value like \"success\" or \"failure\" to indicate whether the startup was successful or not, or it can be left blank to default to a boolean value indicating whether the worker started successfully or not."
              },
              {
                "name": "rt_api",
                "type_name": "str|int",
                "description": "Used to store the RT (Real-Time) API of the worker, which allows the robot to perform real-time actions."
              },
              {
                "name": "inner_api",
                "type_name": "Dict[str,Any]",
                "description": "Used to store internal APIs for the worker's methods that are not exposed to the outside world."
              },
              {
                "name": "robot_name",
                "type_name": "str|List[str]",
                "description": "Used to store the name of the robot that the worker belongs to."
              },
              {
                "name": "robot_id",
                "type_name": "int",
                "description": "Used to represent the unique identifier of the robot node in the graph."
              },
              {
                "name": "last_robot_pose",
                "type_name": "Dict[str,float]",
                "description": "Used to store the last known pose of the robot before it entered a room or crossed a boundary."
              },
              {
                "name": "robot_exit_pose",
                "type_name": "str|int",
                "description": "Used to store the ID of the room node that the robot exits through when transitioning from a door node to a room node."
              },
              {
                "name": "state",
                "type_name": "str|bool",
                "description": "Used to keep track of the worker's current state (either \"idle\", \"crossed\", or \"completed\")."
              },
              {
                "name": "affordance_node_active_id",
                "type_name": "int|bool",
                "description": "Used to store the ID of the affordance node that is currently active or not."
              },
              {
                "name": "exit_door_id",
                "type_name": "int|str",
                "description": "Used to store the ID of the door node that serves as an exit from a room."
              },
              {
                "name": "room_exit_door_id",
                "type_name": "int|str",
                "description": "16 by default, representing the id of a specific door node in the long-term graph that marks the exit of a room."
              },
              {
                "name": "enter_room_node_id",
                "type_name": "int|str",
                "description": "Represented as a room number that, when updated to a value greater than zero, indicates that the robot has entered a new room."
              },
              {
                "name": "vertex_size",
                "type_name": "int|str",
                "description": "Used to store the size or dimension of a vertex in the graph, which can be used to determine the size of a node in the graph."
              },
              {
                "name": "not_required_attrs",
                "type_name": "List[str]",
                "description": "Used to store a list of attributes that are not required for the worker's operations. It helps to optimize the worker's performance by ignoring these unused attributes during updates, inserts, or deletes."
              },
              {
                "name": "long_term_graph",
                "type_name": "igraphGraph",
                "description": "Used to store the long-term graph representation of the environment, which is updated during the worker's execution."
              },
              {
                "name": "insert_current_edge",
                "type_name": "NoneOrEdge|List[str]",
                "description": "Used to insert a new edge into the graph with the specified fr and to nodes, and sets it as the current edge if no current edge exists."
              },
              {
                "name": "timer",
                "type_name": "int|float",
                "description": "Used to track the time taken by the worker to process a task."
              },
              {
                "name": "compute",
                "type_name": "Callable[[str,str],Any]",
                "description": "Used to specify a function that computes the next action for the robot based on its current state and the environment."
              },
              {
                "name": "update_node",
                "type_name": "Dict[str,Any]",
                "description": "Used to update a node in the graph based on its ID, type (door or room), and name. It performs various actions such as checking if a door node exists, inserting a door node, updating the RT translation and rotation, and drawing the graph."
              },
              {
                "name": "update_edge",
                "type_name": "Union[str,int]",
                "description": "Used to update the edge attributes of a specific robot node in the graph when the node's door is opened."
              }
            ],
            "name": "SpecificWorker",
            "location": {
              "start": 49,
              "insert": 50,
              "offset": " ",
              "indent": 4,
              "comment": null
            },
            "item_type": "class",
            "length": 600,
            "docLength": null
          },
          {
            "id": "2420b0f0-67bd-b096-4c4c-57bbc351c392",
            "ancestors": [
              "8012c732-b5dd-93a9-2441-d47f31f3d2fa"
            ],
            "description": "Initializes instance variables and sets up event listeners for graph updates, timeouts, and node measurements.",
            "params": [
              {
                "name": "proxy_map",
                "type_name": "Dict[str, Any]",
                "description": "Used to pass additional data to the SpecificWorker object. It contains key-value pairs that can be used to store any information required by the worker."
              },
              {
                "name": "startup_check",
                "type_name": "bool",
                "description": "Used to check if the agent has already started its computation, skipping the computation if it has already been done."
              }
            ],
            "returns": null,
            "usage": {
              "language": "python",
              "code": "from SpecificWorker import SpecificWorker\n\n# Initialize a new instance of the class\nspecific_worker = SpecificWorker(proxy_map)\n",
              "description": ""
            },
            "name": "__init__",
            "location": {
              "start": 50,
              "insert": 51,
              "offset": " ",
              "indent": 8,
              "comment": null
            },
            "item_type": "constructor",
            "length": 51,
            "docLength": null
          },
          {
            "id": "3cc990dd-edc6-eaa3-e84f-526e79602e4f",
            "ancestors": [
              "8012c732-b5dd-93a9-2441-d47f31f3d2fa"
            ],
            "description": "Sets the parameters passed as an argument to `True`. Then, it removes a self-edge from the current room, stores the ID of the exit door in a variable, and sets the name attribute of both doors to the other side door's name.",
            "params": [
              {
                "name": "params",
                "type_name": "bool",
                "description": "Passed to set parameters for an object of class `Room`."
              }
            ],
            "returns": {
              "type_name": "bool",
              "description": "True."
            },
            "usage": {
              "language": "python",
              "code": "# Initialise a SpecificWorker instance and assign its parameters\nworker = SpecificWorker(proxy_map)\nparams = {\"Period\": 100, \"agent_id\": 13}\nworker.setParams(params)\n\n# Use the worker instance to perform some tasks\nworker.startup_check()\nworker.rt_api.update_node_attributes(worker.g, node_id=worker.robot_id, attr_map={\"timestamp_alivetime\": 1})\n",
              "description": "\nIn this example, we first create a new SpecificWorker instance and initialise its parameters using the setParams function. We then use the worker instance to perform some tasks such as startup_check() and updating node attributes with the rt_api object."
            },
            "name": "setParams",
            "location": {
              "start": 124,
              "insert": 125,
              "offset": " ",
              "indent": 8,
              "comment": null
            },
            "item_type": "method",
            "length": 7,
            "docLength": null
          },
          {
            "id": "d6fad876-0520-74ba-db4f-01fdb0bda8d3",
            "ancestors": [
              "8012c732-b5dd-93a9-2441-d47f31f3d2fa"
            ],
            "description": "Computes and updates the robot's RT (reactive transport) based on the current state of the graph.",
            "params": [],
            "returns": null,
            "usage": {
              "language": "python",
              "code": "import SpecificWorker\n\n# Initialize the SpecificWorker object with the proxy map and a flag for startup check\nspecific_worker = SpecificWorker(proxy_map, startup_check=True)\n\n# Call the compute method to perform the computation\nresult = specific_worker.compute()\n\n# Print the result of the computation\nprint(result)\n",
              "description": ""
            },
            "name": "compute",
            "location": {
              "start": 138,
              "insert": 141,
              "offset": " ",
              "indent": 8,
              "comment": null
            },
            "item_type": "method",
            "length": 61,
            "docLength": null
          },
          {
            "id": "8506fabb-8dc7-2aab-f04a-6f0ba0f9cc92",
            "ancestors": [
              "8012c732-b5dd-93a9-2441-d47f31f3d2fa"
            ],
            "description": "Computes the affordance pose of the robot in a new room based on its current position and orientation, and associates doors in the long-term graph with their corresponding rooms.",
            "params": [],
            "returns": null,
            "usage": {
              "language": "python",
              "code": "specific_worker = SpecificWorker(proxy_map) # Initiate a specific worker object\nspecific_worker.idle() # Call the idle method from the specific worker object\n",
              "description": ""
            },
            "name": "idle",
            "location": {
              "start": 211,
              "insert": 213,
              "offset": " ",
              "indent": 8,
              "comment": null
            },
            "item_type": "method",
            "length": 75,
            "docLength": null
          },
          {
            "id": "04e2af7d-eddb-8f8c-6743-11e3dda21651",
            "ancestors": [
              "8012c732-b5dd-93a9-2441-d47f31f3d2fa"
            ],
            "description": "Updates the state of the worker based on the active affordance node and exit door ID.",
            "params": [],
            "returns": null,
            "usage": {
              "language": "python",
              "code": "# create an instance of the SpecificWorker class\nworker = SpecificWorker(proxy_map)\n\n# set the agent's ID and robot name\nagent_id = 13\nrobot_name = \"Shadow\"\n\n# call the crossed method\nworker.crossed()\n",
              "description": "\nThe crossed function is a method of the SpecificWorker class that subclasses GenericWorker. It takes no arguments and does not return any value. The function first gets the affordance node with ID self.affordance_node_active_id from the graph g using get_node(). If this node has a parent attribute, it sets the exit door ID to the parent attribute value. If the parent attribute is empty, it returns.\nIf the exit door ID is set, the function deletes an edge between room_exit_door_id and self.room_exit_door_id using delete_edge().\nThe function then gets the exit door node with ID self.exit_door_id from the graph g using get_node(). If this node has a connected_room_name attribute, it sets the state to known_room and prints an INSERTING KNOWN ROOM message. If the exit door ID is empty, it sets the state to initializing_room and prints an INITIALIZING ROOM message.\nNote that the SpecificWorker class also has other attributes such as agent_id, g, rt_api, inner_api, robot_name, last_robot_pose, robot_exit_pose, state, affordance_node_active_id, exit_door_id, room_exit_door_id, enter_room_node_id, and vertex_size."
            },
            "name": "crossed",
            "location": {
              "start": 310,
              "insert": 312,
              "offset": " ",
              "indent": 8,
              "comment": null
            },
            "item_type": "method",
            "length": 16,
            "docLength": null
          },
          {
            "id": "789455c6-28e2-7985-854d-e4841c68865e",
            "ancestors": [
              "8012c732-b5dd-93a9-2441-d47f31f3d2fa"
            ],
            "description": "Initializes the room nodes and sets the enter room node ID, then transitions to the \"initializing doors\" state.",
            "params": [],
            "returns": null,
            "usage": {
              "language": "python",
              "code": "# Initialize the specific worker class with the proxy map and the startup check flag set to False\nspecific_worker = SpecificWorker(proxy_map, startup_check=False)\n\n# Call the initializing_room method on the specific worker instance\nspecific_worker.initializing_room()\n",
              "description": ""
            },
            "name": "initializing_room",
            "location": {
              "start": 330,
              "insert": 333,
              "offset": " ",
              "indent": 8,
              "comment": null
            },
            "item_type": "method",
            "length": 10,
            "docLength": null
          },
          {
            "id": "423155ab-cc3e-9ab0-2342-a93d7e99b214",
            "ancestors": [
              "8012c732-b5dd-93a9-2441-d47f31f3d2fa"
            ],
            "description": "Determines the room name associated with a door based on its ID and updates the graph with new edges and nodes to simulate robot movement through the door and into the adjacent room.",
            "params": [],
            "returns": null,
            "usage": {
              "language": "python",
              "code": "# Initialize a SpecificWorker object with the proxy map\nspecific_worker = SpecificWorker(proxy_map)\n\n# Call the known_room method on the specific worker object\nspecific_worker.known_room()\n",
              "description": ""
            },
            "name": "known_room",
            "location": {
              "start": 344,
              "insert": 346,
              "offset": " ",
              "indent": 8,
              "comment": null
            },
            "item_type": "method",
            "length": 73,
            "docLength": null
          },
          {
            "id": "20438ef8-46d9-6a88-2346-a153824233c9",
            "ancestors": [
              "8012c732-b5dd-93a9-2441-d47f31f3d2fa"
            ],
            "description": "1) retrieves exit edges and matching doors, 2) sets other side door name and connected room name attributes for each exit door node, and 3) associates doors using their names and connected rooms.",
            "params": [],
            "returns": null,
            "usage": {
              "language": "python",
              "code": "SpecificWorker(proxy_map).initializing_doors()\n",
              "description": "\nThis code will call the method \"initializing_doors\" of the class SpecificWorker. The method takes no arguments, and it is part of a class that inherits from GenericWorker, so we need to pass an instance of a GenericWorker to the method. In this example, we are passing proxy_map as argument."
            },
            "name": "initializing_doors",
            "location": {
              "start": 438,
              "insert": 440,
              "offset": " ",
              "indent": 8,
              "comment": null
            },
            "item_type": "method",
            "length": 28,
            "docLength": null
          },
          {
            "id": "f8912fcb-f70e-d0a1-424e-4a48496ff5f8",
            "ancestors": [
              "8012c732-b5dd-93a9-2441-d47f31f3d2fa"
            ],
            "description": "Connects two doors in a graph by adding an edge between their nodes and updates their attributes to reflect the connection.",
            "params": [
              {
                "name": "door_1",
                "type_name": "str",
                "description": "A list containing the name of the first door to be associated with the long-term graph."
              },
              {
                "name": "door_2",
                "type_name": "str",
                "description": "A name of another door in the graph, which will be connected to the current door node through an edge in the graph."
              }
            ],
            "returns": null,
            "usage": {
              "language": "python",
              "code": "worker = SpecificWorker(proxy_map)\ndoor_1 = (\"door_name\", \"connected_room_name\")\ndoor_2 = (\"other_side_door_name\", \"connected_room_name\")\nworker.associate_doors(door_1, door_2)\n",
              "description": "\nIn this example, the user is creating a new instance of the SpecificWorker class and then invoking the associate_doors method by passing in two doors (door_1 and door_2). The method will add an edge between the two nodes in the graph representing each door, as well as set the \"other_side_door_name\" and \"connected_room_name\" attributes for both nodes."
            },
            "name": "associate_doors",
            "location": {
              "start": 477,
              "insert": 479,
              "offset": " ",
              "indent": 8,
              "comment": null
            },
            "item_type": "method",
            "length": 16,
            "docLength": null
          },
          {
            "id": "a8d529d0-b6f1-f692-b541-cfd55b35f825",
            "ancestors": [
              "8012c732-b5dd-93a9-2441-d47f31f3d2fa"
            ],
            "description": "Saves the graph representation of a room to a file named \"graph.pkl\" using Python's pickle module.",
            "params": [],
            "returns": null,
            "usage": {
              "language": "python",
              "code": "# Example usage of store_graph function\nworker = SpecificWorker(proxy_map=ProxyMap(), startup_check=False)\nroom_node_id = -1  # Room node id\nworker.store_graph(room_node_id)\n",
              "description": "\nIn this example, the user creates an instance of the `SpecificWorker` class and calls the `store_graph` method with a room node ID as an argument. The function then tries to find the corresponding room node in the igraph object using the `find` method and saves it to a file if it is not found."
            },
            "name": "store_graph",
            "location": {
              "start": 496,
              "insert": 497,
              "offset": " ",
              "indent": 8,
              "comment": null
            },
            "item_type": "method",
            "length": 11,
            "docLength": null
          },
          {
            "id": "0cdf2d45-fad8-44a8-c74d-90a9b7d7fe2d",
            "ancestors": [
              "8012c732-b5dd-93a9-2441-d47f31f3d2fa"
            ],
            "description": "Removes edges from the long-term graph based on room numbers and updates the state of the worker.",
            "params": [],
            "returns": null,
            "usage": {
              "language": "python",
              "code": "# Create an instance of SpecificWorker\nspecific_worker = SpecificWorker(proxy_map)\n\n# Call the removing method with a specific node as its argument\nspecific_worker.removing(200)\n",
              "description": "\nIn this example, we create an instance of `SpecificWorker` and then call the `removing` method with a specific node as its argument. The function removes all nodes connected to the specified node by any edge with the \"RT\" type. It also removes all edges of the \"has\" type that have the specified node as their origin or destination, and deletes the specified node."
            },
            "name": "removing",
            "location": {
              "start": 510,
              "insert": 512,
              "offset": " ",
              "indent": 8,
              "comment": null
            },
            "item_type": "method",
            "length": 19,
            "docLength": null
          },
          {
            "id": "24746b75-48b7-4bb6-1b42-dbcab50aabd8",
            "ancestors": [
              "8012c732-b5dd-93a9-2441-d47f31f3d2fa"
            ],
            "description": "Traverses a graph by starting at a designated node and following RT edges to reach other nodes, inserting vertices and edges into an IGraph object as it goes.",
            "params": [
              {
                "name": "node_id",
                "type_name": "int",
                "description": "Used to represent the unique identifier for a node in the graph."
              }
            ],
            "returns": null,
            "usage": {
              "language": "python",
              "code": "# Create a SpecificWorker instance with proxy_map and startup_check arguments set to True\nspecific_worker = SpecificWorker(proxy_map, startup_check=True)\n\n# Traverse the graph starting from the robot node\nspecific_worker.traverse_graph(\"Robot\")\n",
              "description": "\nThis example uses the traverse_graph function of the SpecificWorker class to traverse a graph starting from the \"Robot\" node."
            },
            "name": "traverse_graph",
            "location": {
              "start": 536,
              "insert": 538,
              "offset": " ",
              "indent": 8,
              "comment": null
            },
            "item_type": "method",
            "length": 7,
            "docLength": null
          },
          {
            "id": "500a6fa2-405e-aa91-9540-a1c44ea71e8e",
            "ancestors": [
              "8012c732-b5dd-93a9-2441-d47f31f3d2fa"
            ],
            "description": "Traverses the graph by visiting all vertices that have successors in the long-term graph, and for each such vertex, it checks if its successor has a higher level than the current vertex, and if so, it inserts a DSR vertex and edge between them, and recursively traverses the successor.",
            "params": [
              {
                "name": "node",
                "type_name": "igraph.Vertex",
                "description": "Used to represent the current node being traversed."
              }
            ],
            "returns": null,
            "usage": {
              "language": "python",
              "code": "graph = SpecificWorker(proxy_map)\nstarting_node = graph.g.get_node(\"MyStartingNode\")\ngraph.traverse_igraph(starting_node)\n",
              "description": "\nThe code creates an instance of the SpecificWorker class and passes a proxy map object to the constructor. Then, it retrieves a starting node from the graph using the g.get_node method and uses this node as the argument for the traverse_igraph function. The function then recursively traverses the graph, inserting DSR vertices and edges based on the condition in the if statement."
            },
            "name": "traverse_igraph",
            "location": {
              "start": 546,
              "insert": 547,
              "offset": " ",
              "indent": 8,
              "comment": null
            },
            "item_type": "method",
            "length": 10,
            "docLength": null
          },
          {
            "id": "60d7e0f3-5642-a39a-4e40-66246d4c4948",
            "ancestors": [
              "8012c732-b5dd-93a9-2441-d47f31f3d2fa"
            ],
            "description": "Adds a new vertex to an existing graph, updating its attributes and edges based on node-specific data.",
            "params": [
              {
                "name": "node",
                "type_name": "igraph.Node",
                "description": "Used to insert a new vertex into the graph."
              }
            ],
            "returns": null,
            "usage": {
              "language": "python",
              "code": "# create a new instance of the SpecificWorker class and pass in proxy_map as argument\nspecific_worker = SpecificWorker(proxy_map)\n\n# add a vertex to the long term graph with the name \"MyVertex\"\nspecific_worker.insert_igraph_vertex(\"MyVertex\")\n",
              "description": "\nIn this example, we first create a new instance of the SpecificWorker class and pass in proxy_map as an argument. We then use the insert_igraph_vertex function to add a vertex with the name \"MyVertex\" to the long term graph."
            },
            "name": "insert_igraph_vertex",
            "location": {
              "start": 559,
              "insert": 560,
              "offset": " ",
              "indent": 8,
              "comment": null
            },
            "item_type": "method",
            "length": 29,
            "docLength": null
          },
          {
            "id": "7467a4df-2da4-a89d-dc40-8d0db7be370f",
            "ancestors": [
              "8012c732-b5dd-93a9-2441-d47f31f3d2fa"
            ],
            "description": "Inserts a new node into a graph, updating the parent node's attribute with the agent ID and copying over non-required attributes from the input node to the new node.",
            "params": [
              {
                "name": "parent_name",
                "type_name": "str",
                "description": "Used to specify the name of the parent node to which the new node will be added."
              },
              {
                "name": "node",
                "type_name": "Node | dict",
                "description": "Passed the attributes and data of a vertex to be inserted into a graph."
              }
            ],
            "returns": null,
            "usage": {
              "language": "python",
              "code": "# Create a new instance of SpecificWorker class and call its constructor\nmy_worker = SpecificWorker(proxy_map)\n\n# Use the worker to add a vertex to the graph\nmy_worker.insert_dsr_vertex(\"parent_node\", {\"type\": \"room\", \"name\": \"Living Room\"})\n",
              "description": ""
            },
            "name": "insert_dsr_vertex",
            "location": {
              "start": 594,
              "insert": 596,
              "offset": " ",
              "indent": 8,
              "comment": null
            },
            "item_type": "method",
            "length": 9,
            "docLength": null
          },
          {
            "id": "ac75a866-f308-2a90-484f-864828cce9c4",
            "ancestors": [
              "8012c732-b5dd-93a9-2441-d47f31f3d2fa"
            ],
            "description": "Adds an edge to a long-term graph based on a given edge attribute, updating the node positions and rotation accordingly.",
            "params": [
              {
                "name": "edge",
                "type_name": "rt.Edge",
                "description": "Passed by reference to the method, representing an edge with attributes such as translation and rotation."
              }
            ],
            "returns": null,
            "usage": {
              "language": "python",
              "code": "# Create an instance of SpecificWorker\nmy_worker = SpecificWorker()\n\n# Create an edge object with attributes \"origin\" and \"destination\"\nedge = Edge(origin=\"node1\", destination=\"node2\")\n\n# Call the insert_igraph_edge method on my_worker with the edge as an argument\nmy_worker.insert_igraph_edge(edge)\n",
              "description": "\nIn this example, an instance of SpecificWorker is created and an Edge object is created with attributes \"origin\" and \"destination\". The insert_igraph_edge method of SpecificWorker is then called with the Edge object as an argument, which adds a new edge to the graph."
            },
            "name": "insert_igraph_edge",
            "location": {
              "start": 608,
              "insert": 609,
              "offset": " ",
              "indent": 8,
              "comment": null
            },
            "item_type": "method",
            "length": 12,
            "docLength": null
          },
          {
            "id": "35a1d65c-21d4-f7be-c446-071ce717b9a2",
            "ancestors": [
              "8012c732-b5dd-93a9-2441-d47f31f3d2fa"
            ],
            "description": "Modifies an existing graph by adding an edge with specific RT attributes, based on input org and dest nodes.",
            "params": [
              {
                "name": "org",
                "type_name": "GraphNode | NoneType",
                "description": "Used to represent the origin node of the edge to be inserted. If it is None, the function will use the root node as the origin."
              },
              {
                "name": "dest",
                "type_name": "Node | str",
                "description": "Used to specify the destination node or name in the graph for insertion of an edge."
              }
            ],
            "returns": null,
            "usage": {
              "language": "python",
              "code": "worker = SpecificWorker(proxy_map)\n# Create a new edge between two nodes in the graph\nworker.insert_dsr_edge(\"node1\", \"node2\")\n",
              "description": "\nIn this example, the insert_dsr_edge function is called on an instance of the SpecificWorker class (which inherits from GenericWorker). The function takes in two arguments: org and dest. Org represents the origin node of the edge, and dest represents the destination node. The function first checks if org is None. If it is not None, then it retrieves the edge ID between org and dest using g.get_eid() and retrieves the attributes of the edge using g.es[edge_id]. It then creates a new Edge object with the destination node ID as its origin, the origin node ID as its destination, and an RT attribute with a value of 0 (as this is not a realistic use case). It then assigns the RT translation and rotation attributes to the new edge using new_edge.attrs[\"rt_translation\"] = Attribute(np.array([0, 0, 0], dtype=np.float32), self.agent_id) and new_edge.attrs[\"rt_rotation_euler_xyz\"] = Attribute(np.array([0, 0, 0], dtype=np.float32), self.agent_id). Finally, it inserts the new edge into the graph using g.insert_or_assign_edge()."
            },
            "name": "insert_dsr_edge",
            "location": {
              "start": 625,
              "insert": 628,
              "offset": " ",
              "indent": 8,
              "comment": null
            },
            "item_type": "method",
            "length": 22,
            "docLength": null
          },
          {
            "id": "d927aae0-9021-6196-9b41-95f639864b45",
            "ancestors": [
              "8012c732-b5dd-93a9-2441-d47f31f3d2fa"
            ],
            "description": "Determines the room number of an element by retrieving the attribute 'room_id' from the element's node ID.",
            "params": [
              {
                "name": "node_id",
                "type_name": "str",
                "description": "Used to reference a node in the graph."
              }
            ],
            "returns": {
              "type_name": "int",
              "description": "The room ID associated with a given node ID."
            },
            "usage": {
              "language": "python",
              "code": "# Initialize the SpecificWorker class and its attributes\nspecific_worker = SpecificWorker()\n\n# Get the room number of a node with ID \"my_node\"\nroom_id = specific_worker.check_element_room_number(\"my_node\")\nprint(f\"The room number of node 'my_node' is {room_id}\")\n",
              "description": ""
            },
            "name": "check_element_room_number",
            "location": {
              "start": 655,
              "insert": 656,
              "offset": " ",
              "indent": 8,
              "comment": null
            },
            "item_type": "method",
            "length": 7,
            "docLength": null
          },
          {
            "id": "5ce9e553-2b0d-88b8-bf49-7882013c2d15",
            "ancestors": [
              "8012c732-b5dd-93a9-2441-d47f31f3d2fa"
            ],
            "description": "Determines the element level of a node based on its attribute \"level\" and returns it if found, or -1 otherwise.",
            "params": [
              {
                "name": "node_id",
                "type_name": "int",
                "description": "Represented by the identifier `node_id`. It serves as an index into the graph's node list to access the specified node."
              }
            ],
            "returns": {
              "type_name": "int",
              "description": "Element level of the node with given id"
            },
            "usage": {
              "language": "python",
              "code": "# Import SpecificWorker class from GenericWorker module\nfrom GenericWorker import SpecificWorker\n\n# Initialize a new SpecificWorker object\nmy_specific_worker = SpecificWorker(\"proxy_map\")\n\n# Call the check_element_level method with the desired node ID as an argument\nelement_level = my_specific_worker.check_element_level(1234)\n\n# Print the element level value to the console\nprint(f\"Element level of node 1234 is {element_level}\")\n",
              "description": ""
            },
            "name": "check_element_level",
            "location": {
              "start": 664,
              "insert": 665,
              "offset": " ",
              "indent": 8,
              "comment": null
            },
            "item_type": "method",
            "length": 25,
            "docLength": null
          },
          {
            "id": "ca797b1f-3a72-7887-b54c-bcac0d9c7872",
            "ancestors": [
              "8012c732-b5dd-93a9-2441-d47f31f3d2fa"
            ],
            "description": "1) retrieves room information from the graph, 2) identifies RT edges connecting to the current room, and 3) extracts translation attribute for the current room.",
            "params": [
              {
                "name": "room_node_id",
                "type_name": "str | int",
                "description": "Required, indicating that it is mandatory to pass this value for the function to work correctly."
              }
            ],
            "returns": null,
            "usage": {
              "language": "python",
              "code": "# Creating a specific worker object\nspecific_worker = SpecificWorker(proxy_map)\n\n# Generating a room picture for a specific room node id\nspecific_worker.generate_room_picture(123456789)\n\n# Saving the image to a file\ncv2.imwrite(\"room_image.jpg\", specific_worker.room_image)\n",
              "description": ""
            },
            "name": "generate_room_picture",
            "location": {
              "start": 707,
              "insert": 709,
              "offset": " ",
              "indent": 8,
              "comment": null
            },
            "item_type": "method",
            "length": 24,
            "docLength": null
          },
          {
            "id": "9d6cc73f-8cb4-e89e-7945-94e9bd98c8ac",
            "ancestors": [
              "8012c732-b5dd-93a9-2441-d47f31f3d2fa"
            ],
            "description": "Inserts or assigns an edge in the graph representing the room hierarchy, with the current worker's ID as the source and the current room ID as the target.",
            "params": [
              {
                "name": "room_id",
                "type_name": "str",
                "description": "Used as an identifier for the current room that the agent is located in."
              }
            ],
            "returns": null,
            "usage": {
              "language": "python",
              "code": "def insert_current_edge(self, room_id):\n        current_edge = Edge(room_id, room_id, \"current\", self.agent_id)\n        self.g.insert_or_assign_edge(current_edge)\n",
              "description": "\nIn this example, the SpecificWorker class is used to insert an edge into a graph representing a LongTermSpatialMemory with the robot's current location represented by room_id. The function first creates an Edge object with the same room_id as the target and source node ids. Then, it inserts or assigns the created edge into the graph using the insert_or_assign_edge() method of the DSRGraph class."
            },
            "name": "insert_current_edge",
            "location": {
              "start": 742,
              "insert": 744,
              "offset": " ",
              "indent": 8,
              "comment": null
            },
            "item_type": "method",
            "length": 3,
            "docLength": null
          },
          {
            "id": "339e852e-5da6-aa92-6146-a2388fe634c4",
            "ancestors": [
              "8012c732-b5dd-93a9-2441-d47f31f3d2fa"
            ],
            "description": "Updates a node in the graph based on its ID and type. If the type is \"door\", it inserts a vertex in the long-term graph, checks if a room node exists, and inserts an edge with a specific translation and rotation. If the ID is the affordance node active ID, it checks the state and activeness of the node and transitions to the crossed state.",
            "params": [
              {
                "name": "id",
                "type_name": "int",
                "description": "Used to identify the node being updated."
              },
              {
                "name": "type",
                "type_name": "str",
                "description": "Used to identify the node being updated, with possible values of \"door\" or \"room\"."
              }
            ],
            "returns": null,
            "usage": {
              "language": "python",
              "code": "# Create a specific worker object and initialize it with the startup check flag set to True\nspecific_worker = SpecificWorker(proxy_map, startup_check=True)\n\n# Call the update_node method of the specific worker object with the node ID and type as arguments\nspecific_worker.update_node(1234567890, \"door\")\n",
              "description": "\nThis code creates a SpecificWorker object and initializes it with the startup check flag set to True. Then it calls the update_node method of the specific worker object with the node ID 1234567890 and type \"door\" as arguments. The function would then check if there is an igraph vertex for the door node, insert it if necessary, and then check if there are any edges between the parent node and the door node in the long-term graph, inserting them if necessary and drawing the updated graph."
            },
            "name": "update_node",
            "location": {
              "start": 756,
              "insert": 757,
              "offset": " ",
              "indent": 8,
              "comment": null
            },
            "item_type": "method",
            "length": 41,
            "docLength": null
          },
          {
            "id": "2abe3cea-a1da-b5bc-224c-fb099b8b8257",
            "ancestors": [
              "8012c732-b5dd-93a9-2441-d47f31f3d2fa"
            ],
            "description": "Updates the current edge based on the specified frame, to node, and type. If no current edge exists, it inserts a new edge and sets it as the current one.",
            "params": [
              {
                "name": "fr",
                "type_name": "int",
                "description": "Representative of the 'from' node value, which indicates the starting point of an edge"
              },
              {
                "name": "to",
                "type_name": "int",
                "description": "The target node ID of an edge to be updated."
              },
              {
                "name": "type",
                "type_name": "str",
                "description": "Used to specify the type of edge being updated, either \"RT\" for real-time or \"NRT\" for non-real-time."
              }
            ],
            "returns": null,
            "usage": {
              "language": "python",
              "code": "worker = SpecificWorker(proxy_map)\n# Initialize the worker with the given proxy map and startup check set to False.\n\nworker.update_edge(fr=10, to=20, type=\"RT\")\n# Update the edge connecting nodes 10 and 20 with type \"RT\".\n",
              "description": ""
            },
            "name": "update_edge",
            "location": {
              "start": 811,
              "insert": 815,
              "offset": " ",
              "indent": 8,
              "comment": null
            },
            "item_type": "method",
            "length": 5,
            "docLength": null
          }
        ]
      }
    }
  },
  {
    "name": "specificworker_sec.py",
    "path": "agents/long_term_spatial_memory_agent/src/specificworker_sec.py",
    "content": {
      "structured": {
        "description": "An igraph object `self` and implements various operations on a graph, including inserting nodes and edges, updating edge attributes, and deleting nodes and edges. The code uses the `igraph` package to perform these operations. Specifically, it inserts a node in the graph with a certain name and ID, updates the RT translation and rotation of an edge connecting two nodes, and deletes a node and edge from the graph. Additionally, it checks if an affordance node is active and sets the state to \"crossed\" if it is completed and not active.",
        "items": [
          {
            "id": "75233bfc-d379-5786-3e4d-6b16aa1599c4",
            "ancestors": [],
            "description": "Manages a graph representation of a robot navigating through a room, handling various actions such as inserting, updating, and deleting nodes and edges, as well as tracking the current state of the room.",
            "attributes": [
              {
                "name": "Period",
                "type_name": "Union[float,int]",
                "description": "Used to represent the time period for which the worker is active."
              },
              {
                "name": "agent_id",
                "type_name": "int|str",
                "description": "Used to store the unique identifier of the agent in the simulation."
              },
              {
                "name": "g",
                "type_name": "igraphGraph",
                "description": "Used to represent the graph of nodes and edges in the environment. It is used for various operations such as inserting, deleting, updating nodes and edges, and drawing the graph."
              },
              {
                "name": "update_node",
                "type_name": "Dict[str,Any]",
                "description": "Used to update the node attributes of a specific node in the graph based on its ID. It takes two arguments: `id` (int) which is the ID of the node to be updated, and `type` (str) which can be either \"door\" or \"room\" indicating whether the node is a door or room node. The function performs different actions depending on the type of node being updated."
              },
              {
                "name": "update_edge",
                "type_name": "Union[int,str]",
                "description": "Used to update the edge attributes of a robot-room pair based on certain conditions, such as when there is no current edge and the room node exists."
              },
              {
                "name": "startup_check",
                "type_name": "bool|str",
                "description": "Used to check if the worker should perform startup tasks such as inserting a node and edge for a room and robot, and setting the state to \"crossed\"."
              },
              {
                "name": "rt_api",
                "type_name": "str|int",
                "description": "Used to store the ID of the robot that the worker is associated with, allowing the worker to perform RT-based actions."
              },
              {
                "name": "inner_api",
                "type_name": "Dict[str,Any]",
                "description": "Used to store additional APIs that are specific to this worker."
              },
              {
                "name": "robot_name",
                "type_name": "str|int",
                "description": "Used to store the ID of the robot that the worker is associated with."
              },
              {
                "name": "robot_id",
                "type_name": "int",
                "description": "Used to identify the robot that the worker is controlling."
              },
              {
                "name": "last_robot_pose",
                "type_name": "Tuple[float,float,float]",
                "description": "Used to store the last known pose of the robot in the environment, which can be used for various tasks such as path planning and obstacle avoidance."
              },
              {
                "name": "robot_exit_pose",
                "type_name": "str|int",
                "description": "Used to store the exit pose of a robot, which is the position and orientation of the robot when it exits a room."
              },
              {
                "name": "state",
                "type_name": "str|int",
                "description": "Used to keep track of the worker's current state (either \"idle\", \"crossed\", or \"completed\")."
              },
              {
                "name": "affordance_node_active_id",
                "type_name": "int|bool",
                "description": "Used to keep track of the active affordance node ID in the graph. It is used to determine when the affordance node has been completed and can transition to the crossed state."
              },
              {
                "name": "exit_door_id",
                "type_name": "int|str",
                "description": "Used to keep track of the id of the door node that leads from a room to the outside world, which is used for various purposes such as routing, affordance detection, and edge insertion."
              },
              {
                "name": "room_exit_door_id",
                "type_name": "int|str",
                "description": "Used to represent the ID of the door node that marks the exit of a room in the graph. It is used for updating edges and inserting current edges."
              },
              {
                "name": "enter_room_node_id",
                "type_name": "int|str",
                "description": "Used to store the ID of the room node that the worker enters when it completes its task."
              },
              {
                "name": "vertex_size",
                "type_name": "float|int",
                "description": "Used to control the size of the vertices in the graph. It determines the width or height of each vertex in the graph, which can be useful for visualization purposes."
              },
              {
                "name": "not_required_attrs",
                "type_name": "List[str]",
                "description": "Used to store a list of attribute names that are not required for the worker's functionality, i.e., they are optional or non-essential attributes."
              },
              {
                "name": "long_term_graph",
                "type_name": "igraphGraph",
                "description": "Used to store the long-term graph of the environment, which can be different from the short-term graph represented by the `g` attribute."
              },
              {
                "name": "graph",
                "type_name": "igraphGraph",
                "description": "Used to store the current state of the graph, which can be updated and manipulated during the execution of the worker's methods."
              },
              {
                "name": "insert_current_edge",
                "type_name": "List[Edge]",
                "description": "Used to insert a new edge into the graph with the specified from and to nodes, and with the \"current\" type."
              },
              {
                "name": "timer",
                "type_name": "int|str",
                "description": "Used to store a timer for the worker, indicating how long it has been running."
              },
              {
                "name": "compute",
                "type_name": "str|int",
                "description": "Used to store the ID of the node that should be updated or inserted in the graph during computation."
              }
            ],
            "name": "SpecificWorker",
            "location": {
              "start": 49,
              "insert": 50,
              "offset": " ",
              "indent": 4,
              "comment": null
            },
            "item_type": "class",
            "length": 592,
            "docLength": null
          },
          {
            "id": "1652a875-3a7c-04b8-3944-add50b4df62e",
            "ancestors": [
              "75233bfc-d379-5786-3e4d-6b16aa1599c4"
            ],
            "description": "Initializes the worker's internal state, including its graph, node ID, and affordance node active ID. It also connects signals for updating nodes and edges and sets up a timer to call the `compute` method periodically.",
            "params": [
              {
                "name": "proxy_map",
                "type_name": "Dict[str, Any]",
                "description": "Used to store a map of proxy nodes for the specific worker."
              },
              {
                "name": "startup_check",
                "type_name": "bool",
                "description": "Used to check if the graph has already been initialized before creating its inner API. It is set to False by default, meaning no check is performed."
              }
            ],
            "returns": null,
            "usage": {
              "language": "python",
              "code": "# create an instance of SpecificWorker class\nspecific_worker = SpecificWorker(proxy_map, startup_check=False)\n\n# call the function to initialize the worker\nspecific_worker.__init__(proxy_map, startup_check=False)\n",
              "description": "\nIn this example, we create an instance of the `SpecificWorker` class and then call its `__init__` method with the required parameters. The `__init__` method initializes the worker by setting up the necessary connections to the Signals module, creating a new graph if it does not exist, and starting the timer for the computation."
            },
            "name": "__init__",
            "location": {
              "start": 50,
              "insert": 51,
              "offset": " ",
              "indent": 8,
              "comment": null
            },
            "item_type": "constructor",
            "length": 53,
            "docLength": null
          },
          {
            "id": "9e3a3660-ca76-efa0-424c-7384a6dfdac5",
            "ancestors": [
              "75233bfc-d379-5786-3e4d-6b16aa1599c4"
            ],
            "description": "Sets the parameters passed as an argument, then modifies the room by removing a self-edge and adding attributes to doors.",
            "params": [
              {
                "name": "params",
                "type_name": "bool",
                "description": "Passed to set the parameters of the Room object."
              }
            ],
            "returns": {
              "type_name": "bool",
              "description": "True."
            },
            "usage": {
              "language": "python",
              "code": "worker = SpecificWorker(proxy_map)\nworker.setParams({'Period': 50})\n",
              "description": "\nIn this example, we create a new instance of the SpecificWorker class and pass in a proxy map as an argument to its constructor. We then use the setParams method to update the Period attribute of the worker instance to 50."
            },
            "name": "setParams",
            "location": {
              "start": 124,
              "insert": 125,
              "offset": " ",
              "indent": 8,
              "comment": null
            },
            "item_type": "method",
            "length": 7,
            "docLength": null
          },
          {
            "id": "13115bf5-e637-5cb7-b343-250c1fd6afbf",
            "ancestors": [
              "75233bfc-d379-5786-3e4d-6b16aa1599c4"
            ],
            "description": "Computes the RT of a robot in a graph, taking into account the current edges and long-term graph information.",
            "params": [],
            "returns": null,
            "usage": {
              "language": "python",
              "code": "worker = SpecificWorker(proxy_map)\nworker.compute()\n",
              "description": "\nIn this example, the user creates an instance of the class SpecificWorker and calls its compute method to execute the code inside it."
            },
            "name": "compute",
            "location": {
              "start": 138,
              "insert": 141,
              "offset": " ",
              "indent": 8,
              "comment": null
            },
            "item_type": "method",
            "length": 37,
            "docLength": null
          },
          {
            "id": "592108b6-327e-ba98-1c49-e5b2b4fb8c1f",
            "ancestors": [
              "75233bfc-d379-5786-3e4d-6b16aa1599c4"
            ],
            "description": "Checks if there are any \"current\" edges or affordance nodes in the graph, and performs actions based on their existence.",
            "params": [],
            "returns": null,
            "usage": {
              "language": "python",
              "code": "# Creating an instance of the SpecificWorker class\nmy_worker = SpecificWorker(proxy_map=None, startup_check=False)\n\n# Calling the idle method with a loop that lasts for 10 seconds\nfor i in range(int(10000 / my_worker.Period)):\n    my_worker.idle()\n",
              "description": ""
            },
            "name": "idle",
            "location": {
              "start": 182,
              "insert": 184,
              "offset": " ",
              "indent": 8,
              "comment": null
            },
            "item_type": "method",
            "length": 76,
            "docLength": null
          },
          {
            "id": "6aed26f6-3473-6faa-7643-8146c8044dbe",
            "ancestors": [
              "75233bfc-d379-5786-3e4d-6b16aa1599c4"
            ],
            "description": "Determines the current room and updates the state of the worker based on whether it is a known or unknown room.",
            "params": [],
            "returns": null,
            "usage": {
              "language": "python",
              "code": "worker = SpecificWorker(proxy_map)\naffordance_node = worker.g.get_node(affordance_id)\nif affordance_node.attrs[\"parent\"].value:\n    exit_door_id = affordance_node.attrs[\"parent\"].value\n    if exit_door_id:\n        exit_door_id_node = worker.g.get_node(exit_door_id)\n        if exit_door_id_node.attrs[\"connected_room_name\"].value:\n            worker.state = \"known_room\"\n",
              "description": ""
            },
            "name": "crossed",
            "location": {
              "start": 283,
              "insert": 285,
              "offset": " ",
              "indent": 8,
              "comment": null
            },
            "item_type": "method",
            "length": 16,
            "docLength": null
          },
          {
            "id": "ab648f62-f59a-0696-1b4f-b5b4de68bc91",
            "ancestors": [
              "75233bfc-d379-5786-3e4d-6b16aa1599c4"
            ],
            "description": "Initializes the room nodes in the graph, identifying and selecting the entrance node based on the exit door ID, and setting the current state to \"initializing doors\".",
            "params": [],
            "returns": null,
            "usage": {
              "language": "python",
              "code": "# Initiate SpecificWorker class\nworker = SpecificWorker(proxy_map, startup_check=False)\n\n# Run initializing_room method\nworker.initializing_room()\n\n# Do something with the result of initializing_room\nprint(\"Room initialized.\")\n",
              "description": ""
            },
            "name": "initializing_room",
            "location": {
              "start": 303,
              "insert": 306,
              "offset": " ",
              "indent": 8,
              "comment": null
            },
            "item_type": "method",
            "length": 10,
            "docLength": null
          },
          {
            "id": "c91dcd80-22ac-4a9b-be40-5caba44d2d63",
            "ancestors": [
              "75233bfc-d379-5786-3e4d-6b16aa1599c4"
            ],
            "description": "Determines the room the robot is currently in, based on the global map and the robot's position, and updates the graph with the appropriate edges and nodes.",
            "params": [],
            "returns": null,
            "usage": {
              "language": "python",
              "code": "import SpecificWorker\n\n# Create a proxy object for the worker\nworker = SpecificWorker.SpecificWorker()\n\n# Set the agent ID for which to perform the task\nagent_id = 13\n\n# Run the function known_room and pass in the agent ID as an argument\nknown_room_output = worker.known_room(agent_id)\n\n# Print the output of the function\nprint(\"Known room:\", known_room_output)\n",
              "description": ""
            },
            "name": "known_room",
            "location": {
              "start": 317,
              "insert": 319,
              "offset": " ",
              "indent": 8,
              "comment": null
            },
            "item_type": "method",
            "length": 73,
            "docLength": null
          },
          {
            "id": "e7db7e8c-ed5d-4192-e74c-af8b90f950ea",
            "ancestors": [
              "75233bfc-d379-5786-3e4d-6b16aa1599c4"
            ],
            "description": "1) identifies exit edges in the graph, 2) finds matching doors, and 3) associates them to create a connected room hierarchy.",
            "params": [],
            "returns": null,
            "usage": {
              "language": "python",
              "code": "# Assume that \"worker\" is an instance of SpecificWorker class\nworker.initializing_doors()\n",
              "description": "\nIn this example, the initializing_doors method is called on the worker object, which is an instance of the SpecificWorker class. The method then performs various actions such as setting up signals and connecting to a runtime API."
            },
            "name": "initializing_doors",
            "location": {
              "start": 411,
              "insert": 413,
              "offset": " ",
              "indent": 8,
              "comment": null
            },
            "item_type": "method",
            "length": 28,
            "docLength": null
          },
          {
            "id": "5cad0a52-9edf-779c-ab40-f409873f2c7f",
            "ancestors": [
              "75233bfc-d379-5786-3e4d-6b16aa1599c4"
            ],
            "description": "Connects two doors in a graph by adding an edge between them and setting their \"other side door name\" and \"connected room name\" attributes.",
            "params": [
              {
                "name": "door_1",
                "type_name": "str",
                "description": "A string representing the name of the first door to be associated with another door."
              },
              {
                "name": "door_2",
                "type_name": "str | int",
                "description": "Used to represent the name of the second door that needs to be associated with the first door."
              }
            ],
            "returns": null,
            "usage": {
              "language": "python",
              "code": "from igraph import Graph\n\n# Create a graph with two nodes and two edges\ng = Graph()\ng.add_vertices([\"A\", \"B\"])\ng.add_edges([(\"A\", \"B\")])\n\n# Use the associate_doors function to add a door between nodes A and B\nspecific_worker = SpecificWorker(proxy_map)\nspecific_worker.associate_doors(door_1=[\"A\", \"C\"], door_2=[\"B\", \"D\"])\n\n# Print the graph\nprint(g)\n",
              "description": "\nIn this example, we first create a graph with two nodes and one edge using the `add_vertices` and `add_edges` methods. Then, we create an instance of the `SpecificWorker` class and use the `associate_doors` method to add a door between nodes A and B. Finally, we print the graph to show that the door has been added correctly."
            },
            "name": "associate_doors",
            "location": {
              "start": 450,
              "insert": 452,
              "offset": " ",
              "indent": 8,
              "comment": null
            },
            "item_type": "method",
            "length": 16,
            "docLength": null
          },
          {
            "id": "a9f2c249-039d-49a4-e240-853633ecd2f4",
            "ancestors": [
              "75233bfc-d379-5786-3e4d-6b16aa1599c4"
            ],
            "description": "Saves the graph data to a file using pickling.",
            "params": [],
            "returns": null,
            "usage": {
              "language": "python",
              "code": "worker = SpecificWorker(proxy_map, startup_check=True)\nworker.store_graph()\n",
              "description": ""
            },
            "name": "store_graph",
            "location": {
              "start": 469,
              "insert": 470,
              "offset": " ",
              "indent": 8,
              "comment": null
            },
            "item_type": "method",
            "length": 11,
            "docLength": null
          },
          {
            "id": "12a2bcfa-ba36-7bb3-404e-aa001af8fb4c",
            "ancestors": [
              "75233bfc-d379-5786-3e4d-6b16aa1599c4"
            ],
            "description": "Removes edges from the long-term graph that have been labeled as RT or has, based on room numbers. It also deletes nodes in the graph that correspond to shadow nodes.",
            "params": [],
            "returns": null,
            "usage": {
              "language": "python",
              "code": "# Initialize the SpecificWorker class and its associated objects\nsw = SpecificWorker(proxy_map, startup_check=False)\n\n# Define a robot name\nrobot_name = \"Shadow\"\n\n# Call the removing method on the initialized SpecificWorker object\nsw.removing(robot_name)\n",
              "description": ""
            },
            "name": "removing",
            "location": {
              "start": 483,
              "insert": 485,
              "offset": " ",
              "indent": 8,
              "comment": null
            },
            "item_type": "method",
            "length": 19,
            "docLength": null
          },
          {
            "id": "c94afa2d-08b0-cc91-8a47-bf999d91cbf5",
            "ancestors": [
              "75233bfc-d379-5786-3e4d-6b16aa1599c4"
            ],
            "description": "Traverses a directed graph represented by an igraph object, starting from a given node ID. It recursively visits all reachable nodes and inserts edges from the root node to each visited node.",
            "params": [
              {
                "name": "node_id",
                "type_name": "int",
                "description": "Representing the unique identifier of a node in the graph to be traversed."
              }
            ],
            "returns": null,
            "usage": {
              "language": "python",
              "code": "# Creating an instance of SpecificWorker class\nmy_worker = SpecificWorker(proxy_map, startup_check=True)\n\n# Traversing the graph starting from the robot's node\nmy_worker.traverse_graph(my_worker.robot_id)\n\n# Printing the traversed nodes and edges\nfor node in my_worker.g.nodes:\n    print(node.id, node.label)\nfor edge in my_worker.g.edges:\n    print(edge.origin, edge.destination)\n",
              "description": ""
            },
            "name": "traverse_graph",
            "location": {
              "start": 509,
              "insert": 511,
              "offset": " ",
              "indent": 8,
              "comment": null
            },
            "item_type": "method",
            "length": 7,
            "docLength": null
          },
          {
            "id": "8a30575b-5e73-bbab-b148-8adc360d99a5",
            "ancestors": [
              "75233bfc-d379-5786-3e4d-6b16aa1599c4"
            ],
            "description": "Iterates through the graph's successors of a given vertex, and for each successor, it checks if the successor's level is higher than the current vertex's level, and if so, it inserts a new vertex and edge in the DSR and recursively traverses the graph.",
            "params": [
              {
                "name": "node",
                "type_name": "igraph.Vertex",
                "description": "Used to represent a specific vertex in the graph."
              }
            ],
            "returns": null,
            "usage": {
              "language": "python",
              "code": "# Example usage of traverse_igraph()\ng = DSRGraph(0, \"LongTermSpatialMemory_agent\", 13)\nnode = g.get_node(\"My_Node\")\ntraverse_igraph(g, node)\n",
              "description": "\nThis code creates an instance of the class GenericWorker and a graph object named g. It also gets a node from the graph using its name \"My_Node\". Then it calls traverse_igraph() with g as an argument and the node as an argument, which initiates the recursive traversal through the graph starting at the given node."
            },
            "name": "traverse_igraph",
            "location": {
              "start": 519,
              "insert": 520,
              "offset": " ",
              "indent": 8,
              "comment": null
            },
            "item_type": "method",
            "length": 10,
            "docLength": null
          },
          {
            "id": "74851935-7e42-4080-e848-40c81557fc8b",
            "ancestors": [
              "75233bfc-d379-5786-3e4d-6b16aa1599c4"
            ],
            "description": "Adds a vertex to an igraph graph, based on attributes provided by a node object. It also tries to find matching vertices using specific attribute values and adds edges between them if found.",
            "params": [
              {
                "name": "node",
                "type_name": "igraph.Node | dict",
                "description": "Used to add a new vertex to an igraph graph with specified attributes."
              }
            ],
            "returns": null,
            "usage": {
              "language": "python",
              "code": "from GenericWorker import SpecificWorker\n\n# create a new worker instance with proxy_map and startup_check=False\nworker = SpecificWorker(proxy_map, startup_check=False)\n\n# add a vertex to the graph with name='node1', id=2, type='room'\nworker.insert_igraph_vertex(node=SpecificWorkerNode(name='node1', id=2, type='room'))\n\n# add another vertex to the graph with name='node2', id=3, type='room'\nworker.insert_igraph_vertex(node=SpecificWorkerNode(name='node2', id=3, type='room'))\n\n# add an edge between the two vertices\nworker.insert_igraph_edge(origin_node=worker.graph.vs[1], other_side_door_node=worker.graph.vs[2])\n",
              "description": ""
            },
            "name": "insert_igraph_vertex",
            "location": {
              "start": 532,
              "insert": 533,
              "offset": " ",
              "indent": 8,
              "comment": null
            },
            "item_type": "method",
            "length": 28,
            "docLength": null
          },
          {
            "id": "6fb56577-9138-aab8-2145-b8d6dbfab0f8",
            "ancestors": [
              "75233bfc-d379-5786-3e4d-6b16aa1599c4"
            ],
            "description": "Inserts a new vertex into a graph, updating the parent node's attribute with the worker's ID and copying over non-optional attributes from the input node to the new vertex.",
            "params": [
              {
                "name": "parent_name",
                "type_name": "str | str",
                "description": "Used to specify the name of the parent node to insert the new node as."
              },
              {
                "name": "node",
                "type_name": "Node",
                "description": "Passed as an instance of the class `Node`."
              }
            ],
            "returns": null,
            "usage": {
              "language": "python",
              "code": "myWorker = SpecificWorker(proxy_map, startup_check=False)\n# create a new node with name \"NewNode\" and type \"Room\":\nnew_node = myWorker.insert_dsr_vertex(\"MyRobot\", {\"type\": \"Room\", \"name\": \"NewNode\"})\n",
              "description": "\nIn this example, the user creates an instance of the `SpecificWorker` class, then calls the `insert_dsr_vertex` function with the parent node name \"MyRobot\" and a dictionary containing the node type and name. The function returns a new node with the specified attributes."
            },
            "name": "insert_dsr_vertex",
            "location": {
              "start": 567,
              "insert": 569,
              "offset": " ",
              "indent": 8,
              "comment": null
            },
            "item_type": "method",
            "length": 9,
            "docLength": null
          },
          {
            "id": "2addb82a-54dd-dbac-cd4a-bb5786953a0f",
            "ancestors": [
              "75233bfc-d379-5786-3e4d-6b16aa1599c4"
            ],
            "description": "Adds an edge to an existing graph based on information provided by the edge attribute, including translation and rotation values.",
            "params": [
              {
                "name": "edge",
                "type_name": "igraph.Edge | GraphElement",
                "description": "An instance representing a single edge to be inserted into the graph."
              }
            ],
            "returns": null,
            "usage": {
              "language": "python",
              "code": "# Create an instance of the SpecificWorker class and initialize it with the proxy map\nworker = SpecificWorker(proxy_map)\n\n# Insert a new edge into the DSRGraph object\nworker.insert_igraph_edge(Edge(origin=\"Origin\", destination=\"Destination\", rt_translation=0, rt_rotation_euler_xyz=[0, 0, 0]))\n",
              "description": ""
            },
            "name": "insert_igraph_edge",
            "location": {
              "start": 581,
              "insert": 582,
              "offset": " ",
              "indent": 8,
              "comment": null
            },
            "item_type": "method",
            "length": 9,
            "docLength": null
          },
          {
            "id": "9645ce4c-8234-ba84-ff45-3574f5a37212",
            "ancestors": [
              "75233bfc-d379-5786-3e4d-6b16aa1599c4"
            ],
            "description": "Inserts or updates an edge in a graph based on the distance-sensitive roadmap (DSR) algorithm, considering the RT translation and rotation of the edge's endpoints.",
            "params": [
              {
                "name": "org",
                "type_name": "Node | None",
                "description": "Used to specify the source node of the edge being inserted. If `org` is None, it means the root node of the graph."
              },
              {
                "name": "dest",
                "type_name": "Node | str",
                "description": "Used to specify the destination node or name in the graph for which to create a new edge with RT attributes."
              }
            ],
            "returns": null,
            "usage": {
              "language": "python",
              "code": "# Creating a new worker class inheriting from GenericWorker\nclass SpecificWorker(GenericWorker):\n    def __init__(self, proxy_map):\n        super(SpecificWorker, self).__init__(proxy_map)\n        # Initializing the DSR graph with an agent ID and robot name\n        self.agent_id = 13\n        self.robot_name = \"Shadow\"\n        self.g = DSRGraph(0, \"LongTermSpatialMemory_agent\", self.agent_id)\n        # Connecting to the signals of the DSR graph\n        try:\n            signals.connect(self.g, signals.UPDATE_NODE, self.update_node)\n            signals.connect(self.g, signals.UPDATE_EDGE, self.update_edge)\n            console.print(\"signals connected\")\n        except RuntimeError as e:\n            print(e)\n",
              "description": "\nThe user can then use the function insert_dsr_edge to add an edge between two nodes in the DSR graph. Here is an example of how this might be done:\n"
            },
            "name": "insert_dsr_edge",
            "location": {
              "start": 595,
              "insert": 598,
              "offset": " ",
              "indent": 8,
              "comment": null
            },
            "item_type": "method",
            "length": 22,
            "docLength": null
          },
          {
            "id": "c91b9329-a134-37b7-f244-aae2be8f76fd",
            "ancestors": [
              "75233bfc-d379-5786-3e4d-6b16aa1599c4"
            ],
            "description": "Generates a graph based on the layout of a Kamada-Kawai graph, and adds node labels and edge annotations.",
            "params": [],
            "returns": null,
            "usage": {
              "language": "python",
              "code": "# Import necessary libraries and classes\nfrom SpecificWorker import GenericWorker, DSRGraph\nimport signals\nimport console\n\n# Instantiate a new instance of SpecificWorker\nworker = SpecificWorker(proxy_map)\n\n# Define the graph object to be drawn\ngraph = DSRGraph(0, \"LongTermSpatialMemory_agent\", worker.agent_id)\n\n# Connect signals to functions in GenericWorker class\nsignals.connect(graph, signals.UPDATE_NODE, worker.update_node)\nsignals.connect(graph, signals.UPDATE_EDGE, worker.update_edge)\n\n# Draw the graph using the draw_graph function\nworker.draw_graph(graph)\n",
              "description": ""
            },
            "name": "draw_graph",
            "location": {
              "start": 625,
              "insert": 626,
              "offset": " ",
              "indent": 8,
              "comment": null
            },
            "item_type": "method",
            "length": 16,
            "docLength": null
          },
          {
            "id": "29f979ee-26a0-1ca3-4747-685c4ee28371",
            "ancestors": [
              "75233bfc-d379-5786-3e4d-6b16aa1599c4"
            ],
            "description": "Retrieves the room ID associated with a given node ID using the Graph object's `get_node` method and attribute access, and returns the room ID if found, or -1 otherwise.",
            "params": [
              {
                "name": "node_id",
                "type_name": "int",
                "description": "Used to identify the element for which the room number needs to be checked."
              }
            ],
            "returns": {
              "type_name": "int",
              "description": "The room ID of a given element if the element has a \"room_id\" attribute, or -1 otherwise."
            },
            "usage": {
              "language": "python",
              "code": "worker = SpecificWorker(proxy_map, startup_check=False)\nroom_id = worker.check_element_room_number(node_id)\nprint(f\"The room ID of the node with ID {node_id} is {room_id}.\")\n",
              "description": ""
            },
            "name": "check_element_room_number",
            "location": {
              "start": 650,
              "insert": 651,
              "offset": " ",
              "indent": 8,
              "comment": null
            },
            "item_type": "method",
            "length": 7,
            "docLength": null
          },
          {
            "id": "5dddb8ec-4dbc-e387-6e48-64f7ff25662a",
            "ancestors": [
              "75233bfc-d379-5786-3e4d-6b16aa1599c4"
            ],
            "description": "Determines the level of an element with a given ID in the internal graph, handles exceptions, and adjusts door connections based on the room similarity.",
            "params": [
              {
                "name": "node_id",
                "type_name": "int",
                "description": "Used to identify the node being checked for its element level attribute value."
              }
            ],
            "returns": {
              "type_name": "int",
              "description": "The level of an element with the given node ID, or -1 if no such attribute is found."
            },
            "usage": {
              "language": "python",
              "code": "# Example of using the check_element_level function\n\n# Create a new instance of the SpecificWorker class\nmy_worker = SpecificWorker(proxy_map, startup_check=False)\n\n# Call the check_element_level function with node_id as an argument\nelement_level = my_worker.check_element_level(\"node_id\")\n",
              "description": ""
            },
            "name": "check_element_level",
            "location": {
              "start": 659,
              "insert": 660,
              "offset": " ",
              "indent": 8,
              "comment": null
            },
            "item_type": "method",
            "length": 25,
            "docLength": null
          },
          {
            "id": "d812eadc-e596-7a97-8447-d13ce3895f4d",
            "ancestors": [
              "75233bfc-d379-5786-3e4d-6b16aa1599c4"
            ],
            "description": "Retrieves information about a room and its RT edges, then draws the room polygon and doors on an image.",
            "params": [
              {
                "name": "room_node_id",
                "type_name": "str | int",
                "description": "Represented as an integer or string, representing the node ID of the room to be drawn."
              }
            ],
            "returns": null,
            "usage": {
              "language": "python",
              "code": "# Importing necessary packages\nfrom SpecificWorker import SpecificWorker\nimport cv2\n\n# Create a new instance of the class SpecificWorker\nworker = SpecificWorker(proxy_map, startup_check=False)\n\n# Call the generate_room_picture method with the desired room node ID as an argument\nroom_node_id = \"Room1\"\nworker.generate_room_picture(room_node_id)\n",
              "description": "\nThis code creates a new instance of the SpecificWorker class, imports the necessary packages, and calls the generate_room_picture method with the desired room node ID as an argument. The function will then generate a 2D image of the room based on the information stored in the graph. The resulting image can be viewed using the OpenCV library by calling cv2.imwrite() or displayed directly using the OpenCV library's display() method."
            },
            "name": "generate_room_picture",
            "location": {
              "start": 702,
              "insert": 704,
              "offset": " ",
              "indent": 8,
              "comment": null
            },
            "item_type": "method",
            "length": 24,
            "docLength": null
          },
          {
            "id": "a50d6999-6284-35be-614f-deef0dec204d",
            "ancestors": [
              "75233bfc-d379-5786-3e4d-6b16aa1599c4"
            ],
            "description": "Inserts or assigns an edge to the graph representing the current room of the agent, with the source and destination being the same agent ID.",
            "params": [
              {
                "name": "room_id",
                "type_name": "str",
                "description": "Passed as an argument to Edge constructor, representing the ID of the current room that the agent is in."
              }
            ],
            "returns": null,
            "usage": {
              "language": "python",
              "code": "worker = SpecificWorker(proxy_map)\nroom_id = 254\nworker.insert_current_edge(room_id)\n",
              "description": ""
            },
            "name": "insert_current_edge",
            "location": {
              "start": 737,
              "insert": 739,
              "offset": " ",
              "indent": 8,
              "comment": null
            },
            "item_type": "method",
            "length": 3,
            "docLength": null
          },
          {
            "id": "9bc1d031-9b8b-578b-b14d-26d0bcd00d92",
            "ancestors": [
              "75233bfc-d379-5786-3e4d-6b16aa1599c4"
            ],
            "description": "Updates a node's information based on its type and other factors, such as checking if a door node exists and inserting it into the graph if necessary, or handling an affordance node's state change.",
            "params": [
              {
                "name": "id",
                "type_name": "int",
                "description": "Used as an identifier for a node in the graph."
              },
              {
                "name": "type",
                "type_name": "str",
                "description": "Used to indicate the type of node being updated."
              }
            ],
            "returns": null,
            "usage": {
              "language": "python",
              "code": "worker = SpecificWorker(proxy_map, startup_check=True)\nif worker.rt_api.is_running():\n    print(\"Robot is running\")\nelse:\n    print(\"Robot is not running\")\n    return\n\n# Update node with id 123 and type \"door\"\nworker.update_node(123, \"door\")\n",
              "description": ""
            },
            "name": "update_node",
            "location": {
              "start": 751,
              "insert": 752,
              "offset": " ",
              "indent": 8,
              "comment": null
            },
            "item_type": "method",
            "length": 41,
            "docLength": null
          },
          {
            "id": "0c89aab3-c848-cb96-6046-4854f3cd0019",
            "ancestors": [
              "75233bfc-d379-5786-3e4d-6b16aa1599c4"
            ],
            "description": "Updates an edge in the graph based on the current node, type, and other conditions.",
            "params": [
              {
                "name": "fr",
                "type_name": "int",
                "description": "Referred to as \"from room\" indicating that it represents the starting point of an edge in the graph, specifically a room node."
              },
              {
                "name": "to",
                "type_name": "int",
                "description": "The id of the target node to which the edge is being updated."
              },
              {
                "name": "type",
                "type_name": "str",
                "description": "Used to specify the type of edge being updated (either \"RT\" or \"FT\")."
              }
            ],
            "returns": null,
            "usage": {
              "language": "python",
              "code": "# Instantiate an object of SpecificWorker class\nworker = SpecificWorker()\n\n# Set the robot name and ID\nworker.robot_name = \"Shadow\"\nworker.robot_id = 13\n\n# Update the edge with type 'RT' between node 0 (the robot) and node 1 (a room exit door)\nworker.update_edge(fr=0, to=1, type=\"RT\")\n",
              "description": ""
            },
            "name": "update_edge",
            "location": {
              "start": 806,
              "insert": 810,
              "offset": " ",
              "indent": 8,
              "comment": null
            },
            "item_type": "method",
            "length": 5,
            "docLength": null
          }
        ]
      }
    }
  }
]