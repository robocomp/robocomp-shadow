[
  {
    "name": "long_term_graph.py",
    "path": "agents/long_term_spatial_memory_agent/src/long_term_graph.py",
    "content": {
      "structured": {
        "description": "A class `Room` that represents a 3D room in a graph, with nodes representing corners and edges representing walls. The class provides methods for calculating the projective coordinates (4x1) of the corners and objects in the room frame, as well as for drawing the room and its objects on a plot. The code uses the `networkx` and `scipy.spatial` libraries to manipulate and analyze the graph data.",
        "items": [
          {
            "id": "e77351db-7a15-56b3-3644-4399c887d62b",
            "ancestors": [],
            "description": "Provides a user interface for visualizing and exploring a graph, including rooms and doors. It allows for adding nodes, edges, and doors, as well as displaying room names and distances between nodes.",
            "attributes": [
              {
                "name": "g",
                "type_name": "str|int",
                "description": "Used to specify the color of the graph's edges. It can be set to a valid matplotlib color name or an integer value between 0 and 1, representing the transparency level of the edge."
              },
              {
                "name": "read_graph",
                "type_name": "Callable[[str],Dict[str,float]]",
                "description": "Used to read a graph from a file specified by the filename parameter. It returns a dictionary containing the graph data as key-value pairs where keys are node or edge indices and values are the corresponding coordinates or weights."
              },
              {
                "name": "fig",
                "type_name": "matplotlibfigureFigure",
                "description": "Used to represent the figure object that will be drawn with the graph. It contains information about the figure, such as its size, layout, and any additional elements that will be displayed in it."
              },
              {
                "name": "ax",
                "type_name": "matplotlibpyplotAxes",
                "description": "Used to represent a 2D axes object that displays the graphical representation of the long-term graph."
              },
              {
                "name": "fig_2",
                "type_name": "matplotlibfigureFigure",
                "description": "Used to store the figure object for the second graph."
              },
              {
                "name": "ax_2",
                "type_name": "AxesSubplot|MatplotlibFigure",
                "description": "Used to store a secondary axes object, which can be used to display additional visualizations or metrics alongside the primary graph."
              }
            ],
            "name": "LongTermGraph",
            "location": {
              "start": 15,
              "insert": 16,
              "offset": " ",
              "indent": 4,
              "comment": null
            },
            "item_type": "class",
            "length": 269,
            "docLength": null
          },
          {
            "id": "35f455db-0eef-1ba5-f04f-cb6cacf60abb",
            "ancestors": [
              "e77351db-7a15-56b3-3644-4399c887d62b"
            ],
            "description": "Reads a graph from a file, creates an igraph object, and displays both the original graph and its metric reconstruction using matplotlib.",
            "params": [
              {
                "name": "file_name",
                "type_name": "str",
                "description": "Used to specify the name of the graph file that contains the LTSM data to be reconstructed."
              }
            ],
            "returns": null,
            "usage": {
              "language": "python",
              "code": "from LongTermGraph import LongTermGraph\n\n# create an instance of the class and set its name\nltg = LongTermGraph(\"my_graph.pickle\")\n\n# print the summary of the graph\nprint(ltg.summary())\n\n# plot the graph on a matplotlib figure\nltg.plot()\n",
              "description": ""
            },
            "name": "__init__",
            "location": {
              "start": 16,
              "insert": 17,
              "offset": " ",
              "indent": 8,
              "comment": null
            },
            "item_type": "constructor",
            "length": 22,
            "docLength": null
          },
          {
            "id": "252c67c9-d429-faa7-ef4a-8d465711c8a0",
            "ancestors": [
              "e77351db-7a15-56b3-3644-4399c887d62b"
            ],
            "description": "Generates a graph based on a subgraph of the original graph, with only certain types of nodes and edges visible.",
            "params": [
              {
                "name": "only_rooms",
                "type_name": "bool",
                "description": "Used to filter out nodes that are not rooms or doors, and edges that do not connect rooms or doors."
              }
            ],
            "returns": null,
            "usage": {
              "language": "python",
              "code": "# create an instance of LongTermGraph class and read graph from file\nmy_graph = LongTermGraph(\"myfile.pkl\")\n\n# draw graph with only rooms\nmy_graph.draw_graph(only_rooms=True)\n\n# draw graph with all nodes including walls, doors, and rooms\nmy_graph.draw_graph()\n",
              "description": ""
            },
            "name": "draw_graph",
            "location": {
              "start": 252,
              "insert": 253,
              "offset": " ",
              "indent": 8,
              "comment": null
            },
            "item_type": "method",
            "length": 33,
            "docLength": null
          }
        ]
      }
    }
  },
  {
    "name": "genericworker.py",
    "path": "agents/g2o_agent/src/genericworker.py",
    "content": {
      "structured": {
        "description": "A worker class that inherits from QtWidgets.QWidget and provides a kill signal for shutting down the worker. The code also sets up an ice slice and imports a RoboCompCommonBehavior module. Additionally, the code creates a Ui_guiDlg class and initializes a timer to call a method every 30 milliseconds.",
        "items": [
          {
            "id": "cb6f42fc-bcd1-7fb5-eb49-91afccba59e8",
            "ancestors": [],
            "description": "Manages a worker process with a periodic timer and provides a signal for termination. It also has a method to set the period of the timer.",
            "attributes": [
              {
                "name": "kill",
                "type_name": "QtCoreSignal",
                "description": "Used to emit a signal when the object needs to be killed."
              },
              {
                "name": "ui",
                "type_name": "Ui_guiDlg",
                "description": "Used to initialize and access the user interface of the widget."
              },
              {
                "name": "mutex",
                "type_name": "QMutex",
                "description": "Used to protect access to the internal state of the worker object, particularly the timer and kill signal."
              },
              {
                "name": "Period",
                "type_name": "int",
                "description": "30 milliseconds by default, which represents the time interval for the timer to run."
              },
              {
                "name": "timer",
                "type_name": "QTimer",
                "description": "Used to schedule a call to the `killYourSelf` slot after a specified period of time."
              }
            ],
            "name": "GenericWorker",
            "location": {
              "start": 43,
              "insert": 45,
              "offset": " ",
              "indent": 4,
              "comment": null
            },
            "item_type": "class",
            "length": 26,
            "docLength": null
          },
          {
            "id": "795c292f-f253-f1aa-a748-23953c9013be",
            "ancestors": [
              "cb6f42fc-bcd1-7fb5-eb49-91afccba59e8"
            ],
            "description": "Initializes an instance of the `GenericWorker` class, setting up a GUI dialog and creating a mutex for managing access to the timer. It also sets the period of the timer to 30 seconds.",
            "params": [
              {
                "name": "mprx",
                "type_name": "Ui_guiDlg",
                "description": "Used as an argument for the setupUi method."
              }
            ],
            "returns": null,
            "name": "__init__",
            "location": {
              "start": 47,
              "insert": 48,
              "offset": " ",
              "indent": 8,
              "comment": null
            },
            "item_type": "method",
            "length": 9,
            "docLength": null
          },
          {
            "id": "ea51cd3f-4286-88a2-5c4e-a765280c1202",
            "ancestors": [
              "cb6f42fc-bcd1-7fb5-eb49-91afccba59e8"
            ],
            "description": "Emits the `kill` signal, indicating that the instance should be destroyed.",
            "params": [],
            "returns": null,
            "name": "killYourSelf",
            "location": {
              "start": 60,
              "insert": 62,
              "offset": " ",
              "indent": 8,
              "comment": null
            },
            "item_type": "method",
            "length": 4,
            "docLength": null
          },
          {
            "id": "20082581-a4f0-66af-9a45-78e2e70b070f",
            "ancestors": [
              "cb6f42fc-bcd1-7fb5-eb49-91afccba59e8"
            ],
            "description": "Updates the `Period` attribute and starts a timer with the new period value using the `timer.start()` method.",
            "params": [
              {
                "name": "p",
                "type_name": "int",
                "description": "Used to set the new period for the timer."
              }
            ],
            "returns": null,
            "name": "setPeriod",
            "location": {
              "start": 67,
              "insert": 69,
              "offset": " ",
              "indent": 8,
              "comment": null
            },
            "item_type": "method",
            "length": 5,
            "docLength": null
          }
        ]
      }
    }
  },
  {
    "name": "specificworker.py",
    "path": "agents/g2o_agent/src/specificworker.py",
    "content": {
      "structured": {
        "description": "A specific worker class that inherits from a generic worker class and is part of a robotic system using DSR (Data Stream Representation) framework. It handles robot odometry updates, generates an information matrix considering noise, optimizes pose estimation, and visualizes the results in 3D space using matplotlib. The worker initializes a G2O graph based on room nodes, corners, and edges, which is then used to optimize robot poses and predict future positions.",
        "items": [
          {
            "id": "609f6edc-14d7-26a1-1c4c-62744b75a643",
            "ancestors": [],
            "description": "Is a worker thread responsible for processing robot odometry data and updating the graph representation using G2O library. It initializes the graph, adds edges and vertices, computes pose and covariance matrix, and visualizes the graph in real-time.",
            "attributes": [
              {
                "name": "Period",
                "type_name": "int",
                "description": "50 by default. It represents the time period for which the worker's timer should wait before calling the `compute` method."
              },
              {
                "name": "agent_id",
                "type_name": "int",
                "description": "20 by default. It seems to be used as a unique identifier for the agent, possibly in conjunction with other nodes or edges in the graph."
              },
              {
                "name": "g",
                "type_name": "DSRGraph",
                "description": "Initialized with a node named \"G2O_agent\" and agent_id 20. It represents a graph data structure used to store nodes, edges, and their attributes."
              },
              {
                "name": "startup_check",
                "type_name": "NoneNone",
                "description": "Used as a parameter in the method with the same name. It seems to be a placeholder or a flag for checking whether some initialization is done, but its exact purpose is not clear from the provided code."
              },
              {
                "name": "rt_api",
                "type_name": "object",
                "description": "Used to get edge information from a Room-Terrain model (RT) API, which seems to provide information about robot edges in a room."
              },
              {
                "name": "inner_api",
                "type_name": "object",
                "description": "Not fully defined in this code snippet. Its purpose appears to be related to transforming room node names to robot pose measurements, but its implementation is unclear without more context or additional code."
              },
              {
                "name": "odometry_node_id",
                "type_name": "int",
                "description": "20 in this case. It seems to be used as a reference to the robot's node in the graph, likely representing its current position or pose."
              },
              {
                "name": "odometry_queue",
                "type_name": "deque[int,float,int]",
                "description": "15 elements long. It stores odometry data, where each element contains robot's current advance speed, side speed, angular speed, and timestamp in milliseconds."
              },
              {
                "name": "last_odometry",
                "type_name": "Tuple[float,float,float,int]",
                "description": "4-element tuple that represents the last recorded odometry values of the robot, including its advancement speed, lateral speed, angular speed, and timestamp."
              },
              {
                "name": "g2o",
                "type_name": "G2OGraph",
                "description": "Used for graph optimization with g2o library. It represents a graph where nodes are poses and edges are measurements between them, allowing to compute the most likely pose given the measurements."
              },
              {
                "name": "odometry_noise_std_dev",
                "type_name": "float",
                "description": "1 by default. It seems to be related to noise added to odometry measurements, representing the standard deviation of the noise."
              },
              {
                "name": "odometry_noise_angle_std_dev",
                "type_name": "float",
                "description": "1 by default. It represents the standard deviation of the noise added to odometry angles during the estimation process using G2O."
              },
              {
                "name": "measurement_noise_std_dev",
                "type_name": "float",
                "description": "1 by default. It seems to be used as a standard deviation for noise in measurements, possibly related to odometry or landmark estimation in SLAM (Simultaneous Localization and Mapping)."
              },
              {
                "name": "last_room_id",
                "type_name": "None|str",
                "description": "Used to store the previously visited room ID. It is initialized as None, but gets updated when the current room ID changes."
              },
              {
                "name": "actual_room_id",
                "type_name": "int|None",
                "description": "Set as follows:\n\n- Initially, it is None.\n- When a room node is found with its id matching `actual_room_id`, it becomes equal to that room's id.\n- When a new room node is found, `last_room_id` is set to the current `actual_room_id`, and `actual_room_id` is updated with the new room's id."
              },
              {
                "name": "elapsed",
                "type_name": "float",
                "description": "Initialized as `time.time()`. It seems to be used to track the time elapsed since the last update of some variables or data, possibly related to the robot's odometry."
              },
              {
                "name": "room_initialized",
                "type_name": "bool",
                "description": "Used to indicate whether the g2o graph has been successfully initialized for a specific room or not."
              },
              {
                "name": "iterations",
                "type_name": "int",
                "description": "Initialized as 0 in the constructor (`__init__`). It keeps track of the number of iterations since the last frame was processed."
              },
              {
                "name": "hide",
                "type_name": "NoneType",
                "description": "Set to True or False. However, there is no clear description or usage of this attribute within the provided code."
              },
              {
                "name": "init_graph",
                "type_name": "bool",
                "description": "Initialized as `False`. It seems to be used to track whether the g2o graph has been initialized or not, and its value changes after certain events such as a room change."
              },
              {
                "name": "current_edge_set",
                "type_name": "bool",
                "description": "Set to True when a current edge is detected between a room node and the Shadow node, indicating that the robot has moved into a new room."
              },
              {
                "name": "first_rt_set",
                "type_name": "bool",
                "description": "Set to True when a first RT edge (Robot Translation) is detected between the \"room\" node and the \"Shadow\" node, indicating that the robot has moved into a new room."
              },
              {
                "name": "translation_to_set",
                "type_name": "Tuple[float,float,float]",
                "description": "Set when a new RT edge is detected, storing the translation values (tx, ty, tz) for further processing in the G2O graph."
              },
              {
                "name": "rotation_to_set",
                "type_name": "Tuple[float,float,float]",
                "description": "Set when a \"RT\" edge (robot translation) from a room node to the robot node is detected, indicating that the robot's rotation needs to be updated."
              },
              {
                "name": "room_polygon",
                "type_name": "QPolygonF",
                "description": "Used to store a polygon representing the boundaries of the current room being explored by the robot."
              },
              {
                "name": "security_polygon",
                "type_name": "QPolygonF",
                "description": "Used to store a polygon that defines a region within which the robot must remain to ensure safety."
              },
              {
                "name": "initialize_g2o_graph",
                "type_name": "bool",
                "description": "Used to initialize a G2O graph object."
              },
              {
                "name": "rt_set_last_time",
                "type_name": "float",
                "description": "Set to the current time when a \"RT\" edge is updated between a room node and the robot node named \"Shadow\". This is used to track the last update time for RT edges."
              },
              {
                "name": "rt_time_min",
                "type_name": "float",
                "description": "1 second. It is used to determine when to update the translation and rotation values after setting a new RT edge."
              },
              {
                "name": "last_update_with_corners",
                "type_name": "float",
                "description": "Updated with the current time when the robot's corners are updated. It keeps track of the last update time for the corners."
              },
              {
                "name": "timer",
                "type_name": "QtCoreQTimer",
                "description": "Used to schedule a method (in this case, `compute`) at regular intervals (`self.Period`). It starts the timer after initializing the g2o graph."
              },
              {
                "name": "compute",
                "type_name": "QtCoreSlot",
                "description": "Used to compute and update the robot's position in real-time based on its odometry data and room information. It also checks for valid corners and doors, and updates the g2o graph accordingly."
              },
              {
                "name": "update_node_att",
                "type_name": "NoneNone",
                "description": "Not defined within the given code snippet."
              },
              {
                "name": "update_edge",
                "type_name": "defupdate_edgeself,frint,toint,typestrNone",
                "description": "Called when an edge in the graph changes. It handles different types of edges, such as \"current\" or \"RT\", and updates internal state accordingly."
              },
              {
                "name": "update_edge_att",
                "type_name": "None",
                "description": "Passed as a parameter to the `update_edge_att` method. It is not used anywhere in the code."
              }
            ],
            "name": "SpecificWorker",
            "location": {
              "start": 50,
              "insert": 51,
              "offset": " ",
              "indent": 4,
              "comment": null
            },
            "item_type": "class",
            "length": 423,
            "docLength": null
          },
          {
            "id": "d4c86ec3-d2a9-ebbb-6b41-649a5fecc346",
            "ancestors": [
              "609f6edc-14d7-26a1-1c4c-62744b75a643"
            ],
            "description": "Initializes various attributes and performs startup checks or sets up internal APIs, graph structures, and timers based on input parameters. It connects signals to methods for handling node updates, edge updates, and other events.",
            "params": [
              {
                "name": "proxy_map",
                "type_name": "object",
                "description": "Passed to the superclass using `super(SpecificWorker, self).__init__(proxy_map)`. Its purpose is not explicitly mentioned in this snippet, but it might be related to initialization or setup of some sort."
              },
              {
                "name": "startup_check",
                "type_name": "bool",
                "description": "Used to decide whether to perform a startup check or not. If it is True, the `startup_check` method is called; otherwise, other initialization steps are performed."
              }
            ],
            "returns": null,
            "usage": {
              "language": "python",
              "code": "worker = SpecificWorker({\"proxy1\": \"localhost:9000\", \"proxy2\": \"localhost:9001\"}, startup_check=True)\n",
              "description": "\n\nThis example demonstrates how to create a `SpecificWorker` instance with a dictionary containing proxy map and a boolean flag for the startup check."
            },
            "name": "__init__",
            "location": {
              "start": 51,
              "insert": 52,
              "offset": " ",
              "indent": 8,
              "comment": null
            },
            "item_type": "constructor",
            "length": 54,
            "docLength": null
          },
          {
            "id": "89daf63d-e190-4bac-1b45-3b07fbc03640",
            "ancestors": [
              "609f6edc-14d7-26a1-1c4c-62744b75a643"
            ],
            "description": "Computes and updates the robot's pose, odometry, and edge information by analyzing the room environment and integrating new data from sensors. It also optimizes the pose estimation using the G2O library and updates the robot's position in the graph.",
            "params": [],
            "returns": null,
            "usage": {
              "language": "python",
              "code": "worker = SpecificWorker(proxy_map, startup_check=False)\nwhile True:\n    worker.compute()\n    time.sleep(0.02)",
              "description": ""
            },
            "name": "compute",
            "location": {
              "start": 123,
              "insert": 125,
              "offset": " ",
              "indent": 8,
              "comment": null
            },
            "item_type": "method",
            "length": 103,
            "docLength": null
          },
          {
            "id": "e8b6c91f-187a-74af-dc4e-6c91a9381907",
            "ancestors": [
              "609f6edc-14d7-26a1-1c4c-62744b75a643"
            ],
            "description": "Initializes the G2O graph by setting fixed poses and adding nominal corners based on the robot's pose, room geometry, and door nodes. It also updates the actual room ID and checks for valid node attributes.",
            "params": [],
            "returns": {
              "type_name": "bool|None",
              "description": "True if successful and initializes a G2O graph, otherwise it returns None or False indicating failure."
            },
            "usage": {
              "language": "python",
              "code": "worker = SpecificWorker(proxy_map)\nworker.initialize_g2o_graph()\n",
              "description": "\nThis code instantiates a SpecificWorker object with proxy_map as its parameter, then calls the initialize_g2o_graph method."
            },
            "name": "initialize_g2o_graph",
            "location": {
              "start": 253,
              "insert": 256,
              "offset": " ",
              "indent": 8,
              "comment": null
            },
            "item_type": "method",
            "length": 115,
            "docLength": null
          },
          {
            "id": "7897dc05-497c-c28e-3b4f-9ed0a337ea5c",
            "ancestors": [
              "609f6edc-14d7-26a1-1c4c-62744b75a643"
            ],
            "description": "Calculates displacement values (lateral, advance, and angular) based on odometry data stored in a queue, using timestamps to match consecutive readings and applying a filtering factor (0.8).",
            "params": [
              {
                "name": "odometry",
                "type_name": "Tuple[float, float, float, float]",
                "description": "Assumed to represent the current odometry data."
              }
            ],
            "returns": {
              "type_name": "Tuple[float,float,float]",
              "description": "A tuple containing three float values representing the lateral displacement, advance displacement, and angular displacement respectively."
            },
            "usage": {
              "language": "python",
              "code": "worker = SpecificWorker(proxy_map)\nodometry = [(1, 2, 3, 4), (5, 6, 7, 8)]\nlateral, advance, angular = worker.get_displacement(odometry)",
              "description": ""
            },
            "name": "get_displacement",
            "location": {
              "start": 458,
              "insert": 459,
              "offset": " ",
              "indent": 8,
              "comment": null
            },
            "item_type": "method",
            "length": 14,
            "docLength": null
          },
          {
            "id": "5175f913-8e97-5989-554b-9ba4188aead9",
            "ancestors": [
              "609f6edc-14d7-26a1-1c4c-62744b75a643"
            ],
            "description": "Computes and returns the covariance matrix for a given vertex using the g2o optimizer's compute_marginals function, and prints relevant messages indicating whether computation was successful or not.",
            "params": [
              {
                "name": "vertex",
                "type_name": "object",
                "description": "Expected to have attributes such as `hessian_index`."
              }
            ],
            "returns": {
              "type_name": "Tuple[Optional[str],Optional[Dict[int,float]]|None",
              "description": "A tuple containing two values: the first one is an optional string (\"Covariance computed\" or \"Covariance not computed\") and the second one is an optional covariance matrix (or None)."
            },
            "usage": {
              "language": "python",
              "code": "worker = SpecificWorker(proxy_map, startup_check=False)\nvertex = worker.g.get_node(\"Shadow\")\ncovariances_result, covariances = worker.get_covariance_matrix(vertex)",
              "description": ""
            },
            "name": "get_covariance_matrix",
            "location": {
              "start": 477,
              "insert": 478,
              "offset": " ",
              "indent": 8,
              "comment": null
            },
            "item_type": "method",
            "length": 11,
            "docLength": null
          },
          {
            "id": "0845024e-0656-4daa-114c-2c7c98f50930",
            "ancestors": [
              "609f6edc-14d7-26a1-1c4c-62744b75a643"
            ],
            "description": "Visualizes the estimated positions of vertices and edges from a G2O optimization process in real-time using matplotlib's 3D plotting functionality.",
            "params": [
              {
                "name": "optimizer",
                "type_name": "g2o::OptimizationAlgorithm",
                "description": "Responsible for optimizing the graph represented by vertices and edges. It contains methods to load, iterate over vertices and edges, as well as other operations."
              }
            ],
            "returns": null,
            "usage": {
              "language": "python",
              "code": "worker = SpecificWorker(proxy_map)\nwhile True:\n    worker.visualize_g2o_realtime(worker.optimizer)",
              "description": ""
            },
            "name": "visualize_g2o_realtime",
            "location": {
              "start": 490,
              "insert": 491,
              "offset": " ",
              "indent": 8,
              "comment": null
            },
            "item_type": "method",
            "length": 29,
            "docLength": null
          },
          {
            "id": "86df470e-4c72-b08b-6b41-4ed9860faf95",
            "ancestors": [
              "609f6edc-14d7-26a1-1c4c-62744b75a643"
            ],
            "description": "Updates node attributes and appends data to a queue when the specified ID matches the odometry node ID, processing relevant attribute values from the Shadow node.",
            "params": [
              {
                "name": "id",
                "type_name": "int",
                "description": "Required when calling this function. It represents an identifier that determines which node attributes will be updated, specifically the odometry node if its value matches the self.odometry_node_id."
              },
              {
                "name": "attribute_names",
                "type_name": "[str]",
                "description": "Not used within the provided code snippet. Its presence suggests that it may be intended for future use or as a placeholder for some functionality, but its purpose remains unclear."
              }
            ],
            "returns": null,
            "usage": {
              "language": "python",
              "code": "worker = SpecificWorker(proxy_map, startup_check=True)\nworker.update_node_att(1, [\"attribute1\", \"attribute2\"])",
              "description": ""
            },
            "name": "update_node_att",
            "location": {
              "start": 527,
              "insert": 536,
              "offset": " ",
              "indent": 8,
              "comment": null
            },
            "item_type": "method",
            "length": 7,
            "docLength": null
          },
          {
            "id": "110e6d65-7753-3797-b145-9550aa15c08c",
            "ancestors": [
              "609f6edc-14d7-26a1-1c4c-62744b75a643"
            ],
            "description": "Updates a node in a graph based on its ID and type, possibly initializing the graph if necessary for certain types of nodes, such as room corners.",
            "params": [
              {
                "name": "id",
                "type_name": "int",
                "description": "Required. It specifies the unique identifier for the node to be updated in the graph."
              },
              {
                "name": "type",
                "type_name": "str",
                "description": "Expected to be either \"corner\" or any other string value. This information will help determine how the node with given `id` should be updated."
              }
            ],
            "returns": null,
            "usage": {
              "language": "python",
              "code": "worker = SpecificWorker(proxy_map)\nworker.update_node(1, \"room\")",
              "description": ""
            },
            "name": "update_node",
            "location": {
              "start": 543,
              "insert": 553,
              "offset": " ",
              "indent": 8,
              "comment": null
            },
            "item_type": "method",
            "length": 6,
            "docLength": null
          },
          {
            "id": "e9952f42-2b9e-63ab-1849-1cb653ec4423",
            "ancestors": [
              "609f6edc-14d7-26a1-1c4c-62744b75a643"
            ],
            "description": "Deletes a node based on its id and resets the `room_initialized` flag to False after deletion, implying that the room's initialization is undone as a result of deleting a node.",
            "params": [
              {
                "name": "id",
                "type_name": "int",
                "description": "Expected to receive an integer value representing the ID of a node to be deleted."
              }
            ],
            "returns": null,
            "usage": {
              "language": "python",
              "code": "worker = SpecificWorker(proxy_map, startup_check=True)\nnode = self.g.get_node(id)\nworker.delete_node(node.id)",
              "description": ""
            },
            "name": "delete_node",
            "location": {
              "start": 555,
              "insert": 556,
              "offset": " ",
              "indent": 8,
              "comment": null
            },
            "item_type": "method",
            "length": 6,
            "docLength": null
          },
          {
            "id": "984f9f40-6985-028f-ea43-2b448d8b12be",
            "ancestors": [
              "609f6edc-14d7-26a1-1c4c-62744b75a643"
            ],
            "description": "Updates the current room ID and initializes/updates RT (Rotation Translation) settings based on the edge type (\"current\", \"RT\") and node attributes. It also prints status messages for debugging purposes.",
            "params": [
              {
                "name": "fr",
                "type_name": "int",
                "description": "Referred to as \"from\" or source node. It represents the node from which an edge originates in a graph, specifically a room in the context of this function."
              },
              {
                "name": "to",
                "type_name": "int",
                "description": "Used as an edge destination node ID when updating edges of graph `g`."
              },
              {
                "name": "type",
                "type_name": "str",
                "description": "Used to determine the action to be taken when updating an edge in the graph. It can have one of two values: \"current\" or \"RT\", depending on the type of update being performed."
              }
            ],
            "returns": null,
            "usage": {
              "language": "python",
              "code": "worker = SpecificWorker(proxy_map, startup_check=False)\nworker.update_edge(1, 2, \"current\")\nworker.update_edge(3, 4, \"RT\")",
              "description": ""
            },
            "name": "update_edge",
            "location": {
              "start": 564,
              "insert": 565,
              "offset": " ",
              "indent": 8,
              "comment": null
            },
            "item_type": "method",
            "length": 22,
            "docLength": null
          },
          {
            "id": "6e6d2faf-e905-d2a0-df4b-fc5568d9863a",
            "ancestors": [
              "609f6edc-14d7-26a1-1c4c-62744b75a643"
            ],
            "description": "Removes an edge from the graph. The method takes three parameters: fr (from), to (to) and type, representing the edge's endpoints and type respectively.",
            "params": [
              {
                "name": "fr",
                "type_name": "int",
                "description": "Expected to represent the starting vertex of an edge in a graph. It specifies the node from which the edge originates."
              },
              {
                "name": "to",
                "type_name": "int",
                "description": "Likely an identifier for a node or vertex in a graph."
              },
              {
                "name": "type",
                "type_name": "str",
                "description": "Intended to specify the type or nature of the edge being deleted between nodes fr and to."
              }
            ],
            "returns": null,
            "usage": {
              "language": "python",
              "code": "worker = SpecificWorker(proxy_map, startup_check=False)\nworker.delete_edge(1, 2, \"edge_type\")",
              "description": ""
            },
            "name": "delete_edge",
            "location": {
              "start": 592,
              "insert": 593,
              "offset": " ",
              "indent": 8,
              "comment": null
            },
            "item_type": "method",
            "length": 3,
            "docLength": null
          }
        ]
      }
    }
  },
  {
    "name": "long_term_graph.py",
    "path": "agents/long_term_spatial_memory_agent/scripts/long_term_graph.py",
    "content": {
      "structured": {
        "description": "a function called draw_metric_map that takes in a metric map object and plots the map using Matplotlib. It first loads the graph from a text file and defines various functions to work with the graph, such as get_room_corners, get_room_objects, and get_room_objects_coordinates. These functions recursively traverse the graph to find the corners or objects in a room, respectively. The draw_metric_map function then uses these functions to plot the rooms and objects in the map. Specifically, it plots each room as a rectangle and adds names to each room, and it plots each object as a point and adds a text label with its name.",
        "items": [
          {
            "id": "5176435a-f92b-e4bd-1b4e-e1e310ab5ae8",
            "ancestors": [],
            "description": "Draws a graph of long-term spatial mobility data using PyQt and Matplotlib. It provides methods to visualize rooms, doors, walls, and edges in the graph.",
            "attributes": [
              {
                "name": "g",
                "type_name": "Graph",
                "description": "Used to represent the graph object that contains the rooms, doors, and walls to be visualized."
              },
              {
                "name": "read_graph",
                "type_name": "instance",
                "description": "Used to read a graph from a file specified by the user. It takes a string path as input and reads the graph data from it."
              },
              {
                "name": "fig",
                "type_name": "instance",
                "description": "A reference to the figure object that will be used to draw the graph."
              },
              {
                "name": "ax",
                "type_name": "MatplotlibFigure",
                "description": "Used to represent the axis object for the graph. It provides methods for adding patches, lines, and other visual elements to the graph."
              }
            ],
            "name": "LongTermGraph",
            "location": {
              "start": 15,
              "insert": 16,
              "offset": " ",
              "indent": 4,
              "comment": null
            },
            "item_type": "class",
            "length": 198,
            "docLength": null
          },
          {
            "id": "411ae665-2c3f-efb9-7546-d76e93280634",
            "ancestors": [
              "5176435a-f92b-e4bd-1b4e-e1e310ab5ae8"
            ],
            "description": "Initializes an object of `LongTermGraph` class, loading a graph from a file using the `read_graph` method and displaying its summary.",
            "params": [
              {
                "name": "file_name",
                "type_name": "str",
                "description": "Used to specify the name of a file containing a graph represented as an adjacency matrix."
              }
            ],
            "returns": null,
            "name": "__init__",
            "location": {
              "start": 16,
              "insert": 17,
              "offset": " ",
              "indent": 8,
              "comment": null
            },
            "item_type": "method",
            "length": 8,
            "docLength": null
          },
          {
            "id": "fbfe681a-6ac8-9cb2-ad48-9c2d64fec643",
            "ancestors": [
              "5176435a-f92b-e4bd-1b4e-e1e310ab5ae8"
            ],
            "description": "Generates a graphical representation of a subgraph within a larger graph, based on node and edge properties. It creates a figure and axis object, sets the title, and draws the nodes and edges using different colors for each type of node or edge.",
            "params": [
              {
                "name": "only_rooms",
                "type_name": "bool",
                "description": "Used to filter the nodes in the graph based on their types, only showing rooms and doors."
              }
            ],
            "returns": null,
            "name": "draw_graph",
            "location": {
              "start": 191,
              "insert": 192,
              "offset": " ",
              "indent": 8,
              "comment": null
            },
            "item_type": "method",
            "length": 34,
            "docLength": null
          }
        ]
      }
    }
  },
  {
    "name": "main.py",
    "path": "agents/long_term_spatial_memory_agent/scripts/main.py",
    "content": {
      "structured": {
        "description": "Three functions: draw_graph, find_edge_with_attribute, and get_connected_door_nodes. The draw_graph function takes a graph object as input and uses PySide2's QtCore module to create a subplot and plot points on the graph. The find_edge_with_attribute function searches for an edge in a given graph based on a specific attribute, and the get_connected_door_nodes function recursively traverses a graph to find all connected door nodes in a given room. The code also loads a graph from a pickled file using the LongTermGraph class, and uses the compute_metric_map and draw_metric_map functions to display the graph's metric map and point locations.",
        "items": [
          {
            "id": "d3824e62-3401-2c9e-394e-2ee9ee755e69",
            "ancestors": [],
            "description": "Generates a graph based on a provided adjacency matrix using Kamada-Kawai layout algorithm, and adds node names and edges with arrowheads.",
            "params": [
              {
                "name": "graph",
                "type_name": "AbstractGraph",
                "description": "Used to represent a graph object that contains vertices and edges."
              }
            ],
            "returns": null,
            "name": "draw_graph",
            "location": {
              "start": 6,
              "insert": 7,
              "offset": " ",
              "indent": 4,
              "comment": null
            },
            "item_type": "function",
            "length": 24,
            "docLength": null
          },
          {
            "id": "d7906eb3-709a-3c95-7c40-18ce0ab8dcfd",
            "ancestors": [],
            "description": "Searches through a graph's edges for an edge with a specific attribute equal to a given value. If such an edge is found, it returns it; otherwise, it returns `None`.",
            "params": [
              {
                "name": "graph",
                "type_name": "Graph",
                "description": "Represented as an object that contains a collection of edges, where each edge represents a connection between two nodes in the graph."
              },
              {
                "name": "attribute",
                "type_name": "attribute",
                "description": "Used to specify the attribute of interest for finding an edge in a graph."
              },
              {
                "name": "value",
                "type_name": "object",
                "description": "Used to search for an edge in a graph based on a specific attribute."
              }
            ],
            "returns": {
              "type_name": "edge",
              "description": "An untyped reference to a graph edge that has the specified attribute equal to the provided value."
            },
            "name": "find_edge_with_attribute",
            "location": {
              "start": 41,
              "insert": 42,
              "offset": " ",
              "indent": 4,
              "comment": null
            },
            "item_type": "function",
            "length": 5,
            "docLength": null
          },
          {
            "id": "fe2cae8a-54a8-32a7-014a-24ebf3a8e0f2",
            "ancestors": [],
            "description": "Iterates over the edges in a graph and adds to an output list any edge connecting nodes with \"door\" in their names.",
            "params": [
              {
                "name": "graph",
                "type_name": "Graph",
                "description": "Represented as g, which contains a collection of nodes and edges that define a graph structure."
              }
            ],
            "returns": {
              "type_name": "list",
              "description": "A collection of edges from the given graph."
            },
            "name": "get_room_edges",
            "location": {
              "start": 47,
              "insert": 48,
              "offset": " ",
              "indent": 4,
              "comment": null
            },
            "item_type": "function",
            "length": 10,
            "docLength": null
          },
          {
            "id": "e9acd19c-513f-f78e-4949-cd353d1b9b16",
            "ancestors": [],
            "description": "In Java code recursively queries the graph for all nodes connected to a given node via doors, returning a list of such nodes.",
            "params": [
              {
                "name": "graph",
                "type_name": "Graph",
                "description": "Used to represent a graph structure."
              },
              {
                "name": "node",
                "type_name": "GraphNode",
                "description": "Referred to as a node in the graph."
              }
            ],
            "returns": {
              "type_name": "list",
              "description": "A collection of nodes that are connected to a specific node through doors."
            },
            "name": "get_connected_door_nodes",
            "location": {
              "start": 58,
              "insert": 60,
              "offset": " ",
              "indent": 4,
              "comment": null
            },
            "item_type": "function",
            "length": 10,
            "docLength": null
          },
          {
            "id": "9a2a2e72-8415-229d-6c4a-657476ccda61",
            "ancestors": [],
            "description": "Navigates through a graph by starting from a given room and visiting all other rooms reachable through doors. It keeps track of visited rooms using a list and prints information about each room it visits.",
            "params": [
              {
                "name": "graph",
                "type_name": "Graph",
                "description": "Used to represent a graph with nodes and edges."
              },
              {
                "name": "current_room",
                "type_name": "dict",
                "description": "Represents the current room to be traversed in the graph."
              },
              {
                "name": "visited",
                "type_name": "list",
                "description": "Used to keep track of the rooms that have been visited during the traversal process, initialized to an empty list if None."
              }
            ],
            "returns": {
              "type_name": "list",
              "description": "A collection of strings representing the rooms that have been visited."
            },
            "name": "traverse_graph",
            "location": {
              "start": 74,
              "insert": 75,
              "offset": " ",
              "indent": 4,
              "comment": null
            },
            "item_type": "function",
            "length": 17,
            "docLength": null
          }
        ]
      }
    }
  },
  {
    "name": "genericworker.py",
    "path": "agents/long_term_spatial_memory_agent/src/genericworker.py",
    "content": {
      "structured": {
        "description": "A worker class that inherits from QtWidgets.QWidget and implements a timer-based mechanism for killing itself after a specified period. It also provides a signal kill to allow for handling of the termination from outside the worker. The code uses PySide2, Ice, and the RoboCompCommonBehavior module.",
        "items": [
          {
            "id": "8a50128c-009f-a1ac-2c45-674f0e62438e",
            "ancestors": [],
            "description": "Manages a timer and a signal to stop its own execution. It has methods to change the timer period and to emit the signal to stop itself.",
            "attributes": [
              {
                "name": "kill",
                "type_name": "QtCoreQObjectSlot",
                "description": "Used to emit a signal that can be caught by any connected slots to stop the worker's execution."
              },
              {
                "name": "ui",
                "type_name": "Ui_guiDlg",
                "description": "Used to setup the user interface of the class."
              },
              {
                "name": "mutex",
                "type_name": "QMutex",
                "description": "Used to protect the worker's state from concurrent access."
              },
              {
                "name": "Period",
                "type_name": "int",
                "description": "Used to set the time interval for the timer signal emitted by the `setPeriod()` method, which changes its value on each call."
              },
              {
                "name": "timer",
                "type_name": "QtCoreQTimer",
                "description": "Used to start a timer that emits the `kill` signal after a specified period."
              }
            ],
            "name": "GenericWorker",
            "location": {
              "start": 43,
              "insert": 45,
              "offset": " ",
              "indent": 4,
              "comment": null
            },
            "item_type": "class",
            "length": 26,
            "docLength": null
          },
          {
            "id": "dc756aa5-ebc6-5490-d649-854bb2ac26a4",
            "ancestors": [
              "8a50128c-009f-a1ac-2c45-674f0e62438e"
            ],
            "description": "Initializes an object of the `GenericWorker` class, setting up a UI widget, creating a mutex for synchronization, and defining a timer with a period of 500 milliseconds.",
            "params": [
              {
                "name": "mprx",
                "type_name": "Ui_guiDlg",
                "description": "Used as the parent widget for the GenericWorker object's UI."
              }
            ],
            "returns": null,
            "name": "__init__",
            "location": {
              "start": 47,
              "insert": 48,
              "offset": " ",
              "indent": 8,
              "comment": null
            },
            "item_type": "method",
            "length": 9,
            "docLength": null
          },
          {
            "id": "17fccd3d-bcc7-a9a3-5f45-73125f7d1f78",
            "ancestors": [
              "8a50128c-009f-a1ac-2c45-674f0e62438e"
            ],
            "description": "Emits the `kill` signal, indicating that the object should be terminated.",
            "params": [],
            "returns": null,
            "name": "killYourSelf",
            "location": {
              "start": 60,
              "insert": 62,
              "offset": " ",
              "indent": 8,
              "comment": null
            },
            "item_type": "method",
            "length": 4,
            "docLength": null
          },
          {
            "id": "a2ebb705-7932-fb9b-3e45-f965c61ebf4d",
            "ancestors": [
              "8a50128c-009f-a1ac-2c45-674f0e62438e"
            ],
            "description": "Sets the period of a timer and updates the internal variable `Period`.",
            "params": [
              {
                "name": "p",
                "type_name": "int",
                "description": "Used to set the new period for the timer."
              }
            ],
            "returns": null,
            "name": "setPeriod",
            "location": {
              "start": 67,
              "insert": 69,
              "offset": " ",
              "indent": 8,
              "comment": null
            },
            "item_type": "method",
            "length": 5,
            "docLength": null
          }
        ]
      }
    }
  },
  {
    "name": "specificworker.py",
    "path": "agents/long_term_spatial_memory_agent/src/specificworker.py",
    "content": {
      "structured": {
        "description": "A class that represents an agent in a robot's environment. The agent uses graph theory and spatial reasoning to navigate through rooms, identify doors, and recognize patterns. The code utilizes igraph for graph manipulation and visualization, and NumPy for numerical computations. It also incorporates various functions for node and edge creation, updating, and deletion, as well as edge attributes modification and room image generation.",
        "items": [
          {
            "id": "895186b9-f902-39ab-ec46-de7001893323",
            "ancestors": [],
            "description": "Simulates a robot navigating through a virtual environment by traversing a graph, updating node and edge attributes, and performing tasks such as door associations, room creation, and path planning.",
            "attributes": [
              {
                "name": "Period",
                "type_name": "None",
                "description": "100 by default, indicating a period of time (in milliseconds) for computing tasks. It is used to set the timer interval for periodic computations."
              },
              {
                "name": "agent_id",
                "type_name": "int",
                "description": "13, which represents the ID of a specific agent in the robotic environment. It is used as an identifier for the agent's internal graph."
              },
              {
                "name": "g",
                "type_name": "igraphGraph",
                "description": "Used to interact with the graph library igraph. It contains methods to insert, delete, update nodes and edges in the graph, as well as traverse the graph."
              },
              {
                "name": "startup_check",
                "type_name": "None|bool",
                "description": "Set by default to None. It is a simple flag that is used for checking if the startup process has completed successfully."
              },
              {
                "name": "rt_api",
                "type_name": "object",
                "description": "Used to get edge RT (Rotation and Translation) from the `room_exit_door_id` to the robot node."
              },
              {
                "name": "inner_api",
                "type_name": "object",
                "description": "Used for internal API operations, likely related to robot pose transformations, door connections, or other internal mechanisms. The exact functionality depends on the implementation details."
              },
              {
                "name": "testing",
                "type_name": "Attribute",
                "description": "2. It seems to be used as a flag for testing mode, controlling certain behavior or actions within the class."
              },
              {
                "name": "robot_name",
                "type_name": "str",
                "description": "Used as a name for the robot node in the graph. It appears to be used to identify the robot's location within the graph."
              },
              {
                "name": "robot_id",
                "type_name": "int",
                "description": "13, as initialized in the `__init__` method. It appears to be a unique identifier for the robot node in the graph."
              },
              {
                "name": "last_robot_pose",
                "type_name": "npfloat64",
                "description": "3-dimensional, representing the last known pose (position and orientation) of the robot in the room. It is used to store the previous position of the robot before updating it with new data."
              },
              {
                "name": "robot_exit_pose",
                "type_name": "npndarray[npfloat64,1D]",
                "description": "3-dimensional representing a pose (x, y, z) of the robot when exiting a room. It stores the final affordance pose transformed to the global reference system."
              },
              {
                "name": "state",
                "type_name": "str|None",
                "description": "Used to keep track of the current state of the worker, such as \"idle\", \"crossing\", \"known_room\", etc., which determines how it should behave in different situations."
              },
              {
                "name": "affordance_node_active_id",
                "type_name": "int",
                "description": "13 by default, which corresponds to the agent's ID. This variable seems to keep track of the active affordance node in the graph."
              },
              {
                "name": "exit_door_id",
                "type_name": "int",
                "description": "Used as a reference to identify the ID of the door that represents the exit from a room."
              },
              {
                "name": "room_exit_door_id",
                "type_name": "int",
                "description": "13, as specified in the class initialization method (`__init__`). It represents the ID of the exit door node in the graph."
              },
              {
                "name": "enter_room_node_id",
                "type_name": "int",
                "description": "Set when a new room is entered. It holds the ID of the node that represents the current room being explored by the robot."
              },
              {
                "name": "vertex_size",
                "type_name": "int",
                "description": "0 initially. It increments by 1 each time a new vertex (node) is inserted into the graph, keeping track of the number of vertices created so far."
              },
              {
                "name": "not_required_attrs",
                "type_name": "List[str]",
                "description": "Used to store the names of attributes that are not required for vertex objects in the graph, such as \"parent\", \"timestamp_alivetime\", etc. These attributes are ignored when inserting vertices into the graph."
              },
              {
                "name": "last_save_time",
                "type_name": "float",
                "description": "Used to store the timestamp when the worker's state was last saved or updated."
              },
              {
                "name": "long_term_graph",
                "type_name": "igraphGraph",
                "description": "Used to store and manipulate the long-term graph data structure, which represents the agent's internal model of its environment."
              },
              {
                "name": "room_number",
                "type_name": "int",
                "description": "1-based indexing for the room ID. It represents the unique identifier of a room node in the graph data structure."
              },
              {
                "name": "room_number_limit",
                "type_name": "None|int",
                "description": "0 by default. It seems to be related to the limit of rooms in a generated apartment, used for procedural room generation."
              },
              {
                "name": "insert_current_edge",
                "type_name": "None",
                "description": "Used to set a current edge between two nodes in the graph, updating the room state to idle."
              },
              {
                "name": "pending_doors_to_stabilize",
                "type_name": "List[tuple[str,str]]",
                "description": "Initialized with a deque(maxlen=10) to store door names to be stabilized later. It keeps track of doors that need to be connected in the graph based on certain conditions."
              },
              {
                "name": "timer",
                "type_name": "QTimer",
                "description": "Used for scheduling the execution of a method after a certain time delay or interval (set by the `start` method)."
              },
              {
                "name": "compute",
                "type_name": "None|Callable[[Any],Any]",
                "description": "Used as a slot for handling timer events. It contains a method that gets called at regular intervals, performing specific tasks depending on the state of the worker."
              },
              {
                "name": "update_node",
                "type_name": "None|int,str",
                "description": "Used to update a node with the given id and type."
              },
              {
                "name": "update_edge",
                "type_name": "NoneNonefrint,toint,typestr",
                "description": "Used to update edges in the graph, specifically when the edge's destination is the robot ID, source node is not the room exit door, type is \"RT\" and there are no current edges."
              }
            ],
            "name": "SpecificWorker",
            "location": {
              "start": 52,
              "insert": 53,
              "offset": " ",
              "indent": 4,
              "comment": null
            },
            "item_type": "class",
            "length": 699,
            "docLength": null
          },
          {
            "id": "f43929f0-c77b-5d99-7d40-e09555e1a3ab",
            "ancestors": [
              "895186b9-f902-39ab-ec46-de7001893323"
            ],
            "description": "Initializes various attributes, sets up graph data structures, and connects signals to methods for updating nodes and edges. It also starts a timer that triggers the compute method at regular intervals.",
            "params": [
              {
                "name": "proxy_map",
                "type_name": "object",
                "description": "Passed to the superclass constructor using the `super()` function, indicating that it should be used for initialization. Its purpose and content are not specified within this code block."
              },
              {
                "name": "startup_check",
                "type_name": "bool",
                "description": "Set to False by default. It determines whether a startup check should be performed or not. If set to True, it calls the `startup_check` method; otherwise, it initializes the other parts of the class."
              }
            ],
            "returns": null,
            "usage": {
              "language": "python",
              "code": "specific_worker = SpecificWorker(proxy_map, startup_check=True)\n",
              "description": "\nNote that this example only shows a basic usage of the class without any specific parameters."
            },
            "name": "__init__",
            "location": {
              "start": 53,
              "insert": 54,
              "offset": " ",
              "indent": 8,
              "comment": null
            },
            "item_type": "constructor",
            "length": 65,
            "docLength": null
          },
          {
            "id": "49b3ce54-b2b8-e8ac-844b-ec91e99feeab",
            "ancestors": [
              "895186b9-f902-39ab-ec46-de7001893323"
            ],
            "description": "Sets parameters for a scenario and performs subsequent actions on doors, including removing self-edges, storing door IDs, updating door attributes, and adding an attribute to an entrance door node.",
            "params": [
              {
                "name": "params",
                "type_name": "Dict[any, any]",
                "description": "Expected to contain various parameters used for setting up the current room state in the game."
              }
            ],
            "returns": {
              "type_name": "bool",
              "description": "True."
            },
            "usage": {
              "language": "python",
              "code": "worker = SpecificWorker(proxy_map, startup_check=False)\nparams = {\"agent_id\": 13, \"robot_name\": \"Shadow\"}\nresult = worker.setParams(params)",
              "description": ""
            },
            "name": "setParams",
            "location": {
              "start": 147,
              "insert": 148,
              "offset": " ",
              "indent": 8,
              "comment": null
            },
            "item_type": "method",
            "length": 9,
            "docLength": null
          },
          {
            "id": "565d28ea-34ad-14ae-2d4a-eea4ebaac461",
            "ancestors": [
              "895186b9-f902-39ab-ec46-de7001893323"
            ],
            "description": "Computes the position and orientation of rooms and doors, generates JSON data for each room, saves it to a file, and then terminates the process if testing mode is enabled.",
            "params": [],
            "returns": null,
            "usage": {
              "language": "python",
              "code": "worker = SpecificWorker(proxy_map)\nwhile True:\n    worker.compute()\n    time.sleep(worker.Period)",
              "description": ""
            },
            "name": "compute",
            "location": {
              "start": 163,
              "insert": 169,
              "offset": " ",
              "indent": 8,
              "comment": null
            },
            "item_type": "method",
            "length": 60,
            "docLength": null
          },
          {
            "id": "b693ac11-a005-33bb-6c45-152db71efd4e",
            "ancestors": [
              "895186b9-f902-39ab-ec46-de7001893323"
            ],
            "description": "Initializes a room structure from an igraph object, creates a root node and edges, updates node attributes, and inserts or assigns new edges into the graph.",
            "params": [],
            "returns": null,
            "usage": {
              "language": "python",
              "code": "worker = SpecificWorker(proxy_map, startup_check=True)\nworker.initialize_room_from_igraph()\n",
              "description": ""
            },
            "name": "initialize_room_from_igraph",
            "location": {
              "start": 237,
              "insert": 239,
              "offset": " ",
              "indent": 8,
              "comment": null
            },
            "item_type": "method",
            "length": 22,
            "docLength": null
          },
          {
            "id": "b242f7eb-eb84-9880-b745-8ba8bec9e950",
            "ancestors": [
              "895186b9-f902-39ab-ec46-de7001893323"
            ],
            "description": "Updates the robot's pose in an igraph graph by reflecting changes from a long-term graph to the current graph and saving the updated graph. It handles cases where the robot moves between rooms or when it is not found in the igraph.",
            "params": [],
            "returns": null,
            "usage": {
              "language": "python",
              "code": "sw = SpecificWorker(proxy_map, startup_check=True)\nsw.update_robot_pose_in_igraph()\n",
              "description": "\n\nThis code initializes a SpecificWorker object with proxy_map and sets the startup_check to True. It then calls the update_robot_pose_in_igraph method on this object."
            },
            "name": "update_robot_pose_in_igraph",
            "location": {
              "start": 270,
              "insert": 272,
              "offset": " ",
              "indent": 8,
              "comment": null
            },
            "item_type": "method",
            "length": 41,
            "docLength": null
          },
          {
            "id": "bced392b-adf3-4a9f-ed49-12d2abc2f0d9",
            "ancestors": [
              "895186b9-f902-39ab-ec46-de7001893323"
            ],
            "description": "Handles affordance nodes, stabilizes doors, and computes robot poses for crossing between rooms. It updates the graph state and prints relevant information during its execution.",
            "params": [],
            "returns": null,
            "usage": {
              "language": "python",
              "code": "worker = SpecificWorker(proxy_map, startup_check=True)\nworker.idle()\n",
              "description": "\nThis code snippet creates a specific worker object and then invokes its idle method. The idle method performs some checks based on the worker's state and graph data, and if certain conditions are met, it may update the worker's state to \"crossing\"."
            },
            "name": "idle",
            "location": {
              "start": 323,
              "insert": 325,
              "offset": " ",
              "indent": 8,
              "comment": null
            },
            "item_type": "method",
            "length": 86,
            "docLength": null
          },
          {
            "id": "4b50aa68-287c-e0a6-094a-b49300e80dd5",
            "ancestors": [
              "895186b9-f902-39ab-ec46-de7001893323"
            ],
            "description": "Updates the room state and door connections based on the current affordance node and exit door node in the graph.",
            "params": [],
            "returns": null,
            "usage": {
              "language": "python",
              "code": "worker = SpecificWorker(proxy_map)\nworker.crossed()\n",
              "description": "\nThis code creates an instance of the class SpecificWorker, and then calls its method crossed."
            },
            "name": "crossed",
            "location": {
              "start": 436,
              "insert": 438,
              "offset": " ",
              "indent": 8,
              "comment": null
            },
            "item_type": "method",
            "length": 16,
            "docLength": null
          },
          {
            "id": "f0eea51e-80ec-3382-9845-e7ae11931b76",
            "ancestors": [
              "895186b9-f902-39ab-ec46-de7001893323"
            ],
            "description": "Retrieves a list of room nodes, selects the first node, sets it as the current room, and inserts an edge representing this change into a graph. The method then changes its internal state to \"initializing_doors\" and prints a status message.",
            "params": [],
            "returns": null,
            "usage": {
              "language": "python",
              "code": "specific_worker = SpecificWorker(proxy_map, startup_check=True)\nspecific_worker.initializing_room()\n",
              "description": ""
            },
            "name": "initializing_room",
            "location": {
              "start": 456,
              "insert": 459,
              "offset": " ",
              "indent": 8,
              "comment": null
            },
            "item_type": "method",
            "length": 10,
            "docLength": null
          },
          {
            "id": "b33bb58f-ff15-99bd-bf41-461d97919761",
            "ancestors": [
              "895186b9-f902-39ab-ec46-de7001893323"
            ],
            "description": "Navigates from the current room to another connected room through an exit door, updates the graph representation of the new room and door, and adjusts the robot's position and orientation accordingly.",
            "params": [],
            "returns": null,
            "usage": {
              "language": "python",
              "code": "worker = SpecificWorker(proxy_map)\nworker.known_room()\n",
              "description": "\nThis will start executing the method known_room, passing no arguments. The worker class object must have been previously instantiated and initialized properly before calling this function."
            },
            "name": "known_room",
            "location": {
              "start": 470,
              "insert": 472,
              "offset": " ",
              "indent": 8,
              "comment": null
            },
            "item_type": "method",
            "length": 73,
            "docLength": null
          },
          {
            "id": "09302d92-1220-46a5-564c-abb4ed5068ba",
            "ancestors": [
              "895186b9-f902-39ab-ec46-de7001893323"
            ],
            "description": "Initializes and associates exit doors with their corresponding rooms, storing the door names and connected room names as attributes. It also updates the graph and sets a state to \"removing\".",
            "params": [],
            "returns": null,
            "usage": {
              "language": "python",
              "code": "worker = SpecificWorker(None, startup_check=False)\nworker.exit_door_id = 123\nworker.initializing_doors()",
              "description": ""
            },
            "name": "initializing_doors",
            "location": {
              "start": 564,
              "insert": 566,
              "offset": " ",
              "indent": 8,
              "comment": null
            },
            "item_type": "method",
            "length": 26,
            "docLength": null
          },
          {
            "id": "860d158e-bcd7-bbb3-ff4f-c34b26f5454f",
            "ancestors": [
              "895186b9-f902-39ab-ec46-de7001893323"
            ],
            "description": "Associates two doors by adding an edge between their corresponding nodes in the long-term graph, and sets additional attributes on each node to store information about the other door and connected room.",
            "params": [
              {
                "name": "door_1",
                "type_name": "Tuple[str, str]",
                "description": "Expected to represent a pair of door names with connected rooms' names as its elements."
              },
              {
                "name": "door_2",
                "type_name": "Tuple[str, str]",
                "description": "Expected to contain the name of the second door and its connected room. It is used to find the node corresponding to this door in the graph and associate it with the first door."
              }
            ],
            "returns": null,
            "usage": {
              "language": "python",
              "code": "worker = SpecificWorker(None)\ndoor_1 = (\"Door 1\", \"Room A\", 123)\ndoor_2 = (\"Door 2\", \"Room B\", 456)\nworker.associate_doors(door_1, door_2)",
              "description": ""
            },
            "name": "associate_doors",
            "location": {
              "start": 601,
              "insert": 603,
              "offset": " ",
              "indent": 8,
              "comment": null
            },
            "item_type": "method",
            "length": 20,
            "docLength": null
          },
          {
            "id": "7d9e23ea-fe30-b6b7-f846-d999e5057864",
            "ancestors": [
              "895186b9-f902-39ab-ec46-de7001893323"
            ],
            "description": "Stores the current state of a graph, represented by an igraph object, into a pickle file named \"graph.pkl\". It first retrieves and verifies the existence of a room node in the graph before storing it.",
            "params": [],
            "returns": null,
            "usage": {
              "language": "python",
              "code": "worker = SpecificWorker(proxy_map, startup_check=True)\nworker.store_graph()",
              "description": ""
            },
            "name": "store_graph",
            "location": {
              "start": 624,
              "insert": 625,
              "offset": " ",
              "indent": 8,
              "comment": null
            },
            "item_type": "method",
            "length": 11,
            "docLength": null
          },
          {
            "id": "242f4fee-7403-e2be-6f4d-a278ec8a96c9",
            "ancestors": [
              "895186b9-f902-39ab-ec46-de7001893323"
            ],
            "description": "Deletes nodes and edges from the graph based on certain conditions. It first identifies nodes connected to a specified room exit door, then removes nodes with no outgoing edges and finally removes destinations of remaining edges sorted by their values in descending order.",
            "params": [],
            "returns": null,
            "usage": {
              "language": "python",
              "code": "worker = SpecificWorker(proxy_map, startup_check=True)\nworker.removing()",
              "description": ""
            },
            "name": "removing",
            "location": {
              "start": 638,
              "insert": 640,
              "offset": " ",
              "indent": 8,
              "comment": null
            },
            "item_type": "method",
            "length": 19,
            "docLength": null
          },
          {
            "id": "77fff487-b57f-4fa4-1d44-3789f5a13b53",
            "ancestors": [
              "895186b9-f902-39ab-ec46-de7001893323"
            ],
            "description": "Recursively traverses a graph, starting from a specified node, and inserts nodes and edges into an igraph object. It identifies RT-type edges with destinations other than the robot ID and explores them further.",
            "params": [
              {
                "name": "node_id",
                "type_name": "int",
                "description": "Expected to be an identifier for a node within the graph data structure (`self.g`)."
              }
            ],
            "returns": null,
            "usage": {
              "language": "python",
              "code": "worker = SpecificWorker(proxy_map)\nnode_id = 5\nworker.traverse_graph(node_id)",
              "description": ""
            },
            "name": "traverse_graph",
            "location": {
              "start": 664,
              "insert": 666,
              "offset": " ",
              "indent": 8,
              "comment": null
            },
            "item_type": "method",
            "length": 7,
            "docLength": null
          },
          {
            "id": "edceaa7c-333f-dd99-9e44-b9bdbae031be",
            "ancestors": [
              "895186b9-f902-39ab-ec46-de7001893323"
            ],
            "description": "Traverses the long-term graph, starting from a given node, and recursively explores its successors, inserting new vertices and edges into a data structure whenever it finds a suitable successor with higher level and same room_id as the current node.",
            "params": [
              {
                "name": "node",
                "type_name": "igraph.vs",
                "description": "Passed to this function. It represents an individual vertex (node) within the graph and contains information about the node, such as its index, name, room_id, and level."
              }
            ],
            "returns": null,
            "usage": {
              "language": "python",
              "code": "worker = SpecificWorker(None, startup_check=False)\nnode = worker.long_term_graph.get_node(\"Initial Room\")\nworker.traverse_igraph(node)",
              "description": ""
            },
            "name": "traverse_igraph",
            "location": {
              "start": 674,
              "insert": 675,
              "offset": " ",
              "indent": 8,
              "comment": null
            },
            "item_type": "method",
            "length": 10,
            "docLength": null
          },
          {
            "id": "a71b8f95-8dea-f190-3143-5b6d1f0a1dfd",
            "ancestors": [
              "895186b9-f902-39ab-ec46-de7001893323"
            ],
            "description": "Adds a vertex to an igraph graph object, long_term_graph.g, with attributes from a given node object. It also checks for specific attributes and adds edges between vertices if necessary.",
            "params": [
              {
                "name": "node",
                "type_name": "object",
                "description": "Assumed to have attributes such as `name`, `id`, `type`, and possibly others like `attrs`. The `node` parameter is used to add vertices to an igraph graph and also potentially establish edges between them."
              }
            ],
            "returns": null,
            "usage": {
              "language": "python",
              "code": "specific_worker = SpecificWorker(proxy_map, startup_check=True)\nnode = Node(name='room1', id=1, type='room')\nnode.attrs['connected_room_name'] = ConnectedRoomName('other_room', 'door1')\nnode.attrs['other_side_door_name'] = OtherSideDoorName('door2', 'other_side_door_name')\nspecific_worker.insert_igraph_vertex(node)",
              "description": ""
            },
            "name": "insert_igraph_vertex",
            "location": {
              "start": 687,
              "insert": 688,
              "offset": " ",
              "indent": 8,
              "comment": null
            },
            "item_type": "method",
            "length": 29,
            "docLength": null
          },
          {
            "id": "021e56e0-815f-d9a6-5343-d8f2a6d2e7bd",
            "ancestors": [
              "895186b9-f902-39ab-ec46-de7001893323"
            ],
            "description": "Inserts a new node into a graph, creating it from a given dictionary and linking it to an existing parent node with the provided name. It also copies over some attributes from the original node.",
            "params": [
              {
                "name": "parent_name",
                "type_name": "str",
                "description": "Used to get an existing node from the graph using its name, which is then used as the parent for the new vertex being inserted into the graph."
              },
              {
                "name": "node",
                "type_name": "Dict",
                "description": "Expected to contain attributes such as \"type\", \"name\" that are used to create a new Node object. The values in this dictionary are used to set the properties of the newly created node."
              }
            ],
            "returns": null,
            "usage": {
              "language": "python",
              "code": "specific_worker = SpecificWorker(proxy_map, startup_check=False)\ndsr_node = {\"type\": \"vertex\", \"name\": \"new_vertex\", \"attributes\": {\"color\": \"red\"}}\nspecific_worker.insert_dsr_vertex(\"parent_name\", dsr_node)",
              "description": ""
            },
            "name": "insert_dsr_vertex",
            "location": {
              "start": 722,
              "insert": 724,
              "offset": " ",
              "indent": 8,
              "comment": null
            },
            "item_type": "method",
            "length": 9,
            "docLength": null
          },
          {
            "id": "1c8acec2-134d-5faf-3c43-92947a256819",
            "ancestors": [
              "895186b9-f902-39ab-ec46-de7001893323"
            ],
            "description": "Inserts an edge into the long-term graph based on the origin and destination nodes, considering translation and rotation attributes from the provided edge. It also applies special handling for door destinations.",
            "params": [
              {
                "name": "edge",
                "type_name": "object",
                "description": "Likely an instance of a class representing an edge in a graph, possibly containing information about its origin, destination, translation, rotation, and other attributes."
              }
            ],
            "returns": null,
            "usage": {
              "language": "python",
              "code": "worker = SpecificWorker(proxy_map, startup_check=False)\nedge = Edge(origin=\"room1\", destination=\"door1\")\nworker.insert_igraph_edge(edge)",
              "description": ""
            },
            "name": "insert_igraph_edge",
            "location": {
              "start": 736,
              "insert": 737,
              "offset": " ",
              "indent": 8,
              "comment": null
            },
            "item_type": "method",
            "length": 15,
            "docLength": null
          },
          {
            "id": "30527036-60e3-8886-a946-2f1b41d32ef6",
            "ancestors": [
              "895186b9-f902-39ab-ec46-de7001893323"
            ],
            "description": "Inserts or updates an edge between two nodes in a graph based on whether one node (org) exists or not. It retrieves relevant data, creates a new edge with attributes and inserts/assigns it to the graph.",
            "params": [
              {
                "name": "org",
                "type_name": "object | None",
                "description": "Used to specify whether a root node should be created or an existing node from which to create a new edge."
              },
              {
                "name": "dest",
                "type_name": "Dict[str, int]",
                "description": "Used to represent a destination node in the graph. It contains a \"name\" key with a string value representing the name of the node, and an \"index\" key with an integer value representing the index of the node."
              }
            ],
            "returns": null,
            "usage": {
              "language": "python",
              "code": "specific_worker = SpecificWorker(proxy_map, startup_check=True)\norg = Node(\"room1\", \"room\")\ndest = Node(\"door2\", \"door\")\nspecific_worker.insert_dsr_edge(org, dest)",
              "description": ""
            },
            "name": "insert_dsr_edge",
            "location": {
              "start": 757,
              "insert": 760,
              "offset": " ",
              "indent": 8,
              "comment": null
            },
            "item_type": "method",
            "length": 22,
            "docLength": null
          },
          {
            "id": "b71963ca-d296-d386-3542-ca6aca921929",
            "ancestors": [
              "895186b9-f902-39ab-ec46-de7001893323"
            ],
            "description": "Retrieves the room ID associated with a node identified by its node ID from a graph, and returns it if found; otherwise, it returns -1. The method handles potential exceptions that may occur during the retrieval process.",
            "params": [
              {
                "name": "node_id",
                "type_name": "int | str",
                "description": "Required for this function. It represents an identifier that uniquely identifies a node within a graph data structure."
              }
            ],
            "returns": {
              "type_name": "str|int",
              "description": "Either a room ID associated with a node or -1 if no room ID is found for that node."
            },
            "usage": {
              "language": "python",
              "code": "worker = SpecificWorker(None, startup_check=False)\nroom_id = worker.check_element_room_number(\"node123\")\n",
              "description": "\nThis code creates an instance of the `SpecificWorker` class and then calls its `check_element_room_number` method with a specific node ID (`\"node123\"`). The function checks if the node has a \"room_id\" attribute, returns it if found, or -1 if not."
            },
            "name": "check_element_room_number",
            "location": {
              "start": 787,
              "insert": 788,
              "offset": " ",
              "indent": 8,
              "comment": null
            },
            "item_type": "method",
            "length": 7,
            "docLength": null
          },
          {
            "id": "71c5bfb8-3835-7788-9042-be2ab507cbc5",
            "ancestors": [
              "895186b9-f902-39ab-ec46-de7001893323"
            ],
            "description": "Retrieves an element level from the attributes of a node with the given ID in the graph, and returns it if found; otherwise, prints an error message and returns -1.",
            "params": [
              {
                "name": "node_id",
                "type_name": "object",
                "description": "Expected to be the ID of a node stored in the graph `self.g`. It is used to retrieve information about the node from the graph."
              }
            ],
            "returns": {
              "type_name": "int|str",
              "description": "1) the value of \"level\" attribute of node with given id if present, or 2) -1 and a print statement indicating that no such attribute was found."
            },
            "usage": {
              "language": "python",
              "code": "worker = SpecificWorker(proxy_map, startup_check=False)\nnode_id = \"my_node\"\nelement_level = worker.check_element_level(node_id)\nif element_level == -1:\n    # handle node with no element_level attribute\nelse:\n    # use the retrieved element_level value",
              "description": ""
            },
            "name": "check_element_level",
            "location": {
              "start": 796,
              "insert": 797,
              "offset": " ",
              "indent": 8,
              "comment": null
            },
            "item_type": "method",
            "length": 25,
            "docLength": null
          },
          {
            "id": "8d17504d-3d97-6684-5142-8bb1f661e2e4",
            "ancestors": [
              "895186b9-f902-39ab-ec46-de7001893323"
            ],
            "description": "Retrieves information about a given room node, identifies edges of type \"RT\" that are connected to it, and extracts translation data from these edges.",
            "params": [
              {
                "name": "room_node_id",
                "type_name": "int",
                "description": "Used to retrieve a specific node from a graph object (`self.g`). This node represents a room, and its id is needed to generate a picture for this room."
              }
            ],
            "returns": null,
            "usage": {
              "language": "python",
              "code": "worker = SpecificWorker(proxy_map, startup_check=False)\nroom_node_id = 1234\nworker.generate_room_picture(room_node_id)",
              "description": ""
            },
            "name": "generate_room_picture",
            "location": {
              "start": 839,
              "insert": 841,
              "offset": " ",
              "indent": 8,
              "comment": null
            },
            "item_type": "method",
            "length": 24,
            "docLength": null
          },
          {
            "id": "0e858f9e-90d2-f5ac-9c4d-3bca8d1e9ec8",
            "ancestors": [
              "895186b9-f902-39ab-ec46-de7001893323"
            ],
            "description": "Inserts or updates an edge in a graph (self.g). The edge represents a current connection between two rooms with given IDs, identified by the agent ID. It is created based on room_id and its mirrored version.",
            "params": [
              {
                "name": "room_id",
                "type_name": "int",
                "description": "Required for the creation of an `Edge` object. It represents the ID of a room that will be part of the edge being inserted into the graph."
              }
            ],
            "returns": null,
            "usage": {
              "language": "python",
              "code": "worker = SpecificWorker(proxy_map, startup_check=False)\nroom_id = \"12345\"\nworker.insert_current_edge(room_id)",
              "description": ""
            },
            "name": "insert_current_edge",
            "location": {
              "start": 874,
              "insert": 876,
              "offset": " ",
              "indent": 8,
              "comment": null
            },
            "item_type": "method",
            "length": 3,
            "docLength": null
          },
          {
            "id": "5d2abf5a-2590-8e8d-3143-a0b3002108a3",
            "ancestors": [
              "895186b9-f902-39ab-ec46-de7001893323"
            ],
            "description": "Executes a shell script, sets its executable permissions, runs it with the argument 'true', and captures any output or errors.",
            "params": [],
            "returns": null,
            "usage": {
              "language": "python",
              "code": "specific_worker = SpecificWorker(proxy_map)\nspecific_worker.kill_everything()",
              "description": ""
            },
            "name": "kill_everything",
            "location": {
              "start": 879,
              "insert": 881,
              "offset": " ",
              "indent": 8,
              "comment": null
            },
            "item_type": "method",
            "length": 8,
            "docLength": null
          },
          {
            "id": "af096c0a-4c0c-e28b-6748-b352cae47b40",
            "ancestors": [
              "895186b9-f902-39ab-ec46-de7001893323"
            ],
            "description": "Updates the node with given id and type in the graph. If the type is \"door\", it inserts the door node into an igraph graph and adds edges between nodes. If the id matches the affordance node active id, it checks the state of the affordance node and changes its state if necessary.",
            "params": [
              {
                "name": "id",
                "type_name": "int",
                "description": "Used as an identifier for nodes in a graph, specifically to identify either a door node or an affordance node based on the value of the `type` parameter."
              },
              {
                "name": "type",
                "type_name": "str",
                "description": "Used to determine what action should be taken when updating a node with the given id. The valid values for this parameter are \"door\" or other types that may be added in the future."
              }
            ],
            "returns": null,
            "usage": {
              "language": "python",
              "code": "worker = SpecificWorker(proxy_map, startup_check=False)\ndoor_id = 42\nworker.update_node(door_id, \"door\")",
              "description": ""
            },
            "name": "update_node",
            "location": {
              "start": 902,
              "insert": 903,
              "offset": " ",
              "indent": 8,
              "comment": null
            },
            "item_type": "method",
            "length": 36,
            "docLength": null
          },
          {
            "id": "2f5f1ef6-a378-a8ba-2246-9cb42852f320",
            "ancestors": [
              "895186b9-f902-39ab-ec46-de7001893323"
            ],
            "description": "Updates the current edge when a specific condition is met: if there are no current edges, the update edge originates from the room exit door, and its type is \"RT\". It inserts the edge into the graph and prints a message.",
            "params": [
              {
                "name": "fr",
                "type_name": "int",
                "description": "Likely to represent the from ID, indicating the starting point of an edge in the graph."
              },
              {
                "name": "to",
                "type_name": "int",
                "description": "Used to specify the destination of an edge in a graph, which represents the ID of another node in the graph."
              },
              {
                "name": "type",
                "type_name": "str",
                "description": "Expected to be set with value \"RT\". This indicates that it is an exit door edge, which leads to the robot's current room."
              }
            ],
            "returns": null,
            "usage": {
              "language": "python",
              "code": "worker = SpecificWorker(proxy_map)\nworker.update_edge(42, 13, \"RT\")",
              "description": ""
            },
            "name": "update_edge",
            "location": {
              "start": 957,
              "insert": 961,
              "offset": " ",
              "indent": 8,
              "comment": null
            },
            "item_type": "method",
            "length": 5,
            "docLength": null
          }
        ]
      }
    }
  },
  {
    "name": "specificworker_sec.py",
    "path": "agents/long_term_spatial_memory_agent/src/specificworker_sec.py",
    "content": {
      "structured": {
        "description": "An igraph object `self` and implements various operations on a graph, including inserting nodes and edges, updating edge attributes, and deleting nodes and edges. The code uses the `igraph` package to perform these operations. Specifically, it inserts a node in the graph with a certain name and ID, updates the RT translation and rotation of an edge connecting two nodes, and deletes a node and edge from the graph. Additionally, it checks if an affordance node is active and sets the state to \"crossed\" if it is completed and not active.",
        "items": [
          {
            "id": "75233bfc-d379-5786-3e4d-6b16aa1599c4",
            "ancestors": [],
            "description": "Manages a graph representation of a robot navigating through a room, handling various actions such as inserting, updating, and deleting nodes and edges, as well as tracking the current state of the room.",
            "attributes": [
              {
                "name": "Period",
                "type_name": "Union[float,int]",
                "description": "Used to represent the time period for which the worker is active."
              },
              {
                "name": "agent_id",
                "type_name": "int|str",
                "description": "Used to store the unique identifier of the agent in the simulation."
              },
              {
                "name": "g",
                "type_name": "igraphGraph",
                "description": "Used to represent the graph of nodes and edges in the environment. It is used for various operations such as inserting, deleting, updating nodes and edges, and drawing the graph."
              },
              {
                "name": "update_node",
                "type_name": "Dict[str,Any]",
                "description": "Used to update the node attributes of a specific node in the graph based on its ID. It takes two arguments: `id` (int) which is the ID of the node to be updated, and `type` (str) which can be either \"door\" or \"room\" indicating whether the node is a door or room node. The function performs different actions depending on the type of node being updated."
              },
              {
                "name": "update_edge",
                "type_name": "Union[int,str]",
                "description": "Used to update the edge attributes of a robot-room pair based on certain conditions, such as when there is no current edge and the room node exists."
              },
              {
                "name": "startup_check",
                "type_name": "bool|str",
                "description": "Used to check if the worker should perform startup tasks such as inserting a node and edge for a room and robot, and setting the state to \"crossed\"."
              },
              {
                "name": "rt_api",
                "type_name": "str|int",
                "description": "Used to store the ID of the robot that the worker is associated with, allowing the worker to perform RT-based actions."
              },
              {
                "name": "inner_api",
                "type_name": "Dict[str,Any]",
                "description": "Used to store additional APIs that are specific to this worker."
              },
              {
                "name": "robot_name",
                "type_name": "str|int",
                "description": "Used to store the ID of the robot that the worker is associated with."
              },
              {
                "name": "robot_id",
                "type_name": "int",
                "description": "Used to identify the robot that the worker is controlling."
              },
              {
                "name": "last_robot_pose",
                "type_name": "Tuple[float,float,float]",
                "description": "Used to store the last known pose of the robot in the environment, which can be used for various tasks such as path planning and obstacle avoidance."
              },
              {
                "name": "robot_exit_pose",
                "type_name": "str|int",
                "description": "Used to store the exit pose of a robot, which is the position and orientation of the robot when it exits a room."
              },
              {
                "name": "state",
                "type_name": "str|int",
                "description": "Used to keep track of the worker's current state (either \"idle\", \"crossed\", or \"completed\")."
              },
              {
                "name": "affordance_node_active_id",
                "type_name": "int|bool",
                "description": "Used to keep track of the active affordance node ID in the graph. It is used to determine when the affordance node has been completed and can transition to the crossed state."
              },
              {
                "name": "exit_door_id",
                "type_name": "int|str",
                "description": "Used to keep track of the id of the door node that leads from a room to the outside world, which is used for various purposes such as routing, affordance detection, and edge insertion."
              },
              {
                "name": "room_exit_door_id",
                "type_name": "int|str",
                "description": "Used to represent the ID of the door node that marks the exit of a room in the graph. It is used for updating edges and inserting current edges."
              },
              {
                "name": "enter_room_node_id",
                "type_name": "int|str",
                "description": "Used to store the ID of the room node that the worker enters when it completes its task."
              },
              {
                "name": "vertex_size",
                "type_name": "float|int",
                "description": "Used to control the size of the vertices in the graph. It determines the width or height of each vertex in the graph, which can be useful for visualization purposes."
              },
              {
                "name": "not_required_attrs",
                "type_name": "List[str]",
                "description": "Used to store a list of attribute names that are not required for the worker's functionality, i.e., they are optional or non-essential attributes."
              },
              {
                "name": "long_term_graph",
                "type_name": "igraphGraph",
                "description": "Used to store the long-term graph of the environment, which can be different from the short-term graph represented by the `g` attribute."
              },
              {
                "name": "graph",
                "type_name": "igraphGraph",
                "description": "Used to store the current state of the graph, which can be updated and manipulated during the execution of the worker's methods."
              },
              {
                "name": "insert_current_edge",
                "type_name": "List[Edge]",
                "description": "Used to insert a new edge into the graph with the specified from and to nodes, and with the \"current\" type."
              },
              {
                "name": "timer",
                "type_name": "int|str",
                "description": "Used to store a timer for the worker, indicating how long it has been running."
              },
              {
                "name": "compute",
                "type_name": "str|int",
                "description": "Used to store the ID of the node that should be updated or inserted in the graph during computation."
              }
            ],
            "name": "SpecificWorker",
            "location": {
              "start": 49,
              "insert": 50,
              "offset": " ",
              "indent": 4,
              "comment": null
            },
            "item_type": "class",
            "length": 592,
            "docLength": null
          },
          {
            "id": "1652a875-3a7c-04b8-3944-add50b4df62e",
            "ancestors": [
              "75233bfc-d379-5786-3e4d-6b16aa1599c4"
            ],
            "description": "Initializes the worker's internal state, including its graph, node ID, and affordance node active ID. It also connects signals for updating nodes and edges and sets up a timer to call the `compute` method periodically.",
            "params": [
              {
                "name": "proxy_map",
                "type_name": "Dict[str, Any]",
                "description": "Used to store a map of proxy nodes for the specific worker."
              },
              {
                "name": "startup_check",
                "type_name": "bool",
                "description": "Used to check if the graph has already been initialized before creating its inner API. It is set to False by default, meaning no check is performed."
              }
            ],
            "returns": null,
            "usage": {
              "language": "python",
              "code": "# create an instance of SpecificWorker class\nspecific_worker = SpecificWorker(proxy_map, startup_check=False)\n\n# call the function to initialize the worker\nspecific_worker.__init__(proxy_map, startup_check=False)\n",
              "description": "\nIn this example, we create an instance of the `SpecificWorker` class and then call its `__init__` method with the required parameters. The `__init__` method initializes the worker by setting up the necessary connections to the Signals module, creating a new graph if it does not exist, and starting the timer for the computation."
            },
            "name": "__init__",
            "location": {
              "start": 50,
              "insert": 51,
              "offset": " ",
              "indent": 8,
              "comment": null
            },
            "item_type": "constructor",
            "length": 53,
            "docLength": null
          },
          {
            "id": "9e3a3660-ca76-efa0-424c-7384a6dfdac5",
            "ancestors": [
              "75233bfc-d379-5786-3e4d-6b16aa1599c4"
            ],
            "description": "Sets the parameters passed as an argument, then modifies the room by removing a self-edge and adding attributes to doors.",
            "params": [
              {
                "name": "params",
                "type_name": "bool",
                "description": "Passed to set the parameters of the Room object."
              }
            ],
            "returns": {
              "type_name": "bool",
              "description": "True."
            },
            "usage": {
              "language": "python",
              "code": "worker = SpecificWorker(proxy_map)\nworker.setParams({'Period': 50})\n",
              "description": "\nIn this example, we create a new instance of the SpecificWorker class and pass in a proxy map as an argument to its constructor. We then use the setParams method to update the Period attribute of the worker instance to 50."
            },
            "name": "setParams",
            "location": {
              "start": 124,
              "insert": 125,
              "offset": " ",
              "indent": 8,
              "comment": null
            },
            "item_type": "method",
            "length": 7,
            "docLength": null
          },
          {
            "id": "13115bf5-e637-5cb7-b343-250c1fd6afbf",
            "ancestors": [
              "75233bfc-d379-5786-3e4d-6b16aa1599c4"
            ],
            "description": "Computes the RT of a robot in a graph, taking into account the current edges and long-term graph information.",
            "params": [],
            "returns": null,
            "usage": {
              "language": "python",
              "code": "worker = SpecificWorker(proxy_map)\nworker.compute()\n",
              "description": "\nIn this example, the user creates an instance of the class SpecificWorker and calls its compute method to execute the code inside it."
            },
            "name": "compute",
            "location": {
              "start": 138,
              "insert": 141,
              "offset": " ",
              "indent": 8,
              "comment": null
            },
            "item_type": "method",
            "length": 37,
            "docLength": null
          },
          {
            "id": "592108b6-327e-ba98-1c49-e5b2b4fb8c1f",
            "ancestors": [
              "75233bfc-d379-5786-3e4d-6b16aa1599c4"
            ],
            "description": "Checks if there are any \"current\" edges or affordance nodes in the graph, and performs actions based on their existence.",
            "params": [],
            "returns": null,
            "usage": {
              "language": "python",
              "code": "# Creating an instance of the SpecificWorker class\nmy_worker = SpecificWorker(proxy_map=None, startup_check=False)\n\n# Calling the idle method with a loop that lasts for 10 seconds\nfor i in range(int(10000 / my_worker.Period)):\n    my_worker.idle()\n",
              "description": ""
            },
            "name": "idle",
            "location": {
              "start": 182,
              "insert": 184,
              "offset": " ",
              "indent": 8,
              "comment": null
            },
            "item_type": "method",
            "length": 76,
            "docLength": null
          },
          {
            "id": "6aed26f6-3473-6faa-7643-8146c8044dbe",
            "ancestors": [
              "75233bfc-d379-5786-3e4d-6b16aa1599c4"
            ],
            "description": "Determines the current room and updates the state of the worker based on whether it is a known or unknown room.",
            "params": [],
            "returns": null,
            "usage": {
              "language": "python",
              "code": "worker = SpecificWorker(proxy_map)\naffordance_node = worker.g.get_node(affordance_id)\nif affordance_node.attrs[\"parent\"].value:\n    exit_door_id = affordance_node.attrs[\"parent\"].value\n    if exit_door_id:\n        exit_door_id_node = worker.g.get_node(exit_door_id)\n        if exit_door_id_node.attrs[\"connected_room_name\"].value:\n            worker.state = \"known_room\"\n",
              "description": ""
            },
            "name": "crossed",
            "location": {
              "start": 283,
              "insert": 285,
              "offset": " ",
              "indent": 8,
              "comment": null
            },
            "item_type": "method",
            "length": 16,
            "docLength": null
          },
          {
            "id": "ab648f62-f59a-0696-1b4f-b5b4de68bc91",
            "ancestors": [
              "75233bfc-d379-5786-3e4d-6b16aa1599c4"
            ],
            "description": "Initializes the room nodes in the graph, identifying and selecting the entrance node based on the exit door ID, and setting the current state to \"initializing doors\".",
            "params": [],
            "returns": null,
            "usage": {
              "language": "python",
              "code": "# Initiate SpecificWorker class\nworker = SpecificWorker(proxy_map, startup_check=False)\n\n# Run initializing_room method\nworker.initializing_room()\n\n# Do something with the result of initializing_room\nprint(\"Room initialized.\")\n",
              "description": ""
            },
            "name": "initializing_room",
            "location": {
              "start": 303,
              "insert": 306,
              "offset": " ",
              "indent": 8,
              "comment": null
            },
            "item_type": "method",
            "length": 10,
            "docLength": null
          },
          {
            "id": "c91dcd80-22ac-4a9b-be40-5caba44d2d63",
            "ancestors": [
              "75233bfc-d379-5786-3e4d-6b16aa1599c4"
            ],
            "description": "Determines the room the robot is currently in, based on the global map and the robot's position, and updates the graph with the appropriate edges and nodes.",
            "params": [],
            "returns": null,
            "usage": {
              "language": "python",
              "code": "import SpecificWorker\n\n# Create a proxy object for the worker\nworker = SpecificWorker.SpecificWorker()\n\n# Set the agent ID for which to perform the task\nagent_id = 13\n\n# Run the function known_room and pass in the agent ID as an argument\nknown_room_output = worker.known_room(agent_id)\n\n# Print the output of the function\nprint(\"Known room:\", known_room_output)\n",
              "description": ""
            },
            "name": "known_room",
            "location": {
              "start": 317,
              "insert": 319,
              "offset": " ",
              "indent": 8,
              "comment": null
            },
            "item_type": "method",
            "length": 73,
            "docLength": null
          },
          {
            "id": "e7db7e8c-ed5d-4192-e74c-af8b90f950ea",
            "ancestors": [
              "75233bfc-d379-5786-3e4d-6b16aa1599c4"
            ],
            "description": "1) identifies exit edges in the graph, 2) finds matching doors, and 3) associates them to create a connected room hierarchy.",
            "params": [],
            "returns": null,
            "usage": {
              "language": "python",
              "code": "# Assume that \"worker\" is an instance of SpecificWorker class\nworker.initializing_doors()\n",
              "description": "\nIn this example, the initializing_doors method is called on the worker object, which is an instance of the SpecificWorker class. The method then performs various actions such as setting up signals and connecting to a runtime API."
            },
            "name": "initializing_doors",
            "location": {
              "start": 411,
              "insert": 413,
              "offset": " ",
              "indent": 8,
              "comment": null
            },
            "item_type": "method",
            "length": 28,
            "docLength": null
          },
          {
            "id": "5cad0a52-9edf-779c-ab40-f409873f2c7f",
            "ancestors": [
              "75233bfc-d379-5786-3e4d-6b16aa1599c4"
            ],
            "description": "Connects two doors in a graph by adding an edge between them and setting their \"other side door name\" and \"connected room name\" attributes.",
            "params": [
              {
                "name": "door_1",
                "type_name": "str",
                "description": "A string representing the name of the first door to be associated with another door."
              },
              {
                "name": "door_2",
                "type_name": "str | int",
                "description": "Used to represent the name of the second door that needs to be associated with the first door."
              }
            ],
            "returns": null,
            "usage": {
              "language": "python",
              "code": "from igraph import Graph\n\n# Create a graph with two nodes and two edges\ng = Graph()\ng.add_vertices([\"A\", \"B\"])\ng.add_edges([(\"A\", \"B\")])\n\n# Use the associate_doors function to add a door between nodes A and B\nspecific_worker = SpecificWorker(proxy_map)\nspecific_worker.associate_doors(door_1=[\"A\", \"C\"], door_2=[\"B\", \"D\"])\n\n# Print the graph\nprint(g)\n",
              "description": "\nIn this example, we first create a graph with two nodes and one edge using the `add_vertices` and `add_edges` methods. Then, we create an instance of the `SpecificWorker` class and use the `associate_doors` method to add a door between nodes A and B. Finally, we print the graph to show that the door has been added correctly."
            },
            "name": "associate_doors",
            "location": {
              "start": 450,
              "insert": 452,
              "offset": " ",
              "indent": 8,
              "comment": null
            },
            "item_type": "method",
            "length": 16,
            "docLength": null
          },
          {
            "id": "a9f2c249-039d-49a4-e240-853633ecd2f4",
            "ancestors": [
              "75233bfc-d379-5786-3e4d-6b16aa1599c4"
            ],
            "description": "Saves the graph data to a file using pickling.",
            "params": [],
            "returns": null,
            "usage": {
              "language": "python",
              "code": "worker = SpecificWorker(proxy_map, startup_check=True)\nworker.store_graph()\n",
              "description": ""
            },
            "name": "store_graph",
            "location": {
              "start": 469,
              "insert": 470,
              "offset": " ",
              "indent": 8,
              "comment": null
            },
            "item_type": "method",
            "length": 11,
            "docLength": null
          },
          {
            "id": "12a2bcfa-ba36-7bb3-404e-aa001af8fb4c",
            "ancestors": [
              "75233bfc-d379-5786-3e4d-6b16aa1599c4"
            ],
            "description": "Removes edges from the long-term graph that have been labeled as RT or has, based on room numbers. It also deletes nodes in the graph that correspond to shadow nodes.",
            "params": [],
            "returns": null,
            "usage": {
              "language": "python",
              "code": "# Initialize the SpecificWorker class and its associated objects\nsw = SpecificWorker(proxy_map, startup_check=False)\n\n# Define a robot name\nrobot_name = \"Shadow\"\n\n# Call the removing method on the initialized SpecificWorker object\nsw.removing(robot_name)\n",
              "description": ""
            },
            "name": "removing",
            "location": {
              "start": 483,
              "insert": 485,
              "offset": " ",
              "indent": 8,
              "comment": null
            },
            "item_type": "method",
            "length": 19,
            "docLength": null
          },
          {
            "id": "c94afa2d-08b0-cc91-8a47-bf999d91cbf5",
            "ancestors": [
              "75233bfc-d379-5786-3e4d-6b16aa1599c4"
            ],
            "description": "Traverses a directed graph represented by an igraph object, starting from a given node ID. It recursively visits all reachable nodes and inserts edges from the root node to each visited node.",
            "params": [
              {
                "name": "node_id",
                "type_name": "int",
                "description": "Representing the unique identifier of a node in the graph to be traversed."
              }
            ],
            "returns": null,
            "usage": {
              "language": "python",
              "code": "# Creating an instance of SpecificWorker class\nmy_worker = SpecificWorker(proxy_map, startup_check=True)\n\n# Traversing the graph starting from the robot's node\nmy_worker.traverse_graph(my_worker.robot_id)\n\n# Printing the traversed nodes and edges\nfor node in my_worker.g.nodes:\n    print(node.id, node.label)\nfor edge in my_worker.g.edges:\n    print(edge.origin, edge.destination)\n",
              "description": ""
            },
            "name": "traverse_graph",
            "location": {
              "start": 509,
              "insert": 511,
              "offset": " ",
              "indent": 8,
              "comment": null
            },
            "item_type": "method",
            "length": 7,
            "docLength": null
          },
          {
            "id": "8a30575b-5e73-bbab-b148-8adc360d99a5",
            "ancestors": [
              "75233bfc-d379-5786-3e4d-6b16aa1599c4"
            ],
            "description": "Iterates through the graph's successors of a given vertex, and for each successor, it checks if the successor's level is higher than the current vertex's level, and if so, it inserts a new vertex and edge in the DSR and recursively traverses the graph.",
            "params": [
              {
                "name": "node",
                "type_name": "igraph.Vertex",
                "description": "Used to represent a specific vertex in the graph."
              }
            ],
            "returns": null,
            "usage": {
              "language": "python",
              "code": "# Example usage of traverse_igraph()\ng = DSRGraph(0, \"LongTermSpatialMemory_agent\", 13)\nnode = g.get_node(\"My_Node\")\ntraverse_igraph(g, node)\n",
              "description": "\nThis code creates an instance of the class GenericWorker and a graph object named g. It also gets a node from the graph using its name \"My_Node\". Then it calls traverse_igraph() with g as an argument and the node as an argument, which initiates the recursive traversal through the graph starting at the given node."
            },
            "name": "traverse_igraph",
            "location": {
              "start": 519,
              "insert": 520,
              "offset": " ",
              "indent": 8,
              "comment": null
            },
            "item_type": "method",
            "length": 10,
            "docLength": null
          },
          {
            "id": "74851935-7e42-4080-e848-40c81557fc8b",
            "ancestors": [
              "75233bfc-d379-5786-3e4d-6b16aa1599c4"
            ],
            "description": "Adds a vertex to an igraph graph, based on attributes provided by a node object. It also tries to find matching vertices using specific attribute values and adds edges between them if found.",
            "params": [
              {
                "name": "node",
                "type_name": "igraph.Node | dict",
                "description": "Used to add a new vertex to an igraph graph with specified attributes."
              }
            ],
            "returns": null,
            "usage": {
              "language": "python",
              "code": "from GenericWorker import SpecificWorker\n\n# create a new worker instance with proxy_map and startup_check=False\nworker = SpecificWorker(proxy_map, startup_check=False)\n\n# add a vertex to the graph with name='node1', id=2, type='room'\nworker.insert_igraph_vertex(node=SpecificWorkerNode(name='node1', id=2, type='room'))\n\n# add another vertex to the graph with name='node2', id=3, type='room'\nworker.insert_igraph_vertex(node=SpecificWorkerNode(name='node2', id=3, type='room'))\n\n# add an edge between the two vertices\nworker.insert_igraph_edge(origin_node=worker.graph.vs[1], other_side_door_node=worker.graph.vs[2])\n",
              "description": ""
            },
            "name": "insert_igraph_vertex",
            "location": {
              "start": 532,
              "insert": 533,
              "offset": " ",
              "indent": 8,
              "comment": null
            },
            "item_type": "method",
            "length": 28,
            "docLength": null
          },
          {
            "id": "6fb56577-9138-aab8-2145-b8d6dbfab0f8",
            "ancestors": [
              "75233bfc-d379-5786-3e4d-6b16aa1599c4"
            ],
            "description": "Inserts a new vertex into a graph, updating the parent node's attribute with the worker's ID and copying over non-optional attributes from the input node to the new vertex.",
            "params": [
              {
                "name": "parent_name",
                "type_name": "str | str",
                "description": "Used to specify the name of the parent node to insert the new node as."
              },
              {
                "name": "node",
                "type_name": "Node",
                "description": "Passed as an instance of the class `Node`."
              }
            ],
            "returns": null,
            "usage": {
              "language": "python",
              "code": "myWorker = SpecificWorker(proxy_map, startup_check=False)\n# create a new node with name \"NewNode\" and type \"Room\":\nnew_node = myWorker.insert_dsr_vertex(\"MyRobot\", {\"type\": \"Room\", \"name\": \"NewNode\"})\n",
              "description": "\nIn this example, the user creates an instance of the `SpecificWorker` class, then calls the `insert_dsr_vertex` function with the parent node name \"MyRobot\" and a dictionary containing the node type and name. The function returns a new node with the specified attributes."
            },
            "name": "insert_dsr_vertex",
            "location": {
              "start": 567,
              "insert": 569,
              "offset": " ",
              "indent": 8,
              "comment": null
            },
            "item_type": "method",
            "length": 9,
            "docLength": null
          },
          {
            "id": "2addb82a-54dd-dbac-cd4a-bb5786953a0f",
            "ancestors": [
              "75233bfc-d379-5786-3e4d-6b16aa1599c4"
            ],
            "description": "Adds an edge to an existing graph based on information provided by the edge attribute, including translation and rotation values.",
            "params": [
              {
                "name": "edge",
                "type_name": "igraph.Edge | GraphElement",
                "description": "An instance representing a single edge to be inserted into the graph."
              }
            ],
            "returns": null,
            "usage": {
              "language": "python",
              "code": "# Create an instance of the SpecificWorker class and initialize it with the proxy map\nworker = SpecificWorker(proxy_map)\n\n# Insert a new edge into the DSRGraph object\nworker.insert_igraph_edge(Edge(origin=\"Origin\", destination=\"Destination\", rt_translation=0, rt_rotation_euler_xyz=[0, 0, 0]))\n",
              "description": ""
            },
            "name": "insert_igraph_edge",
            "location": {
              "start": 581,
              "insert": 582,
              "offset": " ",
              "indent": 8,
              "comment": null
            },
            "item_type": "method",
            "length": 9,
            "docLength": null
          },
          {
            "id": "9645ce4c-8234-ba84-ff45-3574f5a37212",
            "ancestors": [
              "75233bfc-d379-5786-3e4d-6b16aa1599c4"
            ],
            "description": "Inserts or updates an edge in a graph based on the distance-sensitive roadmap (DSR) algorithm, considering the RT translation and rotation of the edge's endpoints.",
            "params": [
              {
                "name": "org",
                "type_name": "Node | None",
                "description": "Used to specify the source node of the edge being inserted. If `org` is None, it means the root node of the graph."
              },
              {
                "name": "dest",
                "type_name": "Node | str",
                "description": "Used to specify the destination node or name in the graph for which to create a new edge with RT attributes."
              }
            ],
            "returns": null,
            "usage": {
              "language": "python",
              "code": "# Creating a new worker class inheriting from GenericWorker\nclass SpecificWorker(GenericWorker):\n    def __init__(self, proxy_map):\n        super(SpecificWorker, self).__init__(proxy_map)\n        # Initializing the DSR graph with an agent ID and robot name\n        self.agent_id = 13\n        self.robot_name = \"Shadow\"\n        self.g = DSRGraph(0, \"LongTermSpatialMemory_agent\", self.agent_id)\n        # Connecting to the signals of the DSR graph\n        try:\n            signals.connect(self.g, signals.UPDATE_NODE, self.update_node)\n            signals.connect(self.g, signals.UPDATE_EDGE, self.update_edge)\n            console.print(\"signals connected\")\n        except RuntimeError as e:\n            print(e)\n",
              "description": "\nThe user can then use the function insert_dsr_edge to add an edge between two nodes in the DSR graph. Here is an example of how this might be done:\n"
            },
            "name": "insert_dsr_edge",
            "location": {
              "start": 595,
              "insert": 598,
              "offset": " ",
              "indent": 8,
              "comment": null
            },
            "item_type": "method",
            "length": 22,
            "docLength": null
          },
          {
            "id": "c91b9329-a134-37b7-f244-aae2be8f76fd",
            "ancestors": [
              "75233bfc-d379-5786-3e4d-6b16aa1599c4"
            ],
            "description": "Generates a graph based on the layout of a Kamada-Kawai graph, and adds node labels and edge annotations.",
            "params": [],
            "returns": null,
            "usage": {
              "language": "python",
              "code": "# Import necessary libraries and classes\nfrom SpecificWorker import GenericWorker, DSRGraph\nimport signals\nimport console\n\n# Instantiate a new instance of SpecificWorker\nworker = SpecificWorker(proxy_map)\n\n# Define the graph object to be drawn\ngraph = DSRGraph(0, \"LongTermSpatialMemory_agent\", worker.agent_id)\n\n# Connect signals to functions in GenericWorker class\nsignals.connect(graph, signals.UPDATE_NODE, worker.update_node)\nsignals.connect(graph, signals.UPDATE_EDGE, worker.update_edge)\n\n# Draw the graph using the draw_graph function\nworker.draw_graph(graph)\n",
              "description": ""
            },
            "name": "draw_graph",
            "location": {
              "start": 625,
              "insert": 626,
              "offset": " ",
              "indent": 8,
              "comment": null
            },
            "item_type": "method",
            "length": 16,
            "docLength": null
          },
          {
            "id": "29f979ee-26a0-1ca3-4747-685c4ee28371",
            "ancestors": [
              "75233bfc-d379-5786-3e4d-6b16aa1599c4"
            ],
            "description": "Retrieves the room ID associated with a given node ID using the Graph object's `get_node` method and attribute access, and returns the room ID if found, or -1 otherwise.",
            "params": [
              {
                "name": "node_id",
                "type_name": "int",
                "description": "Used to identify the element for which the room number needs to be checked."
              }
            ],
            "returns": {
              "type_name": "int",
              "description": "The room ID of a given element if the element has a \"room_id\" attribute, or -1 otherwise."
            },
            "usage": {
              "language": "python",
              "code": "worker = SpecificWorker(proxy_map, startup_check=False)\nroom_id = worker.check_element_room_number(node_id)\nprint(f\"The room ID of the node with ID {node_id} is {room_id}.\")\n",
              "description": ""
            },
            "name": "check_element_room_number",
            "location": {
              "start": 650,
              "insert": 651,
              "offset": " ",
              "indent": 8,
              "comment": null
            },
            "item_type": "method",
            "length": 7,
            "docLength": null
          },
          {
            "id": "5dddb8ec-4dbc-e387-6e48-64f7ff25662a",
            "ancestors": [
              "75233bfc-d379-5786-3e4d-6b16aa1599c4"
            ],
            "description": "Determines the level of an element with a given ID in the internal graph, handles exceptions, and adjusts door connections based on the room similarity.",
            "params": [
              {
                "name": "node_id",
                "type_name": "int",
                "description": "Used to identify the node being checked for its element level attribute value."
              }
            ],
            "returns": {
              "type_name": "int",
              "description": "The level of an element with the given node ID, or -1 if no such attribute is found."
            },
            "usage": {
              "language": "python",
              "code": "# Example of using the check_element_level function\n\n# Create a new instance of the SpecificWorker class\nmy_worker = SpecificWorker(proxy_map, startup_check=False)\n\n# Call the check_element_level function with node_id as an argument\nelement_level = my_worker.check_element_level(\"node_id\")\n",
              "description": ""
            },
            "name": "check_element_level",
            "location": {
              "start": 659,
              "insert": 660,
              "offset": " ",
              "indent": 8,
              "comment": null
            },
            "item_type": "method",
            "length": 25,
            "docLength": null
          },
          {
            "id": "d812eadc-e596-7a97-8447-d13ce3895f4d",
            "ancestors": [
              "75233bfc-d379-5786-3e4d-6b16aa1599c4"
            ],
            "description": "Retrieves information about a room and its RT edges, then draws the room polygon and doors on an image.",
            "params": [
              {
                "name": "room_node_id",
                "type_name": "str | int",
                "description": "Represented as an integer or string, representing the node ID of the room to be drawn."
              }
            ],
            "returns": null,
            "usage": {
              "language": "python",
              "code": "# Importing necessary packages\nfrom SpecificWorker import SpecificWorker\nimport cv2\n\n# Create a new instance of the class SpecificWorker\nworker = SpecificWorker(proxy_map, startup_check=False)\n\n# Call the generate_room_picture method with the desired room node ID as an argument\nroom_node_id = \"Room1\"\nworker.generate_room_picture(room_node_id)\n",
              "description": "\nThis code creates a new instance of the SpecificWorker class, imports the necessary packages, and calls the generate_room_picture method with the desired room node ID as an argument. The function will then generate a 2D image of the room based on the information stored in the graph. The resulting image can be viewed using the OpenCV library by calling cv2.imwrite() or displayed directly using the OpenCV library's display() method."
            },
            "name": "generate_room_picture",
            "location": {
              "start": 702,
              "insert": 704,
              "offset": " ",
              "indent": 8,
              "comment": null
            },
            "item_type": "method",
            "length": 24,
            "docLength": null
          },
          {
            "id": "a50d6999-6284-35be-614f-deef0dec204d",
            "ancestors": [
              "75233bfc-d379-5786-3e4d-6b16aa1599c4"
            ],
            "description": "Inserts or assigns an edge to the graph representing the current room of the agent, with the source and destination being the same agent ID.",
            "params": [
              {
                "name": "room_id",
                "type_name": "str",
                "description": "Passed as an argument to Edge constructor, representing the ID of the current room that the agent is in."
              }
            ],
            "returns": null,
            "usage": {
              "language": "python",
              "code": "worker = SpecificWorker(proxy_map)\nroom_id = 254\nworker.insert_current_edge(room_id)\n",
              "description": ""
            },
            "name": "insert_current_edge",
            "location": {
              "start": 737,
              "insert": 739,
              "offset": " ",
              "indent": 8,
              "comment": null
            },
            "item_type": "method",
            "length": 3,
            "docLength": null
          },
          {
            "id": "9bc1d031-9b8b-578b-b14d-26d0bcd00d92",
            "ancestors": [
              "75233bfc-d379-5786-3e4d-6b16aa1599c4"
            ],
            "description": "Updates a node's information based on its type and other factors, such as checking if a door node exists and inserting it into the graph if necessary, or handling an affordance node's state change.",
            "params": [
              {
                "name": "id",
                "type_name": "int",
                "description": "Used as an identifier for a node in the graph."
              },
              {
                "name": "type",
                "type_name": "str",
                "description": "Used to indicate the type of node being updated."
              }
            ],
            "returns": null,
            "usage": {
              "language": "python",
              "code": "worker = SpecificWorker(proxy_map, startup_check=True)\nif worker.rt_api.is_running():\n    print(\"Robot is running\")\nelse:\n    print(\"Robot is not running\")\n    return\n\n# Update node with id 123 and type \"door\"\nworker.update_node(123, \"door\")\n",
              "description": ""
            },
            "name": "update_node",
            "location": {
              "start": 751,
              "insert": 752,
              "offset": " ",
              "indent": 8,
              "comment": null
            },
            "item_type": "method",
            "length": 41,
            "docLength": null
          },
          {
            "id": "0c89aab3-c848-cb96-6046-4854f3cd0019",
            "ancestors": [
              "75233bfc-d379-5786-3e4d-6b16aa1599c4"
            ],
            "description": "Updates an edge in the graph based on the current node, type, and other conditions.",
            "params": [
              {
                "name": "fr",
                "type_name": "int",
                "description": "Referred to as \"from room\" indicating that it represents the starting point of an edge in the graph, specifically a room node."
              },
              {
                "name": "to",
                "type_name": "int",
                "description": "The id of the target node to which the edge is being updated."
              },
              {
                "name": "type",
                "type_name": "str",
                "description": "Used to specify the type of edge being updated (either \"RT\" or \"FT\")."
              }
            ],
            "returns": null,
            "usage": {
              "language": "python",
              "code": "# Instantiate an object of SpecificWorker class\nworker = SpecificWorker()\n\n# Set the robot name and ID\nworker.robot_name = \"Shadow\"\nworker.robot_id = 13\n\n# Update the edge with type 'RT' between node 0 (the robot) and node 1 (a room exit door)\nworker.update_edge(fr=0, to=1, type=\"RT\")\n",
              "description": ""
            },
            "name": "update_edge",
            "location": {
              "start": 806,
              "insert": 810,
              "offset": " ",
              "indent": 8,
              "comment": null
            },
            "item_type": "method",
            "length": 5,
            "docLength": null
          }
        ]
      }
    }
  }
]