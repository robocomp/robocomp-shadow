[
  {
    "name": "long_term_graph.py",
    "path": "agents/long_term_spatial_memory_agent/src/long_term_graph.py",
    "content": {
      "structured": {
        "description": "A class `Room` that represents a 3D room in a graph, with nodes representing corners and edges representing walls. The class provides methods for calculating the projective coordinates (4x1) of the corners and objects in the room frame, as well as for drawing the room and its objects on a plot. The code uses the `networkx` and `scipy.spatial` libraries to manipulate and analyze the graph data.",
        "items": [
          {
            "id": "e77351db-7a15-56b3-3644-4399c887d62b",
            "ancestors": [],
            "description": "Provides a user interface for visualizing and exploring a graph, including rooms and doors. It allows for adding nodes, edges, and doors, as well as displaying room names and distances between nodes.",
            "attributes": [
              {
                "name": "g",
                "type_name": "str|int",
                "description": "Used to specify the color of the graph's edges. It can be set to a valid matplotlib color name or an integer value between 0 and 1, representing the transparency level of the edge."
              },
              {
                "name": "read_graph",
                "type_name": "Callable[[str],Dict[str,float]]",
                "description": "Used to read a graph from a file specified by the filename parameter. It returns a dictionary containing the graph data as key-value pairs where keys are node or edge indices and values are the corresponding coordinates or weights."
              },
              {
                "name": "fig",
                "type_name": "matplotlibfigureFigure",
                "description": "Used to represent the figure object that will be drawn with the graph. It contains information about the figure, such as its size, layout, and any additional elements that will be displayed in it."
              },
              {
                "name": "ax",
                "type_name": "matplotlibpyplotAxes",
                "description": "Used to represent a 2D axes object that displays the graphical representation of the long-term graph."
              },
              {
                "name": "fig_2",
                "type_name": "matplotlibfigureFigure",
                "description": "Used to store the figure object for the second graph."
              },
              {
                "name": "ax_2",
                "type_name": "AxesSubplot|MatplotlibFigure",
                "description": "Used to store a secondary axes object, which can be used to display additional visualizations or metrics alongside the primary graph."
              }
            ],
            "name": "LongTermGraph",
            "location": {
              "start": 15,
              "insert": 16,
              "offset": " ",
              "indent": 4,
              "comment": null
            },
            "item_type": "class",
            "length": 269,
            "docLength": null
          },
          {
            "id": "35f455db-0eef-1ba5-f04f-cb6cacf60abb",
            "ancestors": [
              "e77351db-7a15-56b3-3644-4399c887d62b"
            ],
            "description": "Reads a graph from a file, creates an igraph object, and displays both the original graph and its metric reconstruction using matplotlib.",
            "params": [
              {
                "name": "file_name",
                "type_name": "str",
                "description": "Used to specify the name of the graph file that contains the LTSM data to be reconstructed."
              }
            ],
            "returns": null,
            "usage": {
              "language": "python",
              "code": "from LongTermGraph import LongTermGraph\n\n# create an instance of the class and set its name\nltg = LongTermGraph(\"my_graph.pickle\")\n\n# print the summary of the graph\nprint(ltg.summary())\n\n# plot the graph on a matplotlib figure\nltg.plot()\n",
              "description": ""
            },
            "name": "__init__",
            "location": {
              "start": 16,
              "insert": 17,
              "offset": " ",
              "indent": 8,
              "comment": null
            },
            "item_type": "constructor",
            "length": 22,
            "docLength": null
          },
          {
            "id": "252c67c9-d429-faa7-ef4a-8d465711c8a0",
            "ancestors": [
              "e77351db-7a15-56b3-3644-4399c887d62b"
            ],
            "description": "Generates a graph based on a subgraph of the original graph, with only certain types of nodes and edges visible.",
            "params": [
              {
                "name": "only_rooms",
                "type_name": "bool",
                "description": "Used to filter out nodes that are not rooms or doors, and edges that do not connect rooms or doors."
              }
            ],
            "returns": null,
            "usage": {
              "language": "python",
              "code": "# create an instance of LongTermGraph class and read graph from file\nmy_graph = LongTermGraph(\"myfile.pkl\")\n\n# draw graph with only rooms\nmy_graph.draw_graph(only_rooms=True)\n\n# draw graph with all nodes including walls, doors, and rooms\nmy_graph.draw_graph()\n",
              "description": ""
            },
            "name": "draw_graph",
            "location": {
              "start": 252,
              "insert": 253,
              "offset": " ",
              "indent": 8,
              "comment": null
            },
            "item_type": "method",
            "length": 33,
            "docLength": null
          }
        ]
      }
    }
  },
  {
    "name": "genericworker.py",
    "path": "agents/g2o_agent/src/genericworker.py",
    "content": {
      "structured": {
        "description": "A worker class that inherits from QtWidgets.QWidget and provides a kill signal for shutting down the worker. The code also sets up an ice slice and imports a RoboCompCommonBehavior module. Additionally, the code creates a Ui_guiDlg class and initializes a timer to call a method every 30 milliseconds.",
        "items": [
          {
            "id": "cb6f42fc-bcd1-7fb5-eb49-91afccba59e8",
            "ancestors": [],
            "description": "Manages a worker process with a periodic timer and provides a signal for termination. It also has a method to set the period of the timer.",
            "attributes": [
              {
                "name": "kill",
                "type_name": "QtCoreSignal",
                "description": "Used to emit a signal when the object needs to be killed."
              },
              {
                "name": "ui",
                "type_name": "Ui_guiDlg",
                "description": "Used to initialize and access the user interface of the widget."
              },
              {
                "name": "mutex",
                "type_name": "QMutex",
                "description": "Used to protect access to the internal state of the worker object, particularly the timer and kill signal."
              },
              {
                "name": "Period",
                "type_name": "int",
                "description": "30 milliseconds by default, which represents the time interval for the timer to run."
              },
              {
                "name": "timer",
                "type_name": "QTimer",
                "description": "Used to schedule a call to the `killYourSelf` slot after a specified period of time."
              }
            ],
            "name": "GenericWorker",
            "location": {
              "start": 43,
              "insert": 45,
              "offset": " ",
              "indent": 4,
              "comment": null
            },
            "item_type": "class",
            "length": 26,
            "docLength": null
          },
          {
            "id": "795c292f-f253-f1aa-a748-23953c9013be",
            "ancestors": [
              "cb6f42fc-bcd1-7fb5-eb49-91afccba59e8"
            ],
            "description": "Initializes an instance of the `GenericWorker` class, setting up a GUI dialog and creating a mutex for managing access to the timer. It also sets the period of the timer to 30 seconds.",
            "params": [
              {
                "name": "mprx",
                "type_name": "Ui_guiDlg",
                "description": "Used as an argument for the setupUi method."
              }
            ],
            "returns": null,
            "name": "__init__",
            "location": {
              "start": 47,
              "insert": 48,
              "offset": " ",
              "indent": 8,
              "comment": null
            },
            "item_type": "method",
            "length": 9,
            "docLength": null
          },
          {
            "id": "ea51cd3f-4286-88a2-5c4e-a765280c1202",
            "ancestors": [
              "cb6f42fc-bcd1-7fb5-eb49-91afccba59e8"
            ],
            "description": "Emits the `kill` signal, indicating that the instance should be destroyed.",
            "params": [],
            "returns": null,
            "name": "killYourSelf",
            "location": {
              "start": 60,
              "insert": 62,
              "offset": " ",
              "indent": 8,
              "comment": null
            },
            "item_type": "method",
            "length": 4,
            "docLength": null
          },
          {
            "id": "20082581-a4f0-66af-9a45-78e2e70b070f",
            "ancestors": [
              "cb6f42fc-bcd1-7fb5-eb49-91afccba59e8"
            ],
            "description": "Updates the `Period` attribute and starts a timer with the new period value using the `timer.start()` method.",
            "params": [
              {
                "name": "p",
                "type_name": "int",
                "description": "Used to set the new period for the timer."
              }
            ],
            "returns": null,
            "name": "setPeriod",
            "location": {
              "start": 67,
              "insert": 69,
              "offset": " ",
              "indent": 8,
              "comment": null
            },
            "item_type": "method",
            "length": 5,
            "docLength": null
          }
        ]
      }
    }
  },
  {
    "name": "specificworker.py",
    "path": "agents/g2o_agent/src/specificworker.py",
    "content": {
      "structured": {
        "description": "a class called `RtOdometry` that implements an algorithm for estimating the position and orientation of a robot based on its odometry data. The code uses the `gazebo` package to simulate the robot's environment and perform odometry calculations. It also utilizes the `rosbag` package to read and process ROS bag files containing sensor data.\n\nThe algorithm first initializes the robot's position and orientation based on the starting pose of the simulation. Then, it updates the node and edge information in the graph using the odometry data from the ROS bag file. Specifically, it calculates the current side speed and angular speed of the robot, and updates the node's position and orientation based on these values. It also updates the edges in the graph based on the current edge set and the RT transmission information.\n\nThe code then implements a few methods for updating and deleting nodes and edges in the graph, as well as updating the algorithm's state based on new sensor data. Overall, the code provides a basic implementation of an odometry algorithm that can be used to estimate the position and orientation of a robot in a simulated environment.",
        "items": [
          {
            "id": "cdcb03d8-8236-2faa-f349-0e323183c24c",
            "ancestors": [],
            "description": "Manages a specific worker's tasks and updates in a graph. It has methods for updating node attributes, deleting nodes, and setting up RT transmission, as well as checking for updates and handling errors.",
            "attributes": [
              {
                "name": "Period",
                "type_name": "float|int",
                "description": "Used to control the update rate of the graph. It determines how often the graph is updated, with a higher value resulting in more frequent updates."
              },
              {
                "name": "agent_id",
                "type_name": "int|str",
                "description": "Used to store the ID of the agent that will be using the specific worker."
              },
              {
                "name": "g",
                "type_name": "Graph|QGraphicsScene",
                "description": "Used to store the graph data for the worker's algorithm, including the nodes, edges, and their attributes."
              },
              {
                "name": "startup_check",
                "type_name": "QTimersingleShot200,QApplicationinstancequit",
                "description": "Used to check if the application is still running after a certain time period (200 milliseconds) and quit if so."
              },
              {
                "name": "rt_api",
                "type_name": "Union[str,int]",
                "description": "Used to store the RT (Real-time) edge set ID for the worker's specific room."
              },
              {
                "name": "inner_api",
                "type_name": "Callable[[],None]",
                "description": "Used to define a custom API for the worker to interact with its internal data structures and algorithms without exposing them to the outer world."
              },
              {
                "name": "odometry_node_id",
                "type_name": "int",
                "description": "Used to identify the node in the graph that represents the robot's odometry information."
              },
              {
                "name": "odometry_queue",
                "type_name": "List[Tuple[float,float,float,int]]",
                "description": "Used to store odometry data from the environment, containing the robot's current advance speed, side speed, and angular speed, as well as the timestamp in milliseconds since the epoch."
              },
              {
                "name": "last_odometry",
                "type_name": "float|List[float]",
                "description": "Used to store the last known odometry values (position, orientation, and translation) of the robot, which are updated in real-time during the simulation."
              },
              {
                "name": "g2o",
                "type_name": "Graph|Tuple[str,str]",
                "description": "Used to represent the graph structure of the robot's environment. It contains a tuple of two elements: the first element is the name of the graph file, and the second element is the name of the node file."
              },
              {
                "name": "visualizer",
                "type_name": "Callable[[QWidget],None]",
                "description": "Used to create a QWidget instance for visualizing the robot's movement and orientation in real-time."
              },
              {
                "name": "odometry_noise_std_dev",
                "type_name": "float|int",
                "description": "0.1 by default, representing the standard deviation of noise added to the odometry measurements for the robot's position, orientation, and angular velocity."
              },
              {
                "name": "odometry_noise_angle_std_dev",
                "type_name": "float|double",
                "description": "0.2 by default, representing the standard deviation of angle noise in the odometry estimates. It affects how much the worker's estimate of the agent's position and orientation deviates from the true values due to random noise in the sensor readings."
              },
              {
                "name": "measurement_noise_std_dev",
                "type_name": "float|int",
                "description": "0.1 by default, indicating the standard deviation of the noise present in the robot's measurements."
              },
              {
                "name": "last_room_id",
                "type_name": "int|str",
                "description": "Used to store the room ID of the previous room that the agent has entered before changing rooms, which is useful for determining when the agent has moved to a new room."
              },
              {
                "name": "actual_room_id",
                "type_name": "int|str",
                "description": "Used to store the current room ID of the agent, which is updated when the agent moves to a new room."
              },
              {
                "name": "elapsed",
                "type_name": "float|int",
                "description": "Used to store the time since the last call to the `update()` method, which is used to update the node's attributes."
              },
              {
                "name": "room_initialized",
                "type_name": "bool",
                "description": "Set to False when a room change is detected, indicating that the worker has not yet initialized its current room's graph. It is reset to True once the worker has successfully initialized the new room's graph."
              },
              {
                "name": "iterations",
                "type_name": "int|float",
                "description": "Used to keep track of the number of iterations (i.e., frames) that the worker has processed. It is updated with each frame processed by the worker, and can be used to control the speed of the worker or to implement various algorithms."
              },
              {
                "name": "hide",
                "type_name": "bool",
                "description": "Used to indicate whether the worker should be hidden or not, affecting its visibility in the graph."
              },
              {
                "name": "init_graph",
                "type_name": "bool",
                "description": "Used to indicate whether the graph has been initialized or not. It is set to True when the worker is initialized and False otherwise, allowing for proper handling of the graph and its nodes and edges in the update methods."
              },
              {
                "name": "current_edge_set",
                "type_name": "bool",
                "description": "Used to track whether an edge set has been computed for the current room id. It is set to True when the first RT edge set is computed and False otherwise, allowing the worker to avoid recomputing the edge set if it has already been computed for the same room id."
              },
              {
                "name": "first_rt_set",
                "type_name": "bool",
                "description": "Set to `True` when the RT translation and rotation values are being set for the first time, and `False` otherwise."
              },
              {
                "name": "translation_to_set",
                "type_name": "float|List[float]",
                "description": "Used to store the translation values set by the RT algorithm."
              },
              {
                "name": "rotation_to_set",
                "type_name": "float|int",
                "description": "A value representing the rotation of the robot to set its end effector at a specific location."
              },
              {
                "name": "room_polygon",
                "type_name": "List[float]",
                "description": "Used to store the vertices of a polygon that represents the room boundary in the environment."
              },
              {
                "name": "security_polygon",
                "type_name": "Union[int,List[float]]",
                "description": "Used to store the security polygon of the worker's workspace in 3D space. It is used to detect collisions between the worker's manipulator and objects in the environment."
              },
              {
                "name": "initialize_g2o_graph",
                "type_name": "void",
                "description": "Used to create a new graph for the given worker instance, which will be used to store the robot's position and orientation in the environment."
              },
              {
                "name": "rt_set_last_time",
                "type_name": "int|float",
                "description": "Used to store the last time a RT (Real-Time) edge was set for a specific agent ID. It is used in conjunction with the `rt_time_min` attribute to determine when to reset the RT translation and rotation values."
              },
              {
                "name": "rt_time_min",
                "type_name": "float",
                "description": "Defined as the minimum time duration between two consecutive RT sets in milliseconds. It is used to determine when to reset the translation and rotation values for the shadow agent during RT tracking."
              },
              {
                "name": "last_update_with_corners",
                "type_name": "int|bool",
                "description": "Used to keep track of the last time a node or edge update was performed with corner information. It is initially set to False, and its value changes when updates are performed with corners. Its purpose is to check if the worker has updated with corners before, so as to avoid unnecessary updates in the future."
              },
              {
                "name": "timer",
                "type_name": "float|int",
                "description": "Used to schedule a call to the `QApplication.instance().quit()` function after 2 seconds."
              },
              {
                "name": "compute",
                "type_name": "Callable[[],Any]",
                "description": "Used to define a function that computes the worker's task based on the graph and other attributes."
              },
              {
                "name": "update_node_att",
                "type_name": "Callable[int,[str]]",
                "description": "Used to update the attributes of a specific node in the graph based on its ID and the type of update. It takes two arguments: id, which is the ID of the node to be updated, and attribute_names, which is a list of attribute names to be updated."
              },
              {
                "name": "update_edge",
                "type_name": "Callable[int,str,str]",
                "description": "Used to update the attributes of an edge in the graph based on its type (current or RT translation) and the node it connects."
              },
              {
                "name": "update_edge_att",
                "type_name": "Tuple[str,]",
                "description": "Used to update the attributes of an edge in a graph based on its type and the name of the attribute."
              }
            ],
            "name": "SpecificWorker",
            "location": {
              "start": 50,
              "insert": 51,
              "offset": " ",
              "indent": 4,
              "comment": null
            },
            "item_type": "class",
            "length": 425,
            "docLength": null
          },
          {
            "id": "d8d35337-69aa-7fa4-5141-35f2de87d6c9",
            "ancestors": [
              "cdcb03d8-8236-2faa-f349-0e323183c24c"
            ],
            "description": "Initializes instance variables and sets up event handling for signals related to node and edge attributes, as well as a timer to compute the worker's output every `Period` seconds.",
            "params": [
              {
                "name": "proxy_map",
                "type_name": "Dict[str, Any]",
                "description": "Used to store the mapping between the original node attributes and their proxies."
              },
              {
                "name": "startup_check",
                "type_name": "bool",
                "description": "Used to check if the graph has already been initialized before starting the worker's execution."
              }
            ],
            "returns": null,
            "usage": {
              "language": "python",
              "code": "# Create an instance of the SpecificWorker class\nmy_specific_worker = SpecificWorker(proxy_map)\n\n# Set up the startup check\nmy_specific_worker.startup_check()\n\n# Connect signals to update node attributes and edges\nsignals.connect(my_specific_worker.g, signals.UPDATE_NODE_ATTR, my_specific_worker.update_node_att)\nsignals.connect(my_specific_worker.g, signals.UPDATE_EDGE, my_specific_worker.update_edge)\n",
              "description": ""
            },
            "name": "__init__",
            "location": {
              "start": 51,
              "insert": 52,
              "offset": " ",
              "indent": 8,
              "comment": null
            },
            "item_type": "constructor",
            "length": 56,
            "docLength": null
          },
          {
            "id": "8a46ef7f-7071-d3b0-3741-830cddb99e31",
            "ancestors": [
              "cdcb03d8-8236-2faa-f349-0e323183c24c"
            ],
            "description": "Computes and updates the robot's position, orientation, and covariance matrix based on RT messages received from the environment.",
            "params": [],
            "returns": null,
            "usage": {
              "language": "python",
              "code": "import time\nfrom specific_worker import SpecificWorker\n\n# Create a SpecificWorker object\nspecific_worker = SpecificWorker()\n\n# Call the compute method\nspecific_worker.compute(time.time())\n",
              "description": ""
            },
            "name": "compute",
            "location": {
              "start": 123,
              "insert": 125,
              "offset": " ",
              "indent": 8,
              "comment": null
            },
            "item_type": "method",
            "length": 103,
            "docLength": null
          },
          {
            "id": "be89d23a-daac-3db1-8843-67ae2a27d66e",
            "ancestors": [
              "cdcb03d8-8236-2faa-f349-0e323183c24c"
            ],
            "description": "Initializes a Graph-Based Odometry (G2O) graph for a specific room by:\n\n1. Retrieving node and edge information from a robot's sensor data.\n2. Filtering out invalid nodes and edges based on their position and orientation.\n3. Adding nominal corners and fixed poses to the G2O graph using the retrieved data.",
            "params": [],
            "returns": {
              "type_name": "bool",
              "description": "True if the g2o graph is successfully initialized and False otherwise."
            },
            "usage": {
              "language": "python",
              "code": "from genericworker import SpecificWorker\n\n# Create a graph and assign it to g2o variable\ng = DSRGraph(0, \"G2O_agent\", agent_id)\ng2o = G2OGraph(verbose=False)\n\n# Use initialize_g2o_graph function from genericworker module\nSpecificWorker.initialize_g2o_graph(g2o)\n",
              "description": ""
            },
            "name": "initialize_g2o_graph",
            "location": {
              "start": 253,
              "insert": 256,
              "offset": " ",
              "indent": 8,
              "comment": null
            },
            "item_type": "method",
            "length": 115,
            "docLength": null
          },
          {
            "id": "9cb9cdad-12a5-6da4-1440-34306b05a309",
            "ancestors": [
              "cdcb03d8-8236-2faa-f349-0e323183c24c"
            ],
            "description": "Computes the displacement of a robot based on its odometry data, taking into account the advance, lateral movement, and angular velocity of the robot.",
            "params": [
              {
                "name": "odometry",
                "type_name": "Tuple[float, float, float]",
                "description": "An immutable sequence containing the robot's odometry data at each time step, consisting of the linear displacement, lateral displacement, and angular velocity, respectively."
              }
            ],
            "returns": {
              "type_name": "Tuple[float,float,float]",
              "description": "The displacement along the x, y and z axes, respectively, calculated using the odometry data from a robot's sensors."
            },
            "usage": {
              "language": "python",
              "code": "# Create an instance of SpecificWorker class and set the proxy map\nspecific_worker = SpecificWorker(proxy_map)\n\n# Set the last odometry to a value\nlast_odometry = (1, 2, 3, 4)\n\n# Call the get_displacement function with the last odometry as an argument\ndisplacement = specific_worker.get_displacement(last_odometry)\n",
              "description": "\nIn this example, we create an instance of the SpecificWorker class and set its proxy map. We then set the last odometry to a value and call the get_displacement function with that value as an argument. The function returns the displacement calculated from the odometry data."
            },
            "name": "get_displacement",
            "location": {
              "start": 458,
              "insert": 459,
              "offset": " ",
              "indent": 8,
              "comment": null
            },
            "item_type": "method",
            "length": 14,
            "docLength": null
          },
          {
            "id": "e5fedf8a-150c-fd98-d148-a6df1ea4a074",
            "ancestors": [
              "cdcb03d8-8236-2faa-f349-0e323183c24c"
            ],
            "description": "Computes the covariance matrix of a set of vertices in a graph, using an optimization algorithm to compute the marginals of the vertices and then constructing the covariance matrix from the resulting upper triangle.",
            "params": [
              {
                "name": "vertex",
                "type_name": "G2O.Vertex | G2O.HessianIndex",
                "description": "Used to compute the covariance matrix for a specific vertex in a graph."
              }
            ],
            "returns": {
              "type_name": "Tuple[bool,npndarray]",
              "description": "A result of computing covariance matrix and the actual computed matrix."
            },
            "usage": {
              "language": "python",
              "code": "import sys\nfrom specific_worker import SpecificWorker\n\n# Create a new instance of SpecificWorker\nworker = SpecificWorker()\n\n# Set the proxy map and startup check to True\nproxy_map = \"proxy_map\"\nstartup_check = True\n\n# Initialize the worker with the given parameters\nworker.init(proxy_map, startup_check)\n\n# Get the covariance matrix of a vertex in the graph\nvertex = worker.g2o.graph.vertices[0]\ncovariance_matrix = worker.get_covariance_matrix(vertex)\nprint(\"Covariance matrix:\", covariance_matrix)\n",
              "description": ""
            },
            "name": "get_covariance_matrix",
            "location": {
              "start": 477,
              "insert": 478,
              "offset": " ",
              "indent": 8,
              "comment": null
            },
            "item_type": "method",
            "length": 11,
            "docLength": null
          },
          {
            "id": "3fa09193-ee9b-8ebd-e44e-8d5f121f7d5a",
            "ancestors": [
              "cdcb03d8-8236-2faa-f349-0e323183c24c"
            ],
            "description": "Visualizes a real-time 3D graphical representation of a G2O optimization problem using Python's Matplotlib library.",
            "params": [
              {
                "name": "optimizer",
                "type_name": "object",
                "description": "Used to load G2O files for visualization."
              }
            ],
            "returns": null,
            "usage": {
              "language": "python",
              "code": "import numpy as np\nfrom g2o import *\nfrom g2o_visualizer import G2OVisualizer\n\n# Create a new instance of the SpecificWorker class.\nworker = SpecificWorker(proxy_map=None, startup_check=False)\n\n# Set up the visualizer and G2OGraph for the worker.\nworker.visualizer = G2OVisualizer(\"G2O Graph\")\nworker.g2o = G2OGraph(verbose=False)\n\n# Load a graph file into the worker's G2OGraph instance.\nworker.g2o.load(\"archivo.g2o\")\n\n# Set up the visualization loop for the worker.\nwhile True:\n    # Load the graph file and update the visualizer.\n    optimizer = worker.g2o\n    positions = []\n    for vertex_id in range(optimizer.vertices().size()):\n        vertex = optimizer.vertex(vertex_id)\n        position = vertex.estimate()\n        positions.append(position)\n    positions = np.array(positions)\n\n    worker.visualizer.ax.clear()\n    worker.visualizer.ax.scatter(positions[:, 0], positions[:, 1], positions[:, 2], c='b', marker='o', label='Vertices')\n\n    edges = optimizer.edges()\n    for edge_id in range(edges.size()):\n        edge = edges[edge_id]\n        measurement = edge.measurement()\n        worker.visualizer.ax.plot(measurement[:, 0], measurement[:, 1], measurement[:, 2], c='r')\n\n    worker.visualizer.ax.set_xlabel('X')\n    worker.visualizer.ax.set_ylabel('Y')\n    worker.visualizer.ax.set_zlabel('Z')\n    worker.visualizer.ax.legend()\n\n    worker.visualizer.draw()\n    worker.visualizer.pause(0.1)\n",
              "description": ""
            },
            "name": "visualize_g2o_realtime",
            "location": {
              "start": 490,
              "insert": 491,
              "offset": " ",
              "indent": 8,
              "comment": null
            },
            "item_type": "method",
            "length": 29,
            "docLength": null
          },
          {
            "id": "595b6b91-9394-1b80-7345-230aff72914c",
            "ancestors": [
              "cdcb03d8-8236-2faa-f349-0e323183c24c"
            ],
            "description": "Updates attributes of a node in a graph based on the current time and robot state, and appends the updated values to an odometry queue for later use.",
            "params": [
              {
                "name": "id",
                "type_name": "int",
                "description": "Used to identify the node for which the attributes are being updated."
              },
              {
                "name": "attribute_names",
                "type_name": "[str]",
                "description": "An array of strings representing the names of attributes to be updated on the given node ID."
              }
            ],
            "returns": null,
            "usage": {
              "language": "python",
              "code": "specificWorker = SpecificWorker(proxy_map)\nspecificWorker.update_node_att(id=20, attribute_names=[\"robot_current_advance_speed\", \"robot_current_side_speed\", \"-robot_current_angular_speed\"])\n",
              "description": "\nIn this example, the end-user is creating a SpecificWorker instance and calling update_node_att with an ID of 20 and a list of attribute names. The function will retrieve the node from the graph based on the ID provided and update the specified attributes in the node's attribute dictionary."
            },
            "name": "update_node_att",
            "location": {
              "start": 527,
              "insert": 536,
              "offset": " ",
              "indent": 8,
              "comment": null
            },
            "item_type": "method",
            "length": 7,
            "docLength": null
          },
          {
            "id": "e4669eb8-bce7-27aa-de44-d04a35cedb5c",
            "ancestors": [
              "cdcb03d8-8236-2faa-f349-0e323183c24c"
            ],
            "description": "Updates the node with the given ID based on the type parameter. If the type is \"corner\", it initializes a room graph and sets the `init_graph` attribute to `True`.",
            "params": [
              {
                "name": "id",
                "type_name": "int",
                "description": "An identifier for the node to be updated."
              },
              {
                "name": "type",
                "type_name": "str",
                "description": "Used to specify the node's type, which can be either \"corner\" or any other valid value."
              }
            ],
            "returns": null,
            "usage": {
              "language": "python",
              "code": "worker = SpecificWorker(proxy_map)  # Initializes a worker with the proxy map\nid = 5                             # Assigns node ID to the variable id\ntype = \"corner\"                     # Assigns node type to the variable type\nworker.update_node(id, type)         # Updates the node in the graph with the given ID and type\n",
              "description": "\nIn this example, the worker is initialized by passing the proxy map as a parameter and then the update_node function is called with the id and type arguments assigned to variables outside the function."
            },
            "name": "update_node",
            "location": {
              "start": 543,
              "insert": 553,
              "offset": " ",
              "indent": 8,
              "comment": null
            },
            "item_type": "method",
            "length": 6,
            "docLength": null
          },
          {
            "id": "6e50ec45-7089-e09c-a842-9c0f0714d216",
            "ancestors": [
              "cdcb03d8-8236-2faa-f349-0e323183c24c"
            ],
            "description": "Deletes a node from a list of nodes maintained by the worker.",
            "params": [
              {
                "name": "id",
                "type_name": "int",
                "description": "Used to represent the unique identifier of the node to be deleted."
              }
            ],
            "returns": null,
            "usage": {
              "language": "python",
              "code": "# Create an instance of the SpecificWorker class\nworker = SpecificWorker(proxy_map)\n\n# Call the delete_node method with the ID of the node to delete\nworker.delete_node(1234567890)\n",
              "description": "\nIn this example, we create an instance of the SpecificWorker class and then call the delete_node method with the ID of the node we want to delete (1234567890). The function will then execute the code to delete the specified node from the graph."
            },
            "name": "delete_node",
            "location": {
              "start": 555,
              "insert": 556,
              "offset": " ",
              "indent": 8,
              "comment": null
            },
            "item_type": "method",
            "length": 6,
            "docLength": null
          },
          {
            "id": "67728d31-113e-e0b4-c34d-aaa4fd6ab27c",
            "ancestors": [
              "cdcb03d8-8236-2faa-f349-0e323183c24c"
            ],
            "description": "Updates the room ID and RT translation and rotation values based on the incoming edge type and node attributes.",
            "params": [
              {
                "name": "fr",
                "type_name": "int",
                "description": "The index of the current edge being processed."
              },
              {
                "name": "to",
                "type_name": "int",
                "description": "Representing the index of the next node in the graph that is being processed."
              },
              {
                "name": "type",
                "type_name": "str",
                "description": "Used to specify the edge's type, which can be either \"current\" or \"RT\"."
              }
            ],
            "returns": null,
            "usage": {
              "language": "python",
              "code": "# In the context of the SpecificWorker class, where \"worker\" is an instance of the SpecificWorker class\nworker.update_edge(fr=0, to=1, type=\"current\") # Update the current edge from node 0 to node 1\nworker.update_edge(fr=0, to=1, type=\"RT\") # Update the RT edge from node 0 to node 1\n",
              "description": "\nThe update_edge function updates the edge between two nodes in the DSRGraph with a specific type (current or RT). The fr parameter specifies the start node of the edge, while the to parameter specifies the end node."
            },
            "name": "update_edge",
            "location": {
              "start": 564,
              "insert": 565,
              "offset": " ",
              "indent": 8,
              "comment": null
            },
            "item_type": "method",
            "length": 22,
            "docLength": null
          },
          {
            "id": "4825b582-5f59-328e-c944-7eddbc75d3f0",
            "ancestors": [
              "cdcb03d8-8236-2faa-f349-0e323183c24c"
            ],
            "description": "Deletes an edge from a graph, identified by its index (fr) and type (to).",
            "params": [
              {
                "name": "fr",
                "type_name": "int",
                "description": "0-based index of the edge to be deleted."
              },
              {
                "name": "to",
                "type_name": "int",
                "description": "Used to specify the target vertex for edge deletion."
              },
              {
                "name": "type",
                "type_name": "str",
                "description": "Used to specify the type of edge to delete, with possible values 'direct' or 'indirect'."
              }
            ],
            "returns": null,
            "usage": {
              "language": "python",
              "code": "my_graph = SpecificWorker(proxy_map)\n# Create a new edge between two nodes in the graph\nmy_graph.add_edge(0, 1, \"type\")\n# Delete the edge from the graph\nmy_graph.delete_edge(0, 1, \"type\")\n",
              "description": ""
            },
            "name": "delete_edge",
            "location": {
              "start": 592,
              "insert": 593,
              "offset": " ",
              "indent": 8,
              "comment": null
            },
            "item_type": "method",
            "length": 3,
            "docLength": null
          }
        ]
      }
    }
  },
  {
    "name": "long_term_graph.py",
    "path": "agents/long_term_spatial_memory_agent/scripts/long_term_graph.py",
    "content": {
      "structured": {
        "description": "a function called draw_metric_map that takes in a metric map object and plots the map using Matplotlib. It first loads the graph from a text file and defines various functions to work with the graph, such as get_room_corners, get_room_objects, and get_room_objects_coordinates. These functions recursively traverse the graph to find the corners or objects in a room, respectively. The draw_metric_map function then uses these functions to plot the rooms and objects in the map. Specifically, it plots each room as a rectangle and adds names to each room, and it plots each object as a point and adds a text label with its name.",
        "items": [
          {
            "id": "5176435a-f92b-e4bd-1b4e-e1e310ab5ae8",
            "ancestors": [],
            "description": "Draws a graph of long-term spatial mobility data using PyQt and Matplotlib. It provides methods to visualize rooms, doors, walls, and edges in the graph.",
            "attributes": [
              {
                "name": "g",
                "type_name": "Graph",
                "description": "Used to represent the graph object that contains the rooms, doors, and walls to be visualized."
              },
              {
                "name": "read_graph",
                "type_name": "instance",
                "description": "Used to read a graph from a file specified by the user. It takes a string path as input and reads the graph data from it."
              },
              {
                "name": "fig",
                "type_name": "instance",
                "description": "A reference to the figure object that will be used to draw the graph."
              },
              {
                "name": "ax",
                "type_name": "MatplotlibFigure",
                "description": "Used to represent the axis object for the graph. It provides methods for adding patches, lines, and other visual elements to the graph."
              }
            ],
            "name": "LongTermGraph",
            "location": {
              "start": 15,
              "insert": 16,
              "offset": " ",
              "indent": 4,
              "comment": null
            },
            "item_type": "class",
            "length": 198,
            "docLength": null
          },
          {
            "id": "411ae665-2c3f-efb9-7546-d76e93280634",
            "ancestors": [
              "5176435a-f92b-e4bd-1b4e-e1e310ab5ae8"
            ],
            "description": "Initializes an object of `LongTermGraph` class, loading a graph from a file using the `read_graph` method and displaying its summary.",
            "params": [
              {
                "name": "file_name",
                "type_name": "str",
                "description": "Used to specify the name of a file containing a graph represented as an adjacency matrix."
              }
            ],
            "returns": null,
            "name": "__init__",
            "location": {
              "start": 16,
              "insert": 17,
              "offset": " ",
              "indent": 8,
              "comment": null
            },
            "item_type": "method",
            "length": 8,
            "docLength": null
          },
          {
            "id": "fbfe681a-6ac8-9cb2-ad48-9c2d64fec643",
            "ancestors": [
              "5176435a-f92b-e4bd-1b4e-e1e310ab5ae8"
            ],
            "description": "Generates a graphical representation of a subgraph within a larger graph, based on node and edge properties. It creates a figure and axis object, sets the title, and draws the nodes and edges using different colors for each type of node or edge.",
            "params": [
              {
                "name": "only_rooms",
                "type_name": "bool",
                "description": "Used to filter the nodes in the graph based on their types, only showing rooms and doors."
              }
            ],
            "returns": null,
            "name": "draw_graph",
            "location": {
              "start": 191,
              "insert": 192,
              "offset": " ",
              "indent": 8,
              "comment": null
            },
            "item_type": "method",
            "length": 34,
            "docLength": null
          }
        ]
      }
    }
  },
  {
    "name": "main.py",
    "path": "agents/long_term_spatial_memory_agent/scripts/main.py",
    "content": {
      "structured": {
        "description": "Three functions: draw_graph, find_edge_with_attribute, and get_connected_door_nodes. The draw_graph function takes a graph object as input and uses PySide2's QtCore module to create a subplot and plot points on the graph. The find_edge_with_attribute function searches for an edge in a given graph based on a specific attribute, and the get_connected_door_nodes function recursively traverses a graph to find all connected door nodes in a given room. The code also loads a graph from a pickled file using the LongTermGraph class, and uses the compute_metric_map and draw_metric_map functions to display the graph's metric map and point locations.",
        "items": [
          {
            "id": "d3824e62-3401-2c9e-394e-2ee9ee755e69",
            "ancestors": [],
            "description": "Generates a graph based on a provided adjacency matrix using Kamada-Kawai layout algorithm, and adds node names and edges with arrowheads.",
            "params": [
              {
                "name": "graph",
                "type_name": "AbstractGraph",
                "description": "Used to represent a graph object that contains vertices and edges."
              }
            ],
            "returns": null,
            "name": "draw_graph",
            "location": {
              "start": 6,
              "insert": 7,
              "offset": " ",
              "indent": 4,
              "comment": null
            },
            "item_type": "function",
            "length": 24,
            "docLength": null
          },
          {
            "id": "d7906eb3-709a-3c95-7c40-18ce0ab8dcfd",
            "ancestors": [],
            "description": "Searches through a graph's edges for an edge with a specific attribute equal to a given value. If such an edge is found, it returns it; otherwise, it returns `None`.",
            "params": [
              {
                "name": "graph",
                "type_name": "Graph",
                "description": "Represented as an object that contains a collection of edges, where each edge represents a connection between two nodes in the graph."
              },
              {
                "name": "attribute",
                "type_name": "attribute",
                "description": "Used to specify the attribute of interest for finding an edge in a graph."
              },
              {
                "name": "value",
                "type_name": "object",
                "description": "Used to search for an edge in a graph based on a specific attribute."
              }
            ],
            "returns": {
              "type_name": "edge",
              "description": "An untyped reference to a graph edge that has the specified attribute equal to the provided value."
            },
            "name": "find_edge_with_attribute",
            "location": {
              "start": 41,
              "insert": 42,
              "offset": " ",
              "indent": 4,
              "comment": null
            },
            "item_type": "function",
            "length": 5,
            "docLength": null
          },
          {
            "id": "fe2cae8a-54a8-32a7-014a-24ebf3a8e0f2",
            "ancestors": [],
            "description": "Iterates over the edges in a graph and adds to an output list any edge connecting nodes with \"door\" in their names.",
            "params": [
              {
                "name": "graph",
                "type_name": "Graph",
                "description": "Represented as g, which contains a collection of nodes and edges that define a graph structure."
              }
            ],
            "returns": {
              "type_name": "list",
              "description": "A collection of edges from the given graph."
            },
            "name": "get_room_edges",
            "location": {
              "start": 47,
              "insert": 48,
              "offset": " ",
              "indent": 4,
              "comment": null
            },
            "item_type": "function",
            "length": 10,
            "docLength": null
          },
          {
            "id": "e9acd19c-513f-f78e-4949-cd353d1b9b16",
            "ancestors": [],
            "description": "In Java code recursively queries the graph for all nodes connected to a given node via doors, returning a list of such nodes.",
            "params": [
              {
                "name": "graph",
                "type_name": "Graph",
                "description": "Used to represent a graph structure."
              },
              {
                "name": "node",
                "type_name": "GraphNode",
                "description": "Referred to as a node in the graph."
              }
            ],
            "returns": {
              "type_name": "list",
              "description": "A collection of nodes that are connected to a specific node through doors."
            },
            "name": "get_connected_door_nodes",
            "location": {
              "start": 58,
              "insert": 60,
              "offset": " ",
              "indent": 4,
              "comment": null
            },
            "item_type": "function",
            "length": 10,
            "docLength": null
          },
          {
            "id": "9a2a2e72-8415-229d-6c4a-657476ccda61",
            "ancestors": [],
            "description": "Navigates through a graph by starting from a given room and visiting all other rooms reachable through doors. It keeps track of visited rooms using a list and prints information about each room it visits.",
            "params": [
              {
                "name": "graph",
                "type_name": "Graph",
                "description": "Used to represent a graph with nodes and edges."
              },
              {
                "name": "current_room",
                "type_name": "dict",
                "description": "Represents the current room to be traversed in the graph."
              },
              {
                "name": "visited",
                "type_name": "list",
                "description": "Used to keep track of the rooms that have been visited during the traversal process, initialized to an empty list if None."
              }
            ],
            "returns": {
              "type_name": "list",
              "description": "A collection of strings representing the rooms that have been visited."
            },
            "name": "traverse_graph",
            "location": {
              "start": 74,
              "insert": 75,
              "offset": " ",
              "indent": 4,
              "comment": null
            },
            "item_type": "function",
            "length": 17,
            "docLength": null
          }
        ]
      }
    }
  },
  {
    "name": "genericworker.py",
    "path": "agents/long_term_spatial_memory_agent/src/genericworker.py",
    "content": {
      "structured": {
        "description": "A worker class that inherits from QtWidgets.QWidget and implements a timer-based mechanism for killing itself after a specified period. It also provides a signal kill to allow for handling of the termination from outside the worker. The code uses PySide2, Ice, and the RoboCompCommonBehavior module.",
        "items": [
          {
            "id": "8a50128c-009f-a1ac-2c45-674f0e62438e",
            "ancestors": [],
            "description": "Manages a timer and a signal to stop its own execution. It has methods to change the timer period and to emit the signal to stop itself.",
            "attributes": [
              {
                "name": "kill",
                "type_name": "QtCoreQObjectSlot",
                "description": "Used to emit a signal that can be caught by any connected slots to stop the worker's execution."
              },
              {
                "name": "ui",
                "type_name": "Ui_guiDlg",
                "description": "Used to setup the user interface of the class."
              },
              {
                "name": "mutex",
                "type_name": "QMutex",
                "description": "Used to protect the worker's state from concurrent access."
              },
              {
                "name": "Period",
                "type_name": "int",
                "description": "Used to set the time interval for the timer signal emitted by the `setPeriod()` method, which changes its value on each call."
              },
              {
                "name": "timer",
                "type_name": "QtCoreQTimer",
                "description": "Used to start a timer that emits the `kill` signal after a specified period."
              }
            ],
            "name": "GenericWorker",
            "location": {
              "start": 43,
              "insert": 45,
              "offset": " ",
              "indent": 4,
              "comment": null
            },
            "item_type": "class",
            "length": 26,
            "docLength": null
          },
          {
            "id": "dc756aa5-ebc6-5490-d649-854bb2ac26a4",
            "ancestors": [
              "8a50128c-009f-a1ac-2c45-674f0e62438e"
            ],
            "description": "Initializes an object of the `GenericWorker` class, setting up a UI widget, creating a mutex for synchronization, and defining a timer with a period of 500 milliseconds.",
            "params": [
              {
                "name": "mprx",
                "type_name": "Ui_guiDlg",
                "description": "Used as the parent widget for the GenericWorker object's UI."
              }
            ],
            "returns": null,
            "name": "__init__",
            "location": {
              "start": 47,
              "insert": 48,
              "offset": " ",
              "indent": 8,
              "comment": null
            },
            "item_type": "method",
            "length": 9,
            "docLength": null
          },
          {
            "id": "17fccd3d-bcc7-a9a3-5f45-73125f7d1f78",
            "ancestors": [
              "8a50128c-009f-a1ac-2c45-674f0e62438e"
            ],
            "description": "Emits the `kill` signal, indicating that the object should be terminated.",
            "params": [],
            "returns": null,
            "name": "killYourSelf",
            "location": {
              "start": 60,
              "insert": 62,
              "offset": " ",
              "indent": 8,
              "comment": null
            },
            "item_type": "method",
            "length": 4,
            "docLength": null
          },
          {
            "id": "a2ebb705-7932-fb9b-3e45-f965c61ebf4d",
            "ancestors": [
              "8a50128c-009f-a1ac-2c45-674f0e62438e"
            ],
            "description": "Sets the period of a timer and updates the internal variable `Period`.",
            "params": [
              {
                "name": "p",
                "type_name": "int",
                "description": "Used to set the new period for the timer."
              }
            ],
            "returns": null,
            "name": "setPeriod",
            "location": {
              "start": 67,
              "insert": 69,
              "offset": " ",
              "indent": 8,
              "comment": null
            },
            "item_type": "method",
            "length": 5,
            "docLength": null
          }
        ]
      }
    }
  },
  {
    "name": "specificworker.py",
    "path": "agents/long_term_spatial_memory_agent/src/specificworker.py",
    "content": {
      "structured": {
        "description": "An igraph wrapper around a graph and provides several methods for working with it, including inserting new nodes and edges, updating edge attributes, and deleting nodes and edges. The code uses the `igraph` package to interface with the graph. Specifically, it creates a long-term graph (LTG) and a short-term graph (STG), allowing for efficient insertion, deletion, and manipulation of nodes and edges in the LTG while maintaining the integrity of the STG. The code also provides functions to update edge attributes and delete nodes or edges from the graph.",
        "items": [
          {
            "id": "68a48220-ebf4-7cb1-6d46-ec8ae0b47c1b",
            "ancestors": [],
            "description": "Manages a specific node and edge attributes and performs various operations on them, such as updating, inserting, deleting, and attributing. It also keeps track of the current state of the robot and updates the graph accordingly.",
            "attributes": [
              {
                "name": "Period",
                "type_name": "Union[int,str]",
                "description": "Used to store the period of time during which the worker can perform its task, such as a day or a week."
              },
              {
                "name": "agent_id",
                "type_name": "int|str",
                "description": "Used to identify the specific worker instance, allowing the agent to perform tasks and maintain a unique identity during its lifetime."
              },
              {
                "name": "g",
                "type_name": "igraphGraph",
                "description": "Used to represent the long-term graph of the environment, which is updated periodically by the worker."
              },
              {
                "name": "startup_check",
                "type_name": "bool|str",
                "description": "Used to check if the worker has been started or not, with possible values \"yes\", \"no\", or False."
              },
              {
                "name": "rt_api",
                "type_name": "str|int",
                "description": "Used for storing the RT (Real-Time) API ID which represents the current task being executed by the worker."
              },
              {
                "name": "inner_api",
                "type_name": "Dict[str,Any]",
                "description": "Used to store the inner API of the worker, which is a Python function that performs actions related to the worker's task."
              },
              {
                "name": "robot_name",
                "type_name": "str|int",
                "description": "Used to store the name of the robot that will perform a specific task."
              },
              {
                "name": "robot_id",
                "type_name": "int",
                "description": "Used to identify the robot node in the graph, which is the starting point for the worker's movement."
              },
              {
                "name": "last_robot_pose",
                "type_name": "Tuple[float,float,float]",
                "description": "Stored as the last known pose (position, orientation, and scale) of the robot before any actions were taken in the environment."
              },
              {
                "name": "robot_exit_pose",
                "type_name": "str|int",
                "description": "A reference to the pose of the robot when it exits a room. It is used to determine when the robot has reached its goal in a task."
              },
              {
                "name": "state",
                "type_name": "str|int",
                "description": "Used to keep track of the current state of the worker, which can be either \"idle\", \"crossed\", or \"completed\"."
              },
              {
                "name": "affordance_node_active_id",
                "type_name": "int|bool",
                "description": "Used to keep track of the active affordance node ID, which is used to determine when the robot has reached its goal."
              },
              {
                "name": "exit_door_id",
                "type_name": "int|str",
                "description": "Used to store the ID of the door node that leads from a room to the outside world."
              },
              {
                "name": "room_exit_door_id",
                "type_name": "int|str",
                "description": "Used to represent the ID of the door node that leads from a room to the outside world."
              },
              {
                "name": "enter_room_node_id",
                "type_name": "int",
                "description": "Used to store the ID of the room node that the worker is currently entering."
              },
              {
                "name": "vertex_size",
                "type_name": "int|str",
                "description": "Used to keep track of the number of vertices in the graph, which can be useful for various operations such as insertion, deletion, and querying the graph."
              },
              {
                "name": "not_required_attrs",
                "type_name": "List[str]",
                "description": "Used to store a list of attributes that are not required for the worker's functionality, but can be useful for debugging or other purposes."
              },
              {
                "name": "last_save_time",
                "type_name": "datetime|str",
                "description": "Used to store the time when the worker's long-term graph was last saved. It helps track when the graph was last updated for subsequent actions."
              },
              {
                "name": "long_term_graph",
                "type_name": "igraphGraph",
                "description": "Used to store the long-term graph representation of the environment, which is updated over time as new data becomes available."
              },
              {
                "name": "initialize_room_from_igraph",
                "type_name": "Dict[str,Any]",
                "description": "Used to initialize the room graph from an igraph graph. It takes the igraph graph as input and creates a new room graph with the same node IDs and edges as the input igraph."
              },
              {
                "name": "update_robot_pose_in_igraph",
                "type_name": "void",
                "description": "Used to update the pose of a robot node in the graph by inserting a new edge with the correct \"RT\" translation and rotation."
              },
              {
                "name": "insert_current_edge",
                "type_name": "List[Edge]",
                "description": "Used to insert a new edge into the graph with the specified source and target nodes and edge type, effectively setting it as the current edge in the graph."
              },
              {
                "name": "timer",
                "type_name": "int|float",
                "description": "Used to track the time taken by the worker to perform its tasks."
              },
              {
                "name": "compute",
                "type_name": "Callable[[int],str|int]",
                "description": "Defined as a method that takes an integer argument and returns a string or integer value representing the result \nof some computation. It is used in various methods of the worker to perform computations on the graph."
              },
              {
                "name": "update_node",
                "type_name": "Dict[str,Any]",
                "description": "Responsible for updating a node in the graph when the worker's id matches the node's id. It takes three parameters: `id`, `type`, and `door_node`. The method updates the node's attributes based on its type and inserts an RT edge between the node and its parent if necessary."
              },
              {
                "name": "update_edge",
                "type_name": "Union[int,str]",
                "description": "Used to update an edge's type or remove it altogether based on certain conditions."
              }
            ],
            "name": "SpecificWorker",
            "location": {
              "start": 49,
              "insert": 50,
              "offset": " ",
              "indent": 4,
              "comment": null
            },
            "item_type": "class",
            "length": 628,
            "docLength": null
          },
          {
            "id": "ad42c39d-e8e5-3180-aa4c-67d2bbbe477e",
            "ancestors": [
              "68a48220-ebf4-7cb1-6d46-ec8ae0b47c1b"
            ],
            "description": "Initializes the worker's internal state, including its graph, node and edge variables, and timers for computing and updating the graph.",
            "params": [
              {
                "name": "proxy_map",
                "type_name": "dict",
                "description": "Used to pass a mapping of proxy nodes to their corresponding real nodes in the graph."
              },
              {
                "name": "startup_check",
                "type_name": "bool",
                "description": "Set to False by default. It performs a check on the graph upon initialization if it's set to True, otherwise, it does not."
              }
            ],
            "returns": null,
            "usage": {
              "language": "python",
              "code": "from SpecificWorker import SpecificWorker\nimport time\n\n# Initialize the worker with a proxy map and a startup check\nworker = SpecificWorker(proxy_map, True)\n\n# Set up the timer for the compute method\ntimer = time.time()\nworker.setPeriod(100)\nworker.startTimer()\n\nwhile True:\n    # Perform the computation\n    worker.compute()\n    \n    # Check if it's time to save the graph\n    if time.time() - last_save_time > 3600:\n        worker.saveGraph(\"graph.pkl\")\n",
              "description": ""
            },
            "name": "__init__",
            "location": {
              "start": 50,
              "insert": 51,
              "offset": " ",
              "indent": 8,
              "comment": null
            },
            "item_type": "constructor",
            "length": 54,
            "docLength": null
          },
          {
            "id": "61093faf-d7f7-cebb-4d49-712ed045066d",
            "ancestors": [
              "68a48220-ebf4-7cb1-6d46-ec8ae0b47c1b"
            ],
            "description": "Sets parameters and modifies the state of the room by removing a self-edge, storing an exit door ID, and adding attributes to doors.",
            "params": [
              {
                "name": "params",
                "type_name": "bool",
                "description": "Passed to set the parameters of the room."
              }
            ],
            "returns": {
              "type_name": "bool",
              "description": "True."
            },
            "usage": {
              "language": "python",
              "code": "worker = SpecificWorker(proxy_map)\n# setParams takes in a dictionary of parameters as input\nparams = {\"Period\": 10, \"agent_id\": 12}\nworker.setParams(params)\n",
              "description": "\nIn this example, the user creates an instance of the SpecificWorker class and passes a dictionary of parameters to the setParams method. The function then updates the worker's internal state based on the input parameters."
            },
            "name": "setParams",
            "location": {
              "start": 127,
              "insert": 128,
              "offset": " ",
              "indent": 8,
              "comment": null
            },
            "item_type": "method",
            "length": 7,
            "docLength": null
          },
          {
            "id": "cfc1e69d-8797-9087-e844-76a8a7e76242",
            "ancestors": [
              "68a48220-ebf4-7cb1-6d46-ec8ae0b47c1b"
            ],
            "description": "Updates the robot's pose in the graph and performs various actions based on the current state of the robot.",
            "params": [],
            "returns": null,
            "usage": {
              "language": "python",
              "code": "specific_worker = SpecificWorker()\nspecific_worker.compute()\n",
              "description": ""
            },
            "name": "compute",
            "location": {
              "start": 141,
              "insert": 144,
              "offset": " ",
              "indent": 8,
              "comment": null
            },
            "item_type": "method",
            "length": 22,
            "docLength": null
          },
          {
            "id": "8b3d3eed-7010-bd8a-8045-f75833aa77e7",
            "ancestors": [
              "68a48220-ebf4-7cb1-6d46-ec8ae0b47c1b"
            ],
            "description": "Initializes a room in a graph by deleting an edge, finding the robot node and its neighbors, creating a new vertex for the root of the igraph, inserting edges to connect the robot to the room and the room to itself, and updating the robot's parent node attribute.",
            "params": [],
            "returns": null,
            "usage": {
              "language": "python",
              "code": "worker = SpecificWorker(proxy_map, startup_check=False)\nworker.initialize_room_from_igraph()\n",
              "description": "\nThis code uses the Python function \"initialize_room_from_igraph\" to initialize the room from an igraph graph structure. The function is called on a worker object created from the SpecificWorker class, which subclasses GenericWorker."
            },
            "name": "initialize_room_from_igraph",
            "location": {
              "start": 165,
              "insert": 167,
              "offset": " ",
              "indent": 8,
              "comment": null
            },
            "item_type": "method",
            "length": 22,
            "docLength": null
          },
          {
            "id": "aab2b882-aaae-999f-b248-533b7089da3f",
            "ancestors": [
              "68a48220-ebf4-7cb1-6d46-ec8ae0b47c1b"
            ],
            "description": "Updates the robot's pose in an igraph graph based on a RT translation and rotation, taking into account the robot's current location and the surrounding rooms.",
            "params": [],
            "returns": null,
            "usage": {
              "language": "python",
              "code": "# create an instance of SpecificWorker class\nspecific_worker = SpecificWorker(proxy_map)\n\n# call the update_robot_pose_in_igraph method to update robot pose in igraph\nspecific_worker.update_robot_pose_in_igraph()\n",
              "description": ""
            },
            "name": "update_robot_pose_in_igraph",
            "location": {
              "start": 198,
              "insert": 200,
              "offset": " ",
              "indent": 8,
              "comment": null
            },
            "item_type": "method",
            "length": 41,
            "docLength": null
          },
          {
            "id": "67757034-6f36-3890-0942-bd47b1455c70",
            "ancestors": [
              "68a48220-ebf4-7cb1-6d46-ec8ae0b47c1b"
            ],
            "description": "Detects when the robot enters a new room and associates doors based on their proximity to the robot's current position, updating the graph and door attributes accordingly.",
            "params": [],
            "returns": null,
            "usage": {
              "language": "python",
              "code": "# Initialize the worker and specify the startup check parameter as True\nworker = SpecificWorker(proxy_map, startup_check=True)\n\n# Perform an initialization check for the worker\nworker.startup_check()\n\n# Set the agent ID to 13\nworker.agent_id = 13\n\n# Update the robot name to \"Shadow\"\nworker.robot_name = \"Shadow\"\n\n# Update the vertex size to 0\nworker.vertex_size = 0\n\n# Set the state of the worker to idle\nworker.state = \"idle\"\n",
              "description": ""
            },
            "name": "idle",
            "location": {
              "start": 251,
              "insert": 253,
              "offset": " ",
              "indent": 8,
              "comment": null
            },
            "item_type": "method",
            "length": 75,
            "docLength": null
          },
          {
            "id": "51b1dbb4-c5a5-63b2-4b43-06106aa87d12",
            "ancestors": [
              "68a48220-ebf4-7cb1-6d46-ec8ae0b47c1b"
            ],
            "description": "1) retrieves the active affordance node and its parent, 2) sets the exit door ID to the value of the parent attribute, and 3) deletes the edge connecting the current room to itself.",
            "params": [],
            "returns": null,
            "usage": {
              "language": "python",
              "code": "import SpecificWorker\n\n# Create an instance of the SpecificWorker class\nworker = SpecificWorker(proxy_map=your_proxy_map)\n\n# Call the crossed method with no arguments and store the return value in a variable\nroom_state = worker.crossed()\n\n# Print the returned value to see if the function executed successfully\nprint(\"Room state:\", room_state)\n",
              "description": ""
            },
            "name": "crossed",
            "location": {
              "start": 350,
              "insert": 352,
              "offset": " ",
              "indent": 8,
              "comment": null
            },
            "item_type": "method",
            "length": 16,
            "docLength": null
          },
          {
            "id": "d55c53ae-f2c0-628c-ca4e-0ad084fa17b1",
            "ancestors": [
              "68a48220-ebf4-7cb1-6d46-ec8ae0b47c1b"
            ],
            "description": "Determines and sets the ID of the room node to enter upon construction, based on conditions involving the existence of nodes labeled \"room\" and the absence of certain attributes.",
            "params": [],
            "returns": null,
            "usage": {
              "language": "python",
              "code": "from mymodule import SpecificWorker\n\n# Creating an instance of the class and using its method initializing_room\nmyworker = SpecificWorker(proxy_map)\nmyworker.initializing_room()\n\n# The function will be executed within the context of the object,\n# allowing it to modify any attributes or methods associated with it.\n",
              "description": ""
            },
            "name": "initializing_room",
            "location": {
              "start": 370,
              "insert": 373,
              "offset": " ",
              "indent": 8,
              "comment": null
            },
            "item_type": "method",
            "length": 10,
            "docLength": null
          },
          {
            "id": "bdadfa6f-3602-06ad-9c4d-0b5443a38eed",
            "ancestors": [
              "68a48220-ebf4-7cb1-6d46-ec8ae0b47c1b"
            ],
            "description": "Detects the room the robot is currently in and finds the door node leading to the next room. It then creates a new edge in the graph representing the RT pose of the robot and updates the graph with the new edge.",
            "params": [],
            "returns": null,
            "usage": {
              "language": "python",
              "code": "# Initialize a SpecificWorker object named \"worker\"\nworker = SpecificWorker(proxy_map)\n\n# Call the known_room method with a given room name and node ID\nworker.known_room(\"room1\", 234)\n",
              "description": ""
            },
            "name": "known_room",
            "location": {
              "start": 384,
              "insert": 386,
              "offset": " ",
              "indent": 8,
              "comment": null
            },
            "item_type": "method",
            "length": 73,
            "docLength": null
          },
          {
            "id": "911fde00-668a-68ae-d446-d45ece69baae",
            "ancestors": [
              "68a48220-ebf4-7cb1-6d46-ec8ae0b47c1b"
            ],
            "description": "1) retrieves edges leading to the exit door, 2) checks if any matching edges exist, and 3) updates node attributes and associates doors based on the matched edges.",
            "params": [],
            "returns": null,
            "usage": {
              "language": "python",
              "code": "# create a SpecificWorker object\nworker = SpecificWorker(proxy_map)\n\n# initialize the doors in the graph\nworker.initializing_doors()\n",
              "description": ""
            },
            "name": "initializing_doors",
            "location": {
              "start": 478,
              "insert": 480,
              "offset": " ",
              "indent": 8,
              "comment": null
            },
            "item_type": "method",
            "length": 28,
            "docLength": null
          },
          {
            "id": "17a38090-fb25-fbbd-6242-3b9b704aaad8",
            "ancestors": [
              "68a48220-ebf4-7cb1-6d46-ec8ae0b47c1b"
            ],
            "description": "Connects two nodes representing doors in the long-term graph, adding an edge between them and updating their attributes to reflect the connection.",
            "params": [
              {
                "name": "door_1",
                "type_name": "str",
                "description": "A list containing the name of the first door to be associated with another door."
              },
              {
                "name": "door_2",
                "type_name": "str",
                "description": "A string representation of the second door to be associated with the long-term graph."
              }
            ],
            "returns": null,
            "usage": {
              "language": "python",
              "code": "# Initialize the SpecificWorker class object\nworker = SpecificWorker(proxy_map)\n\n# Define two door objects with names and room identifiers\ndoor1 = {\"name\": \"Front Door\", \"room_id\": 2}\ndoor2 = {\"name\": \"Back Door\", \"room_id\": 4}\n\n# Call the associate_doors method on the worker object\nworker.associate_doors(door1, door2)\n",
              "description": ""
            },
            "name": "associate_doors",
            "location": {
              "start": 517,
              "insert": 519,
              "offset": " ",
              "indent": 8,
              "comment": null
            },
            "item_type": "method",
            "length": 16,
            "docLength": null
          },
          {
            "id": "cc21732a-a5cc-7d90-2b4b-65d37df3c117",
            "ancestors": [
              "68a48220-ebf4-7cb1-6d46-ec8ae0b47c1b"
            ],
            "description": "Saves the graph representation of a room node and its exit door id to a file.",
            "params": [],
            "returns": null,
            "usage": {
              "language": "python",
              "code": "from worker import SpecificWorker\n\n# Initialize the worker\nworker = SpecificWorker(proxy_map, startup_check=False)\n\n# Create a new room node\nroom_node = worker.g.vs.find(name=\"New Room\")\nif not room_node:\n    room_node = worker.g.add_vertex(name=\"New Room\")\n\n# Store the graph in pickle format\nwith open(\"graph.pkl\", \"wb\") as f:\n    pickle.dump(worker.long_term_graph.g, f)\n",
              "description": ""
            },
            "name": "store_graph",
            "location": {
              "start": 536,
              "insert": 537,
              "offset": " ",
              "indent": 8,
              "comment": null
            },
            "item_type": "method",
            "length": 11,
            "docLength": null
          },
          {
            "id": "f099c4de-b784-939e-6846-a148b2aeec31",
            "ancestors": [
              "68a48220-ebf4-7cb1-6d46-ec8ae0b47c1b"
            ],
            "description": "Removes edges from the long-term graph based on certain conditions, including room numbers and types of edges.",
            "params": [],
            "returns": null,
            "usage": {
              "language": "python",
              "code": "specific_worker = SpecificWorker(proxy_map, startup_check=True)\nspecific_worker.removing()\n",
              "description": "\nThis code creates a new instance of the `SpecificWorker` class and then calls the `removing` method on it. The `removing` function is defined in the `SpecificWorker` class, and it removes certain elements from the graph using the `delete_node` method. The graph is an attribute of the `SpecificWorker` class, and it represents a long-term spatial memory for a robot named Shadow. The `startup_check` argument passed to the `SpecificWorker` constructor is set to `True`, indicating that the startup check should be performed before the removal process can begin."
            },
            "name": "removing",
            "location": {
              "start": 550,
              "insert": 552,
              "offset": " ",
              "indent": 8,
              "comment": null
            },
            "item_type": "method",
            "length": 19,
            "docLength": null
          },
          {
            "id": "18553e7e-c150-41ac-6742-b52ca312d465",
            "ancestors": [
              "68a48220-ebf4-7cb1-6d46-ec8ae0b47c1b"
            ],
            "description": "Traverses a graph and performs actions based on the type of edges it encounters. It starts at a designated node, then visits the children nodes of that node according to the RT edge type, and repeats this process for each child node until no more actions are left to perform.",
            "params": [
              {
                "name": "node_id",
                "type_name": "int",
                "description": "Represented by the igraph vertex ID of the current node being traversed."
              }
            ],
            "returns": null,
            "usage": {
              "language": "python",
              "code": "specific_worker = SpecificWorker(proxy_map, startup_check=False)\nnode_id = \"a_node_id\"\nspecific_worker.traverse_graph(node_id)\n",
              "description": "\nThis example shows how the traverse_graph method of the SpecificWorker class can be used to start traversing a graph from a specific node. The node ID is passed as an argument to the function, and the function then performs the necessary steps to traverse the graph starting at that node."
            },
            "name": "traverse_graph",
            "location": {
              "start": 576,
              "insert": 578,
              "offset": " ",
              "indent": 8,
              "comment": null
            },
            "item_type": "method",
            "length": 7,
            "docLength": null
          },
          {
            "id": "8ac6a6a7-f160-089e-bb4c-9b09f663081c",
            "ancestors": [
              "68a48220-ebf4-7cb1-6d46-ec8ae0b47c1b"
            ],
            "description": "Traverses the graph, identifying vertices with higher level than the current vertex and adding them to the DSR graph along with their connections.",
            "params": [
              {
                "name": "node",
                "type_name": "igraph.Vertex",
                "description": "Representing a vertex in the graph."
              }
            ],
            "returns": null,
            "usage": {
              "language": "python",
              "code": "specific_worker = SpecificWorker(proxy_map)\nspecific_worker.traverse_igraph(specific_worker.g.vs[0])\n",
              "description": "\nThis code creates a new object of type SpecificWorker and then calls the traverse_igraph method, passing in the first vertex of the graph as an argument. This vertex is used to start the traversal of the graph."
            },
            "name": "traverse_igraph",
            "location": {
              "start": 586,
              "insert": 587,
              "offset": " ",
              "indent": 8,
              "comment": null
            },
            "item_type": "method",
            "length": 10,
            "docLength": null
          },
          {
            "id": "8d4576e6-5bd3-6d9d-6548-08acb2abc696",
            "ancestors": [
              "68a48220-ebf4-7cb1-6d46-ec8ae0b47c1b"
            ],
            "description": "Adds a new vertex to an existing graph, updating the graph's vertices with provided attributes and matching other vertices based on specified conditions.",
            "params": [
              {
                "name": "node",
                "type_name": "igraph.Vertex",
                "description": "Used to represent a single vertex in the graph, including its name, ID, and attributes."
              }
            ],
            "returns": null,
            "usage": {
              "language": "python",
              "code": "worker = SpecificWorker()  # Initiate the class\nnode = Node(name=\"Door\", id=1, type=\"door\")  # Create a node with name and ID\nworker.insert_igraph_vertex(node)  # Pass the node to the function\n",
              "description": "\nThe example shows how a node with name \"Door\" and ID \"1\" is created and then passed to the insert_igraph_vertex() function, which will add it as a vertex in the graph. The function also takes care of any other attributes that may be present in the node object, such as parent or timestamp creation."
            },
            "name": "insert_igraph_vertex",
            "location": {
              "start": 599,
              "insert": 600,
              "offset": " ",
              "indent": 8,
              "comment": null
            },
            "item_type": "method",
            "length": 29,
            "docLength": null
          },
          {
            "id": "705003db-9448-d6bc-2145-c9b70fa2a402",
            "ancestors": [
              "68a48220-ebf4-7cb1-6d46-ec8ae0b47c1b"
            ],
            "description": "Modifies an existing node within a graph, adding new attributes and linking it to its parent node through an attribute.",
            "params": [
              {
                "name": "parent_name",
                "type_name": "str",
                "description": "Used to specify the name of the parent node to insert the new vertex into."
              },
              {
                "name": "node",
                "type_name": "Node | dict",
                "description": "Passed in from caller, it contains attributes that define the vertex to be inserted into graph."
              }
            ],
            "returns": null,
            "usage": {
              "language": "python",
              "code": "specific_worker = SpecificWorker(proxy_map)\nspecific_worker.insert_dsr_vertex(\"parent_name\", {\"type\": \"node_type\", \"name\": \"node_name\"})\n",
              "description": "\nThis example inserts a node with the name \"node_name\" into the graph with the type \"node_type\" and links it to the parent node named \"parent_name\"."
            },
            "name": "insert_dsr_vertex",
            "location": {
              "start": 634,
              "insert": 636,
              "offset": " ",
              "indent": 8,
              "comment": null
            },
            "item_type": "method",
            "length": 9,
            "docLength": null
          },
          {
            "id": "57a732e1-901a-ef80-944c-23f4f0907fda",
            "ancestors": [
              "68a48220-ebf4-7cb1-6d46-ec8ae0b47c1b"
            ],
            "description": "Adds an edge to a long-term graph based on a received edge attribute. It checks if the destination node is the robot, and if so, uses the correct translation and rotation attributes. Otherwise, it uses the provided translation and rotation attributes.",
            "params": [
              {
                "name": "edge",
                "type_name": "GraphEdge",
                "description": "Passed as a whole object containing information about an edge in the graph, including its origin and destination nodes, as well as attribute values such as translation and rotation."
              }
            ],
            "returns": null,
            "usage": {
              "language": "python",
              "code": "worker = SpecificWorker(proxy_map, startup_check=False)\nedge = Edge(\"Origin\", \"Destination\")\nedge.attrs[\"rt_translation\"] = [10, 20, 30]\nedge.attrs[\"rt_rotation_euler_xyz\"] = [45, 90, 180]\nworker.insert_igraph_edge(edge)\n",
              "description": "\nIn this example, a user creates an instance of the SpecificWorker class and then adds an edge to the graph by calling the insert_igraph_edge method with the edge object as an argument. The edge object contains information about the origin and destination nodes of the edge, such as their names or IDs. The method then uses this information to add a new edge to the long-term spatial memory graph with the given translation and rotation attributes."
            },
            "name": "insert_igraph_edge",
            "location": {
              "start": 648,
              "insert": 649,
              "offset": " ",
              "indent": 8,
              "comment": null
            },
            "item_type": "method",
            "length": 12,
            "docLength": null
          },
          {
            "id": "3f1ca468-3163-3ba8-e54f-a2fb9ce810fa",
            "ancestors": [
              "68a48220-ebf4-7cb1-6d46-ec8ae0b47c1b"
            ],
            "description": "Creates a new edge in the long-term graph based on data from the short-term graph. It assigns attributes to the new edge, including a translation and rotation value for RT tracking.",
            "params": [
              {
                "name": "org",
                "type_name": "GraphNode | NoneType",
                "description": "Used to specify the starting node of the edge to be inserted. If it is None, it means the starting node is unknown or unspecified."
              },
              {
                "name": "dest",
                "type_name": "Node | str",
                "description": "Used to specify the destination node or edge id for the edge insertion operation."
              }
            ],
            "returns": null,
            "usage": {
              "language": "python",
              "code": "worker = SpecificWorker(proxy_map)\n# Define the nodes and edges in the graph\nnode1 = Node(\"Node 1\", agent_id=worker.agent_id)\nnode2 = Node(\"Node 2\", agent_id=worker.agent_id)\nedge = Edge(node1, node2, \"RT\", worker.agent_id)\n# Call the function to insert the edge into the graph\nworker.insert_dsr_edge(node1, node2)\n",
              "description": ""
            },
            "name": "insert_dsr_edge",
            "location": {
              "start": 665,
              "insert": 668,
              "offset": " ",
              "indent": 8,
              "comment": null
            },
            "item_type": "method",
            "length": 22,
            "docLength": null
          },
          {
            "id": "04491164-d053-7abe-e94a-0772c85a56b6",
            "ancestors": [
              "68a48220-ebf4-7cb1-6d46-ec8ae0b47c1b"
            ],
            "description": "Determines the room number associated with a given node ID by retrieving the attribute \"room_id\" from the node and returning its value if found, or -1 otherwise.",
            "params": [
              {
                "name": "node_id",
                "type_name": "int",
                "description": "Passed as an argument to the function, indicating the id of the element whose room number needs to be checked."
              }
            ],
            "returns": {
              "type_name": "int",
              "description": "The room ID associated with a given node ID if the node has an attribute \"room_id\" and its value is not None, or -1 otherwise."
            },
            "usage": {
              "language": "python",
              "code": "worker = SpecificWorker(proxy_map)\nnode_id = 1234567890\nroom_id = worker.check_element_room_number(node_id)\nif room_id == -1:\n    print(\"Node is not in a room\")\nelse:\n    print(\"Node is in room\", room_id)\n",
              "description": ""
            },
            "name": "check_element_room_number",
            "location": {
              "start": 695,
              "insert": 696,
              "offset": " ",
              "indent": 8,
              "comment": null
            },
            "item_type": "method",
            "length": 7,
            "docLength": null
          },
          {
            "id": "f912f9d3-d6ed-b482-ee40-a7c750e382d7",
            "ancestors": [
              "68a48220-ebf4-7cb1-6d46-ec8ae0b47c1b"
            ],
            "description": "1) retrieves the element level of a node with the given ID, and 2) handles missing or non-existent element levels by printing an error message and returning -1.",
            "params": [
              {
                "name": "node_id",
                "type_name": "int",
                "description": "Representing an element node identifier, which identifies a specific element in the graph."
              }
            ],
            "returns": {
              "type_name": "int",
              "description": "Element level if found, or -1 otherwise."
            },
            "usage": {
              "language": "python",
              "code": "# Initialize SpecificWorker class instance\nworker = SpecificWorker(proxy_map)\n\n# Get node_id of a specific element in the graph\nnode_id = 123456789\n\n# Call check_element_level function to retrieve level attribute value from node\nelement_level = worker.check_element_level(node_id)\n\n# Print retrieved level attribute value for the specified element\nprint(\"Element level:\", element_level)\n",
              "description": ""
            },
            "name": "check_element_level",
            "location": {
              "start": 704,
              "insert": 705,
              "offset": " ",
              "indent": 8,
              "comment": null
            },
            "item_type": "method",
            "length": 25,
            "docLength": null
          },
          {
            "id": "1141fbc6-886b-ab8c-324d-576e1b3fb114",
            "ancestors": [
              "68a48220-ebf4-7cb1-6d46-ec8ae0b47c1b"
            ],
            "description": "Retrieves and processes information about a room node in a graph, including its ID, old RT edges, translation attribute, and doors. It then draws the room polygon and doors on an image for saving.",
            "params": [
              {
                "name": "room_node_id",
                "type_name": "str | int",
                "description": "Used to identify the room for which the picture will be generated."
              }
            ],
            "returns": null,
            "usage": {
              "language": "python",
              "code": "specific_worker = SpecificWorker(proxy_map)\n# Startup check and initialize the robot's name, id, and last robot pose.\nspecific_worker.startup_check()\n\n# Generate the room picture using the specific worker instance and the desired room node ID.\nroom_node_id = 123456 # Replace with actual node ID\nspecific_worker.generate_room_picture(room_node_id)\n",
              "description": ""
            },
            "name": "generate_room_picture",
            "location": {
              "start": 747,
              "insert": 749,
              "offset": " ",
              "indent": 8,
              "comment": null
            },
            "item_type": "method",
            "length": 24,
            "docLength": null
          },
          {
            "id": "abb52b39-2b77-1e95-5943-2ff31d0cfa5b",
            "ancestors": [
              "68a48220-ebf4-7cb1-6d46-ec8ae0b47c1b"
            ],
            "description": "Inserts or assigns an edge in the graph with the current room ID as the tail and the same ID as the head, indicating that the agent is currently located in that room.",
            "params": [
              {
                "name": "room_id",
                "type_name": "str",
                "description": "Used to represent the id of the current room in which the agent is located."
              }
            ],
            "returns": null,
            "usage": {
              "language": "python",
              "code": "worker = SpecificWorker(proxy_map)\nworker.insert_current_edge(room_id)\n",
              "description": ""
            },
            "name": "insert_current_edge",
            "location": {
              "start": 782,
              "insert": 784,
              "offset": " ",
              "indent": 8,
              "comment": null
            },
            "item_type": "method",
            "length": 3,
            "docLength": null
          },
          {
            "id": "c580b131-a2f7-48b2-d347-fd8315f9d58a",
            "ancestors": [
              "68a48220-ebf4-7cb1-6d46-ec8ae0b47c1b"
            ],
            "description": "Updates the node attributes based on user input and inserts new edges into the graph according to predefined rules.",
            "params": [
              {
                "name": "id",
                "type_name": "int",
                "description": "Used to identify the node to be updated."
              },
              {
                "name": "type",
                "type_name": "str",
                "description": "Used to identify the type of node being updated (door or room)."
              }
            ],
            "returns": null,
            "usage": {
              "language": "python",
              "code": "# Call the function update_node() with parameters\nworker.update_node(1, \"door\")\n",
              "description": "\nIn this code snippet, we call the `update_node()` function in the `SpecificWorker` class by passing two arguments: 1 and \"door\". The first argument is the id of the node to be updated, and the second argument is the type of the node, which is door in this case. This call will update the node with the id 1 with the new type information.\n\nWe can also use `update_node()` to update other types of nodes, such as rooms or affordances, by passing different arguments for the type parameter. For example:\n"
            },
            "name": "update_node",
            "location": {
              "start": 796,
              "insert": 797,
              "offset": " ",
              "indent": 8,
              "comment": null
            },
            "item_type": "method",
            "length": 41,
            "docLength": null
          },
          {
            "id": "1b073fde-9b9f-83a1-3541-533c6e7e206e",
            "ancestors": [
              "68a48220-ebf4-7cb1-6d46-ec8ae0b47c1b"
            ],
            "description": "Updates an edge in the graph based on its type, source node, and target node.",
            "params": [
              {
                "name": "fr",
                "type_name": "int",
                "description": "Representing the first room number of an edge to be updated with new information."
              },
              {
                "name": "to",
                "type_name": "int",
                "description": "Used to identify the target node in the graph for updating the edge."
              },
              {
                "name": "type",
                "type_name": "str",
                "description": "Used to indicate whether the edge is a robot or a room node."
              }
            ],
            "returns": null,
            "usage": {
              "language": "python",
              "code": "worker = SpecificWorker(proxy_map, startup_check=False)\n# Update edge in graph\nworker.update_edge(fr=1, to=2, type=\"RT\")\n",
              "description": "\nThis updates the edge with fr as the starting node and to as the ending node with the type of \"RT\"."
            },
            "name": "update_edge",
            "location": {
              "start": 851,
              "insert": 855,
              "offset": " ",
              "indent": 8,
              "comment": null
            },
            "item_type": "method",
            "length": 5,
            "docLength": null
          }
        ]
      }
    }
  },
  {
    "name": "specificworker_sec.py",
    "path": "agents/long_term_spatial_memory_agent/src/specificworker_sec.py",
    "content": {
      "structured": {
        "description": "An igraph object `self` and implements various operations on a graph, including inserting nodes and edges, updating edge attributes, and deleting nodes and edges. The code uses the `igraph` package to perform these operations. Specifically, it inserts a node in the graph with a certain name and ID, updates the RT translation and rotation of an edge connecting two nodes, and deletes a node and edge from the graph. Additionally, it checks if an affordance node is active and sets the state to \"crossed\" if it is completed and not active.",
        "items": [
          {
            "id": "75233bfc-d379-5786-3e4d-6b16aa1599c4",
            "ancestors": [],
            "description": "Manages a graph representation of a robot navigating through a room, handling various actions such as inserting, updating, and deleting nodes and edges, as well as tracking the current state of the room.",
            "attributes": [
              {
                "name": "Period",
                "type_name": "Union[float,int]",
                "description": "Used to represent the time period for which the worker is active."
              },
              {
                "name": "agent_id",
                "type_name": "int|str",
                "description": "Used to store the unique identifier of the agent in the simulation."
              },
              {
                "name": "g",
                "type_name": "igraphGraph",
                "description": "Used to represent the graph of nodes and edges in the environment. It is used for various operations such as inserting, deleting, updating nodes and edges, and drawing the graph."
              },
              {
                "name": "update_node",
                "type_name": "Dict[str,Any]",
                "description": "Used to update the node attributes of a specific node in the graph based on its ID. It takes two arguments: `id` (int) which is the ID of the node to be updated, and `type` (str) which can be either \"door\" or \"room\" indicating whether the node is a door or room node. The function performs different actions depending on the type of node being updated."
              },
              {
                "name": "update_edge",
                "type_name": "Union[int,str]",
                "description": "Used to update the edge attributes of a robot-room pair based on certain conditions, such as when there is no current edge and the room node exists."
              },
              {
                "name": "startup_check",
                "type_name": "bool|str",
                "description": "Used to check if the worker should perform startup tasks such as inserting a node and edge for a room and robot, and setting the state to \"crossed\"."
              },
              {
                "name": "rt_api",
                "type_name": "str|int",
                "description": "Used to store the ID of the robot that the worker is associated with, allowing the worker to perform RT-based actions."
              },
              {
                "name": "inner_api",
                "type_name": "Dict[str,Any]",
                "description": "Used to store additional APIs that are specific to this worker."
              },
              {
                "name": "robot_name",
                "type_name": "str|int",
                "description": "Used to store the ID of the robot that the worker is associated with."
              },
              {
                "name": "robot_id",
                "type_name": "int",
                "description": "Used to identify the robot that the worker is controlling."
              },
              {
                "name": "last_robot_pose",
                "type_name": "Tuple[float,float,float]",
                "description": "Used to store the last known pose of the robot in the environment, which can be used for various tasks such as path planning and obstacle avoidance."
              },
              {
                "name": "robot_exit_pose",
                "type_name": "str|int",
                "description": "Used to store the exit pose of a robot, which is the position and orientation of the robot when it exits a room."
              },
              {
                "name": "state",
                "type_name": "str|int",
                "description": "Used to keep track of the worker's current state (either \"idle\", \"crossed\", or \"completed\")."
              },
              {
                "name": "affordance_node_active_id",
                "type_name": "int|bool",
                "description": "Used to keep track of the active affordance node ID in the graph. It is used to determine when the affordance node has been completed and can transition to the crossed state."
              },
              {
                "name": "exit_door_id",
                "type_name": "int|str",
                "description": "Used to keep track of the id of the door node that leads from a room to the outside world, which is used for various purposes such as routing, affordance detection, and edge insertion."
              },
              {
                "name": "room_exit_door_id",
                "type_name": "int|str",
                "description": "Used to represent the ID of the door node that marks the exit of a room in the graph. It is used for updating edges and inserting current edges."
              },
              {
                "name": "enter_room_node_id",
                "type_name": "int|str",
                "description": "Used to store the ID of the room node that the worker enters when it completes its task."
              },
              {
                "name": "vertex_size",
                "type_name": "float|int",
                "description": "Used to control the size of the vertices in the graph. It determines the width or height of each vertex in the graph, which can be useful for visualization purposes."
              },
              {
                "name": "not_required_attrs",
                "type_name": "List[str]",
                "description": "Used to store a list of attribute names that are not required for the worker's functionality, i.e., they are optional or non-essential attributes."
              },
              {
                "name": "long_term_graph",
                "type_name": "igraphGraph",
                "description": "Used to store the long-term graph of the environment, which can be different from the short-term graph represented by the `g` attribute."
              },
              {
                "name": "graph",
                "type_name": "igraphGraph",
                "description": "Used to store the current state of the graph, which can be updated and manipulated during the execution of the worker's methods."
              },
              {
                "name": "insert_current_edge",
                "type_name": "List[Edge]",
                "description": "Used to insert a new edge into the graph with the specified from and to nodes, and with the \"current\" type."
              },
              {
                "name": "timer",
                "type_name": "int|str",
                "description": "Used to store a timer for the worker, indicating how long it has been running."
              },
              {
                "name": "compute",
                "type_name": "str|int",
                "description": "Used to store the ID of the node that should be updated or inserted in the graph during computation."
              }
            ],
            "name": "SpecificWorker",
            "location": {
              "start": 49,
              "insert": 50,
              "offset": " ",
              "indent": 4,
              "comment": null
            },
            "item_type": "class",
            "length": 592,
            "docLength": null
          },
          {
            "id": "1652a875-3a7c-04b8-3944-add50b4df62e",
            "ancestors": [
              "75233bfc-d379-5786-3e4d-6b16aa1599c4"
            ],
            "description": "Initializes the worker's internal state, including its graph, node ID, and affordance node active ID. It also connects signals for updating nodes and edges and sets up a timer to call the `compute` method periodically.",
            "params": [
              {
                "name": "proxy_map",
                "type_name": "Dict[str, Any]",
                "description": "Used to store a map of proxy nodes for the specific worker."
              },
              {
                "name": "startup_check",
                "type_name": "bool",
                "description": "Used to check if the graph has already been initialized before creating its inner API. It is set to False by default, meaning no check is performed."
              }
            ],
            "returns": null,
            "usage": {
              "language": "python",
              "code": "# create an instance of SpecificWorker class\nspecific_worker = SpecificWorker(proxy_map, startup_check=False)\n\n# call the function to initialize the worker\nspecific_worker.__init__(proxy_map, startup_check=False)\n",
              "description": "\nIn this example, we create an instance of the `SpecificWorker` class and then call its `__init__` method with the required parameters. The `__init__` method initializes the worker by setting up the necessary connections to the Signals module, creating a new graph if it does not exist, and starting the timer for the computation."
            },
            "name": "__init__",
            "location": {
              "start": 50,
              "insert": 51,
              "offset": " ",
              "indent": 8,
              "comment": null
            },
            "item_type": "constructor",
            "length": 53,
            "docLength": null
          },
          {
            "id": "9e3a3660-ca76-efa0-424c-7384a6dfdac5",
            "ancestors": [
              "75233bfc-d379-5786-3e4d-6b16aa1599c4"
            ],
            "description": "Sets the parameters passed as an argument, then modifies the room by removing a self-edge and adding attributes to doors.",
            "params": [
              {
                "name": "params",
                "type_name": "bool",
                "description": "Passed to set the parameters of the Room object."
              }
            ],
            "returns": {
              "type_name": "bool",
              "description": "True."
            },
            "usage": {
              "language": "python",
              "code": "worker = SpecificWorker(proxy_map)\nworker.setParams({'Period': 50})\n",
              "description": "\nIn this example, we create a new instance of the SpecificWorker class and pass in a proxy map as an argument to its constructor. We then use the setParams method to update the Period attribute of the worker instance to 50."
            },
            "name": "setParams",
            "location": {
              "start": 124,
              "insert": 125,
              "offset": " ",
              "indent": 8,
              "comment": null
            },
            "item_type": "method",
            "length": 7,
            "docLength": null
          },
          {
            "id": "13115bf5-e637-5cb7-b343-250c1fd6afbf",
            "ancestors": [
              "75233bfc-d379-5786-3e4d-6b16aa1599c4"
            ],
            "description": "Computes the RT of a robot in a graph, taking into account the current edges and long-term graph information.",
            "params": [],
            "returns": null,
            "usage": {
              "language": "python",
              "code": "worker = SpecificWorker(proxy_map)\nworker.compute()\n",
              "description": "\nIn this example, the user creates an instance of the class SpecificWorker and calls its compute method to execute the code inside it."
            },
            "name": "compute",
            "location": {
              "start": 138,
              "insert": 141,
              "offset": " ",
              "indent": 8,
              "comment": null
            },
            "item_type": "method",
            "length": 37,
            "docLength": null
          },
          {
            "id": "592108b6-327e-ba98-1c49-e5b2b4fb8c1f",
            "ancestors": [
              "75233bfc-d379-5786-3e4d-6b16aa1599c4"
            ],
            "description": "Checks if there are any \"current\" edges or affordance nodes in the graph, and performs actions based on their existence.",
            "params": [],
            "returns": null,
            "usage": {
              "language": "python",
              "code": "# Creating an instance of the SpecificWorker class\nmy_worker = SpecificWorker(proxy_map=None, startup_check=False)\n\n# Calling the idle method with a loop that lasts for 10 seconds\nfor i in range(int(10000 / my_worker.Period)):\n    my_worker.idle()\n",
              "description": ""
            },
            "name": "idle",
            "location": {
              "start": 182,
              "insert": 184,
              "offset": " ",
              "indent": 8,
              "comment": null
            },
            "item_type": "method",
            "length": 76,
            "docLength": null
          },
          {
            "id": "6aed26f6-3473-6faa-7643-8146c8044dbe",
            "ancestors": [
              "75233bfc-d379-5786-3e4d-6b16aa1599c4"
            ],
            "description": "Determines the current room and updates the state of the worker based on whether it is a known or unknown room.",
            "params": [],
            "returns": null,
            "usage": {
              "language": "python",
              "code": "worker = SpecificWorker(proxy_map)\naffordance_node = worker.g.get_node(affordance_id)\nif affordance_node.attrs[\"parent\"].value:\n    exit_door_id = affordance_node.attrs[\"parent\"].value\n    if exit_door_id:\n        exit_door_id_node = worker.g.get_node(exit_door_id)\n        if exit_door_id_node.attrs[\"connected_room_name\"].value:\n            worker.state = \"known_room\"\n",
              "description": ""
            },
            "name": "crossed",
            "location": {
              "start": 283,
              "insert": 285,
              "offset": " ",
              "indent": 8,
              "comment": null
            },
            "item_type": "method",
            "length": 16,
            "docLength": null
          },
          {
            "id": "ab648f62-f59a-0696-1b4f-b5b4de68bc91",
            "ancestors": [
              "75233bfc-d379-5786-3e4d-6b16aa1599c4"
            ],
            "description": "Initializes the room nodes in the graph, identifying and selecting the entrance node based on the exit door ID, and setting the current state to \"initializing doors\".",
            "params": [],
            "returns": null,
            "usage": {
              "language": "python",
              "code": "# Initiate SpecificWorker class\nworker = SpecificWorker(proxy_map, startup_check=False)\n\n# Run initializing_room method\nworker.initializing_room()\n\n# Do something with the result of initializing_room\nprint(\"Room initialized.\")\n",
              "description": ""
            },
            "name": "initializing_room",
            "location": {
              "start": 303,
              "insert": 306,
              "offset": " ",
              "indent": 8,
              "comment": null
            },
            "item_type": "method",
            "length": 10,
            "docLength": null
          },
          {
            "id": "c91dcd80-22ac-4a9b-be40-5caba44d2d63",
            "ancestors": [
              "75233bfc-d379-5786-3e4d-6b16aa1599c4"
            ],
            "description": "Determines the room the robot is currently in, based on the global map and the robot's position, and updates the graph with the appropriate edges and nodes.",
            "params": [],
            "returns": null,
            "usage": {
              "language": "python",
              "code": "import SpecificWorker\n\n# Create a proxy object for the worker\nworker = SpecificWorker.SpecificWorker()\n\n# Set the agent ID for which to perform the task\nagent_id = 13\n\n# Run the function known_room and pass in the agent ID as an argument\nknown_room_output = worker.known_room(agent_id)\n\n# Print the output of the function\nprint(\"Known room:\", known_room_output)\n",
              "description": ""
            },
            "name": "known_room",
            "location": {
              "start": 317,
              "insert": 319,
              "offset": " ",
              "indent": 8,
              "comment": null
            },
            "item_type": "method",
            "length": 73,
            "docLength": null
          },
          {
            "id": "e7db7e8c-ed5d-4192-e74c-af8b90f950ea",
            "ancestors": [
              "75233bfc-d379-5786-3e4d-6b16aa1599c4"
            ],
            "description": "1) identifies exit edges in the graph, 2) finds matching doors, and 3) associates them to create a connected room hierarchy.",
            "params": [],
            "returns": null,
            "usage": {
              "language": "python",
              "code": "# Assume that \"worker\" is an instance of SpecificWorker class\nworker.initializing_doors()\n",
              "description": "\nIn this example, the initializing_doors method is called on the worker object, which is an instance of the SpecificWorker class. The method then performs various actions such as setting up signals and connecting to a runtime API."
            },
            "name": "initializing_doors",
            "location": {
              "start": 411,
              "insert": 413,
              "offset": " ",
              "indent": 8,
              "comment": null
            },
            "item_type": "method",
            "length": 28,
            "docLength": null
          },
          {
            "id": "5cad0a52-9edf-779c-ab40-f409873f2c7f",
            "ancestors": [
              "75233bfc-d379-5786-3e4d-6b16aa1599c4"
            ],
            "description": "Connects two doors in a graph by adding an edge between them and setting their \"other side door name\" and \"connected room name\" attributes.",
            "params": [
              {
                "name": "door_1",
                "type_name": "str",
                "description": "A string representing the name of the first door to be associated with another door."
              },
              {
                "name": "door_2",
                "type_name": "str | int",
                "description": "Used to represent the name of the second door that needs to be associated with the first door."
              }
            ],
            "returns": null,
            "usage": {
              "language": "python",
              "code": "from igraph import Graph\n\n# Create a graph with two nodes and two edges\ng = Graph()\ng.add_vertices([\"A\", \"B\"])\ng.add_edges([(\"A\", \"B\")])\n\n# Use the associate_doors function to add a door between nodes A and B\nspecific_worker = SpecificWorker(proxy_map)\nspecific_worker.associate_doors(door_1=[\"A\", \"C\"], door_2=[\"B\", \"D\"])\n\n# Print the graph\nprint(g)\n",
              "description": "\nIn this example, we first create a graph with two nodes and one edge using the `add_vertices` and `add_edges` methods. Then, we create an instance of the `SpecificWorker` class and use the `associate_doors` method to add a door between nodes A and B. Finally, we print the graph to show that the door has been added correctly."
            },
            "name": "associate_doors",
            "location": {
              "start": 450,
              "insert": 452,
              "offset": " ",
              "indent": 8,
              "comment": null
            },
            "item_type": "method",
            "length": 16,
            "docLength": null
          },
          {
            "id": "a9f2c249-039d-49a4-e240-853633ecd2f4",
            "ancestors": [
              "75233bfc-d379-5786-3e4d-6b16aa1599c4"
            ],
            "description": "Saves the graph data to a file using pickling.",
            "params": [],
            "returns": null,
            "usage": {
              "language": "python",
              "code": "worker = SpecificWorker(proxy_map, startup_check=True)\nworker.store_graph()\n",
              "description": ""
            },
            "name": "store_graph",
            "location": {
              "start": 469,
              "insert": 470,
              "offset": " ",
              "indent": 8,
              "comment": null
            },
            "item_type": "method",
            "length": 11,
            "docLength": null
          },
          {
            "id": "12a2bcfa-ba36-7bb3-404e-aa001af8fb4c",
            "ancestors": [
              "75233bfc-d379-5786-3e4d-6b16aa1599c4"
            ],
            "description": "Removes edges from the long-term graph that have been labeled as RT or has, based on room numbers. It also deletes nodes in the graph that correspond to shadow nodes.",
            "params": [],
            "returns": null,
            "usage": {
              "language": "python",
              "code": "# Initialize the SpecificWorker class and its associated objects\nsw = SpecificWorker(proxy_map, startup_check=False)\n\n# Define a robot name\nrobot_name = \"Shadow\"\n\n# Call the removing method on the initialized SpecificWorker object\nsw.removing(robot_name)\n",
              "description": ""
            },
            "name": "removing",
            "location": {
              "start": 483,
              "insert": 485,
              "offset": " ",
              "indent": 8,
              "comment": null
            },
            "item_type": "method",
            "length": 19,
            "docLength": null
          },
          {
            "id": "c94afa2d-08b0-cc91-8a47-bf999d91cbf5",
            "ancestors": [
              "75233bfc-d379-5786-3e4d-6b16aa1599c4"
            ],
            "description": "Traverses a directed graph represented by an igraph object, starting from a given node ID. It recursively visits all reachable nodes and inserts edges from the root node to each visited node.",
            "params": [
              {
                "name": "node_id",
                "type_name": "int",
                "description": "Representing the unique identifier of a node in the graph to be traversed."
              }
            ],
            "returns": null,
            "usage": {
              "language": "python",
              "code": "# Creating an instance of SpecificWorker class\nmy_worker = SpecificWorker(proxy_map, startup_check=True)\n\n# Traversing the graph starting from the robot's node\nmy_worker.traverse_graph(my_worker.robot_id)\n\n# Printing the traversed nodes and edges\nfor node in my_worker.g.nodes:\n    print(node.id, node.label)\nfor edge in my_worker.g.edges:\n    print(edge.origin, edge.destination)\n",
              "description": ""
            },
            "name": "traverse_graph",
            "location": {
              "start": 509,
              "insert": 511,
              "offset": " ",
              "indent": 8,
              "comment": null
            },
            "item_type": "method",
            "length": 7,
            "docLength": null
          },
          {
            "id": "8a30575b-5e73-bbab-b148-8adc360d99a5",
            "ancestors": [
              "75233bfc-d379-5786-3e4d-6b16aa1599c4"
            ],
            "description": "Iterates through the graph's successors of a given vertex, and for each successor, it checks if the successor's level is higher than the current vertex's level, and if so, it inserts a new vertex and edge in the DSR and recursively traverses the graph.",
            "params": [
              {
                "name": "node",
                "type_name": "igraph.Vertex",
                "description": "Used to represent a specific vertex in the graph."
              }
            ],
            "returns": null,
            "usage": {
              "language": "python",
              "code": "# Example usage of traverse_igraph()\ng = DSRGraph(0, \"LongTermSpatialMemory_agent\", 13)\nnode = g.get_node(\"My_Node\")\ntraverse_igraph(g, node)\n",
              "description": "\nThis code creates an instance of the class GenericWorker and a graph object named g. It also gets a node from the graph using its name \"My_Node\". Then it calls traverse_igraph() with g as an argument and the node as an argument, which initiates the recursive traversal through the graph starting at the given node."
            },
            "name": "traverse_igraph",
            "location": {
              "start": 519,
              "insert": 520,
              "offset": " ",
              "indent": 8,
              "comment": null
            },
            "item_type": "method",
            "length": 10,
            "docLength": null
          },
          {
            "id": "74851935-7e42-4080-e848-40c81557fc8b",
            "ancestors": [
              "75233bfc-d379-5786-3e4d-6b16aa1599c4"
            ],
            "description": "Adds a vertex to an igraph graph, based on attributes provided by a node object. It also tries to find matching vertices using specific attribute values and adds edges between them if found.",
            "params": [
              {
                "name": "node",
                "type_name": "igraph.Node | dict",
                "description": "Used to add a new vertex to an igraph graph with specified attributes."
              }
            ],
            "returns": null,
            "usage": {
              "language": "python",
              "code": "from GenericWorker import SpecificWorker\n\n# create a new worker instance with proxy_map and startup_check=False\nworker = SpecificWorker(proxy_map, startup_check=False)\n\n# add a vertex to the graph with name='node1', id=2, type='room'\nworker.insert_igraph_vertex(node=SpecificWorkerNode(name='node1', id=2, type='room'))\n\n# add another vertex to the graph with name='node2', id=3, type='room'\nworker.insert_igraph_vertex(node=SpecificWorkerNode(name='node2', id=3, type='room'))\n\n# add an edge between the two vertices\nworker.insert_igraph_edge(origin_node=worker.graph.vs[1], other_side_door_node=worker.graph.vs[2])\n",
              "description": ""
            },
            "name": "insert_igraph_vertex",
            "location": {
              "start": 532,
              "insert": 533,
              "offset": " ",
              "indent": 8,
              "comment": null
            },
            "item_type": "method",
            "length": 28,
            "docLength": null
          },
          {
            "id": "6fb56577-9138-aab8-2145-b8d6dbfab0f8",
            "ancestors": [
              "75233bfc-d379-5786-3e4d-6b16aa1599c4"
            ],
            "description": "Inserts a new vertex into a graph, updating the parent node's attribute with the worker's ID and copying over non-optional attributes from the input node to the new vertex.",
            "params": [
              {
                "name": "parent_name",
                "type_name": "str | str",
                "description": "Used to specify the name of the parent node to insert the new node as."
              },
              {
                "name": "node",
                "type_name": "Node",
                "description": "Passed as an instance of the class `Node`."
              }
            ],
            "returns": null,
            "usage": {
              "language": "python",
              "code": "myWorker = SpecificWorker(proxy_map, startup_check=False)\n# create a new node with name \"NewNode\" and type \"Room\":\nnew_node = myWorker.insert_dsr_vertex(\"MyRobot\", {\"type\": \"Room\", \"name\": \"NewNode\"})\n",
              "description": "\nIn this example, the user creates an instance of the `SpecificWorker` class, then calls the `insert_dsr_vertex` function with the parent node name \"MyRobot\" and a dictionary containing the node type and name. The function returns a new node with the specified attributes."
            },
            "name": "insert_dsr_vertex",
            "location": {
              "start": 567,
              "insert": 569,
              "offset": " ",
              "indent": 8,
              "comment": null
            },
            "item_type": "method",
            "length": 9,
            "docLength": null
          },
          {
            "id": "2addb82a-54dd-dbac-cd4a-bb5786953a0f",
            "ancestors": [
              "75233bfc-d379-5786-3e4d-6b16aa1599c4"
            ],
            "description": "Adds an edge to an existing graph based on information provided by the edge attribute, including translation and rotation values.",
            "params": [
              {
                "name": "edge",
                "type_name": "igraph.Edge | GraphElement",
                "description": "An instance representing a single edge to be inserted into the graph."
              }
            ],
            "returns": null,
            "usage": {
              "language": "python",
              "code": "# Create an instance of the SpecificWorker class and initialize it with the proxy map\nworker = SpecificWorker(proxy_map)\n\n# Insert a new edge into the DSRGraph object\nworker.insert_igraph_edge(Edge(origin=\"Origin\", destination=\"Destination\", rt_translation=0, rt_rotation_euler_xyz=[0, 0, 0]))\n",
              "description": ""
            },
            "name": "insert_igraph_edge",
            "location": {
              "start": 581,
              "insert": 582,
              "offset": " ",
              "indent": 8,
              "comment": null
            },
            "item_type": "method",
            "length": 9,
            "docLength": null
          },
          {
            "id": "9645ce4c-8234-ba84-ff45-3574f5a37212",
            "ancestors": [
              "75233bfc-d379-5786-3e4d-6b16aa1599c4"
            ],
            "description": "Inserts or updates an edge in a graph based on the distance-sensitive roadmap (DSR) algorithm, considering the RT translation and rotation of the edge's endpoints.",
            "params": [
              {
                "name": "org",
                "type_name": "Node | None",
                "description": "Used to specify the source node of the edge being inserted. If `org` is None, it means the root node of the graph."
              },
              {
                "name": "dest",
                "type_name": "Node | str",
                "description": "Used to specify the destination node or name in the graph for which to create a new edge with RT attributes."
              }
            ],
            "returns": null,
            "usage": {
              "language": "python",
              "code": "# Creating a new worker class inheriting from GenericWorker\nclass SpecificWorker(GenericWorker):\n    def __init__(self, proxy_map):\n        super(SpecificWorker, self).__init__(proxy_map)\n        # Initializing the DSR graph with an agent ID and robot name\n        self.agent_id = 13\n        self.robot_name = \"Shadow\"\n        self.g = DSRGraph(0, \"LongTermSpatialMemory_agent\", self.agent_id)\n        # Connecting to the signals of the DSR graph\n        try:\n            signals.connect(self.g, signals.UPDATE_NODE, self.update_node)\n            signals.connect(self.g, signals.UPDATE_EDGE, self.update_edge)\n            console.print(\"signals connected\")\n        except RuntimeError as e:\n            print(e)\n",
              "description": "\nThe user can then use the function insert_dsr_edge to add an edge between two nodes in the DSR graph. Here is an example of how this might be done:\n"
            },
            "name": "insert_dsr_edge",
            "location": {
              "start": 595,
              "insert": 598,
              "offset": " ",
              "indent": 8,
              "comment": null
            },
            "item_type": "method",
            "length": 22,
            "docLength": null
          },
          {
            "id": "c91b9329-a134-37b7-f244-aae2be8f76fd",
            "ancestors": [
              "75233bfc-d379-5786-3e4d-6b16aa1599c4"
            ],
            "description": "Generates a graph based on the layout of a Kamada-Kawai graph, and adds node labels and edge annotations.",
            "params": [],
            "returns": null,
            "usage": {
              "language": "python",
              "code": "# Import necessary libraries and classes\nfrom SpecificWorker import GenericWorker, DSRGraph\nimport signals\nimport console\n\n# Instantiate a new instance of SpecificWorker\nworker = SpecificWorker(proxy_map)\n\n# Define the graph object to be drawn\ngraph = DSRGraph(0, \"LongTermSpatialMemory_agent\", worker.agent_id)\n\n# Connect signals to functions in GenericWorker class\nsignals.connect(graph, signals.UPDATE_NODE, worker.update_node)\nsignals.connect(graph, signals.UPDATE_EDGE, worker.update_edge)\n\n# Draw the graph using the draw_graph function\nworker.draw_graph(graph)\n",
              "description": ""
            },
            "name": "draw_graph",
            "location": {
              "start": 625,
              "insert": 626,
              "offset": " ",
              "indent": 8,
              "comment": null
            },
            "item_type": "method",
            "length": 16,
            "docLength": null
          },
          {
            "id": "29f979ee-26a0-1ca3-4747-685c4ee28371",
            "ancestors": [
              "75233bfc-d379-5786-3e4d-6b16aa1599c4"
            ],
            "description": "Retrieves the room ID associated with a given node ID using the Graph object's `get_node` method and attribute access, and returns the room ID if found, or -1 otherwise.",
            "params": [
              {
                "name": "node_id",
                "type_name": "int",
                "description": "Used to identify the element for which the room number needs to be checked."
              }
            ],
            "returns": {
              "type_name": "int",
              "description": "The room ID of a given element if the element has a \"room_id\" attribute, or -1 otherwise."
            },
            "usage": {
              "language": "python",
              "code": "worker = SpecificWorker(proxy_map, startup_check=False)\nroom_id = worker.check_element_room_number(node_id)\nprint(f\"The room ID of the node with ID {node_id} is {room_id}.\")\n",
              "description": ""
            },
            "name": "check_element_room_number",
            "location": {
              "start": 650,
              "insert": 651,
              "offset": " ",
              "indent": 8,
              "comment": null
            },
            "item_type": "method",
            "length": 7,
            "docLength": null
          },
          {
            "id": "5dddb8ec-4dbc-e387-6e48-64f7ff25662a",
            "ancestors": [
              "75233bfc-d379-5786-3e4d-6b16aa1599c4"
            ],
            "description": "Determines the level of an element with a given ID in the internal graph, handles exceptions, and adjusts door connections based on the room similarity.",
            "params": [
              {
                "name": "node_id",
                "type_name": "int",
                "description": "Used to identify the node being checked for its element level attribute value."
              }
            ],
            "returns": {
              "type_name": "int",
              "description": "The level of an element with the given node ID, or -1 if no such attribute is found."
            },
            "usage": {
              "language": "python",
              "code": "# Example of using the check_element_level function\n\n# Create a new instance of the SpecificWorker class\nmy_worker = SpecificWorker(proxy_map, startup_check=False)\n\n# Call the check_element_level function with node_id as an argument\nelement_level = my_worker.check_element_level(\"node_id\")\n",
              "description": ""
            },
            "name": "check_element_level",
            "location": {
              "start": 659,
              "insert": 660,
              "offset": " ",
              "indent": 8,
              "comment": null
            },
            "item_type": "method",
            "length": 25,
            "docLength": null
          },
          {
            "id": "d812eadc-e596-7a97-8447-d13ce3895f4d",
            "ancestors": [
              "75233bfc-d379-5786-3e4d-6b16aa1599c4"
            ],
            "description": "Retrieves information about a room and its RT edges, then draws the room polygon and doors on an image.",
            "params": [
              {
                "name": "room_node_id",
                "type_name": "str | int",
                "description": "Represented as an integer or string, representing the node ID of the room to be drawn."
              }
            ],
            "returns": null,
            "usage": {
              "language": "python",
              "code": "# Importing necessary packages\nfrom SpecificWorker import SpecificWorker\nimport cv2\n\n# Create a new instance of the class SpecificWorker\nworker = SpecificWorker(proxy_map, startup_check=False)\n\n# Call the generate_room_picture method with the desired room node ID as an argument\nroom_node_id = \"Room1\"\nworker.generate_room_picture(room_node_id)\n",
              "description": "\nThis code creates a new instance of the SpecificWorker class, imports the necessary packages, and calls the generate_room_picture method with the desired room node ID as an argument. The function will then generate a 2D image of the room based on the information stored in the graph. The resulting image can be viewed using the OpenCV library by calling cv2.imwrite() or displayed directly using the OpenCV library's display() method."
            },
            "name": "generate_room_picture",
            "location": {
              "start": 702,
              "insert": 704,
              "offset": " ",
              "indent": 8,
              "comment": null
            },
            "item_type": "method",
            "length": 24,
            "docLength": null
          },
          {
            "id": "a50d6999-6284-35be-614f-deef0dec204d",
            "ancestors": [
              "75233bfc-d379-5786-3e4d-6b16aa1599c4"
            ],
            "description": "Inserts or assigns an edge to the graph representing the current room of the agent, with the source and destination being the same agent ID.",
            "params": [
              {
                "name": "room_id",
                "type_name": "str",
                "description": "Passed as an argument to Edge constructor, representing the ID of the current room that the agent is in."
              }
            ],
            "returns": null,
            "usage": {
              "language": "python",
              "code": "worker = SpecificWorker(proxy_map)\nroom_id = 254\nworker.insert_current_edge(room_id)\n",
              "description": ""
            },
            "name": "insert_current_edge",
            "location": {
              "start": 737,
              "insert": 739,
              "offset": " ",
              "indent": 8,
              "comment": null
            },
            "item_type": "method",
            "length": 3,
            "docLength": null
          },
          {
            "id": "9bc1d031-9b8b-578b-b14d-26d0bcd00d92",
            "ancestors": [
              "75233bfc-d379-5786-3e4d-6b16aa1599c4"
            ],
            "description": "Updates a node's information based on its type and other factors, such as checking if a door node exists and inserting it into the graph if necessary, or handling an affordance node's state change.",
            "params": [
              {
                "name": "id",
                "type_name": "int",
                "description": "Used as an identifier for a node in the graph."
              },
              {
                "name": "type",
                "type_name": "str",
                "description": "Used to indicate the type of node being updated."
              }
            ],
            "returns": null,
            "usage": {
              "language": "python",
              "code": "worker = SpecificWorker(proxy_map, startup_check=True)\nif worker.rt_api.is_running():\n    print(\"Robot is running\")\nelse:\n    print(\"Robot is not running\")\n    return\n\n# Update node with id 123 and type \"door\"\nworker.update_node(123, \"door\")\n",
              "description": ""
            },
            "name": "update_node",
            "location": {
              "start": 751,
              "insert": 752,
              "offset": " ",
              "indent": 8,
              "comment": null
            },
            "item_type": "method",
            "length": 41,
            "docLength": null
          },
          {
            "id": "0c89aab3-c848-cb96-6046-4854f3cd0019",
            "ancestors": [
              "75233bfc-d379-5786-3e4d-6b16aa1599c4"
            ],
            "description": "Updates an edge in the graph based on the current node, type, and other conditions.",
            "params": [
              {
                "name": "fr",
                "type_name": "int",
                "description": "Referred to as \"from room\" indicating that it represents the starting point of an edge in the graph, specifically a room node."
              },
              {
                "name": "to",
                "type_name": "int",
                "description": "The id of the target node to which the edge is being updated."
              },
              {
                "name": "type",
                "type_name": "str",
                "description": "Used to specify the type of edge being updated (either \"RT\" or \"FT\")."
              }
            ],
            "returns": null,
            "usage": {
              "language": "python",
              "code": "# Instantiate an object of SpecificWorker class\nworker = SpecificWorker()\n\n# Set the robot name and ID\nworker.robot_name = \"Shadow\"\nworker.robot_id = 13\n\n# Update the edge with type 'RT' between node 0 (the robot) and node 1 (a room exit door)\nworker.update_edge(fr=0, to=1, type=\"RT\")\n",
              "description": ""
            },
            "name": "update_edge",
            "location": {
              "start": 806,
              "insert": 810,
              "offset": " ",
              "indent": 8,
              "comment": null
            },
            "item_type": "method",
            "length": 5,
            "docLength": null
          }
        ]
      }
    }
  }
]